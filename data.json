[
    {
        "id": 1,
        "question": "Given an array arr, use selection sort to sort arr[] in increasing order.\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: Maintain sorted (in bold) and unsorted subarrays.\nSelect 1. Array becomes 1 4 3 9 7.\nSelect 3.  Array becomes 1 3 4 9 7.\nSelect 4. Array becomes 1 3 4 9 7.\nSelect 7. Array becomes 1 3 4 7 9.\nSelect 9. Array becomes 1 3 4 7 9.\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nInput: arr[] = [38, 31, 20, 14, 30]\nOutput: [14, 20, 30, 31, 38]\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^3\n1 \u2264 arr[i] \u2264 10^6",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Selection Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/selection-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/1_Selection_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "This is an unstable sorting algorithm but can be made stable to maintain relative\nordering of element but will increase time complexity.\nThis algorithms worst,best,avg time complexity is O(N^2)\nIn each iteration place the minimum/maximum most element to its correct place.\nFor example for ascending in 1st iteration place the most minimum to 0th index\n, next iteration 2nd minimum to 1st index like this.",
                "code": "class Solution:\n    def selectionSort(self, arr: list[int]):\n        for i in range(len(arr)):\n            min_idx = i\n            for j in range(i, len(arr)):\n                if arr[j] < arr[min_idx]:\n                    min_idx = j\n            arr[i], arr[min_idx] = arr[min_idx], arr[i]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given an array, arr[]. Sort the array using bubble sort algorithm.\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nInput: arr[] = [1, 2, 3, 4, 5]\nOutput: [1, 2, 3, 4, 5]\n\nExplanation: An array that is already sorted should remain unchanged after applying bubble sort.\n\nConstraints:\n1 <= arr.size() <= 10^3\n1 <= arr[i] <= 10^3",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Bubble Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/bubble-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/2_Bubble_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.This is a stable\nsorting algo.\nIn each iteration place the minimum/maximum most element to the end of\nthe array making swaps on the go.For example , for ascending order in\nfirst iteration the most maximum will be placed at last,then next iteration\n2nd maximum will be placed at 2nd last index like this.",
                "code": "class Solution:\n    # Function to sort the array using bubble sort algorithm.\n    def bubbleSort(self, arr: list[int]):\n        for i in range(\n            len(arr) - 1\n        ):  # since at last iteration last element will be at its correct place\n            did_swap = False\n            for j in range(0, len(arr) - i - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                    did_swap = True\n\n            if not did_swap:  # if array is sorted no swaps will take place\n                break",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "The task is to complete the insertsort() function which is used to implement Insertion Sort.\n\nExamples:\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: The sorted array will be [1, 3, 4, 7, 9].\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nExplanation: The sorted array will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\nInput: arr[] = [4, 1, 9]\nOutput: [1, 4, 9]\nExplanation: The sorted array will be [1, 4, 9].\n\nConstraints:\n1 <= arr.size() <= 1000\n1 <= arr[i] <= 1000",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Insertion Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/insertion-sort/0",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/3_Insertion_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.\nThis is a stable sorting algo.\nIn this algorithm in every pass we try to place the\nnumber at its correct position,from the current position\nin which the number is in we try to check with its left\nneighbours whether its lesser than its left neighbour,\nif its lesser than its left neighbour we swap places\nwe keep doing it unitl its placed in its correct place",
                "code": "class Solution:\n    def insertionSort(self, arr: list[int]):\n        # we start from 1 index as 1 does not have any left neighbours\n        for i in range(1, len(arr)):\n            j = i\n            while j > 0 and arr[j] < arr[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                j -= 1\n\n        return arr",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given an array of integers nums, sort the array in ascending order and return it.\n\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the\nsmallest space complexity possible.\n\nExample 1:\n\nInput: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions\nof other numbers are changed (for example, 1 and 5).\n\nExample 2:\n\nInput: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique.\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-5 * 10^4 <= nums[i] <= 5 * 10^4",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Merge Sort",
        "problem_link": "https://leetcode.com/problems/sort-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/4_Merge_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(N)+O(N)",
                "intuition": "This algorithms worst,avg,best time complexity is O(Nlog(N)).\nThis also use a recursion stack space of O(N) and O(N) auxiliary space to\nstore array elements.\nThis is a stable sorting algo.\nWe follow a divide and conquer strategy we keep divind the\narray into 2 equal halves until they cannot be divided or we are left with array with one element\nand then we keep on merging the two halves until no subarrays are left.",
                "code": "from typing import List\n\n\nclass Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> None:\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> None:\n        if l >= h:  # array has 1 element\n            return\n\n        mid = (l + h) // 2\n\n        self.mergeSort(l, mid, arr)\n        self.mergeSort(mid + 1, h, arr)\n        self.merge(l, mid, h, arr)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(0, len(nums) - 1, nums)\n        return nums",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Implement Quick Sort, a Divide and Conquer algorithm, to sort an array, arr[] in ascending order. Given an array, arr[], with starting index low and ending index high, complete the functions partition() and quickSort(). Use the last element as the pivot so that all elements less than or equal to the pivot come before it, and elements greater than the pivot follow it.\n\nNote: The low and high are inclusive.\n\nExamples:\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: After sorting, all elements are arranged in ascending order.\n\nInput: arr[] = [2, 1, 6, 10, 4, 1, 3, 9, 7]\nOutput: [1, 1, 2, 3, 4, 6, 7, 9, 10]\nExplanation: Duplicate elements (1) are retained in sorted order.\n\nInput: arr[] = [5, 5, 5, 5]\nOutput: [5, 5, 5, 5]\nExplanation: All elements are identical, so the array remains unchanged.\n\nConstraints:\n1 <= arr.size() <= 10^5\n1 <= arr[i] <= 10^5",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Quick Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/quick-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/5_Quick_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "This algorithms avg,best time complexity is O(Nlog(N)) and worst case\ntime complexity is O(N^2).\nThis is a unstable sorting algo.\nWe pick a pivot,pivot can be first,last element.we try to place all\nthe elements smaller to pivot to its left and bigger to right,\nnow this two partions (left and right) created are sorted recursively with the same logic.\ntake 2 pointers i and j i points to start and j points to end given in the function call.\nfor finding pivot find the first smallest from right anf first biggest from left.\nkeep doing this till i<j and swap after every finding of these two position.\natlast place pivot at its correct place swap pivot with j and return j.",
                "code": "class Solution:\n    # Function to sort a list using quick sort algorithm.\n    def quickSort(self, arr: list[int], low: int, high: int):\n        if low >= high:  # return if has only one element\n            return\n\n        pivot = self.partitionv2(arr, low, high)\n        self.quickSort(arr, low, pivot - 1)\n        self.quickSort(arr, pivot + 1, high)\n\n    def partitionv2(self, arr: list[int], low: int, high: int) -> int:  # algorithmic\n        i, j = low, high\n        pivot = arr[low]\n\n        while i < j:\n            # bigger from left\n            while i < high and arr[i] <= pivot:\n                i += 1\n\n            # smaller from right\n            while j > low and arr[j] > pivot:\n                j -= 1\n\n            # swap only of i<j\n            if i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n\n        # place the pivot in its correct place\n        arr[low], arr[j] = arr[j], arr[low]\n\n        return j\n\n    # Naive way of partitioning [last as pivot]\n    def partitionv1_0(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[high]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low, high):  # ignore the last element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)\n\n    # Naive way of partitioning [first as pivot]\n    def partitionv1_1(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[low]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low + 1, high + 1):  # ignore the first element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given a string arr consisting of lowercase english letters, arrange all its letters in lexicographical order using Counting Sort.\n\nExample 1:\n\nInput:\nN = 5\nS = \"edsab\"\nOutput:\nabdes\nExplanation:\nIn lexicographical order, string will be\nabdes.\nExample 2:\n\nInput:\nN = 13\nS = \"geeksforgeeks\"\nOutput:\neeeefggkkorss\nExplanation:\nIn lexicographical order, string will be\neeeefggkkorss.\nYour Task:\nThis is a function problem. You only need to complete the function countSort() that takes string arr as a parameter and returns the sorted string. The printing is done by the driver code.\n\nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(N).\n\nConstraints:\n1 \u2264 N \u2264 10^5",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Count Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/counting-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/6_Count_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(N+26)",
                "sc": "S.C  - O(26)+O(N)",
                "intuition": "This is a non comparison basesd algo\nThis algo work best when all input elements are within a given range k.\nThis algorithms avg,best,worst time complexity is O(Nlog(N)) and worst case\nThis is a unstable sorting algo.\ncreate a count array of size either max element+1 or given k+1\nstore the frequence of each element in the count array\nthen replace everything in the count array with prefix sum\nsuch that count[i]=count[i]+count[i-1]\nloop from back of the input array suppose we enconter number 2\nin our input array then we go to the index 2 in the count array\nthe value at that index 2 will gives us where to place 2 in the final output array\ndecrement count of 2 in the count array\nplace the 2 in that index postion got from count array",
                "code": "class Solution:\n    def countSort(self, arr: list[str]):\n        count_arr = [0] * 27\n\n        # calculate frequency\n        for char in arr:\n            count_arr[ord(char) - 97] += 1\n\n        # calculate prefix sum\n        for i in range(1, len(count_arr)):\n            count_arr[i] = count_arr[i] + count_arr[i - 1]\n\n        # build output array\n        out = [\"\"] * len(arr)\n        for i in range(len(arr) - 1, -1, -1):\n            num = ord(arr[i]) - 97\n            count_arr[num] -= 1\n            out[count_arr[num]] = arr[i]\n\n        return \"\".join(out)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "You are given an integer array nums containing n + 1 integers where each integer is in the\nrange [1, n]. There is only one duplicate number in the array, but it could be repeated more than once.\nYou must solve the problem without modifying the input array and using O(1) extra space.\n\n\nInput: nums = [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\nInput: nums = [1, 3, 4, 2]\nOutput: [1, 2, 3, 4]\n\nInput: nums = [2, 1, 3]\nOutput: [1, 2, 3]",
        "topic": "Sorting",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Cyclic Sort",
        "problem_link": "NA",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/7_Cyclic_Sort.py",
        "approaches": [
            {
                "tc": "T.C. - O(N-1+n) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Check whether current number is at its correct index\nThis algorithm works for small ranged numbers\nmust be in range of 1 to N or 0 to N\nFor one based indexing , correct index of number is val-1\nFor one based indexing , element at index i should be at i+1\nFor zero based indexing , correct index of number is val\nFor zero based indexing , element at index i should be at i\nAlways remember -> ignore numbers greater than size of array for zero based indexing\nAlways remember -> cyclic sort will make the duplicate numbers go at wrong place\nAlways remember -> duplicate numbers will not be at its correct place say i , then nums[i] is the duplicate and i+1 is missing",
                "code": "from typing import List\n\n\ndef cyclic_sort(nums: List[int]) -> None:\n    i = 0\n    while i < len(nums):\n        actualPos = nums[i] - 1\n        if nums[actualPos] != nums[i]:\n            nums[i], nums[actualPos] = nums[actualPos], nums[i]\n        else:\n            i += 1\n\n\nif __name__ == \"__main__\":\n    # Test cases\n    nums1 = [3, 1, 4, 2]\n    cyclic_sort(nums1)\n    assert nums1 == [1, 2, 3, 4], f\"Test case 1 failed: expected [1, 2, 3], got {nums1}\"\n\n    nums2 = [1, 3, 4, 2]\n    cyclic_sort(nums2)\n    assert nums2 == [1, 2, 3, 4], f\"Test case 2 failed: expected [1, 2, 3], got {nums2}\"\n\n    nums3 = [2, 1, 3]\n    cyclic_sort(nums3)\n    assert nums3 == [1, 2, 3], f\"Test case 3 failed: expected [1, 2, 3], got {nums3}\"\n\n    nums4 = [4, 3, 2, 1]\n    cyclic_sort(nums4)\n    assert nums4 == [\n        1,\n        2,\n        3,\n        4,\n    ], f\"Test case 4 failed: expected [1, 2, 3, 4], got {nums4}\"\n\n    nums5 = [5, 4, 3, 2, 1]\n    cyclic_sort(nums5)\n    assert nums5 == [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ], f\"Test case 5 failed: expected [1, 2, 3, 4, 5], got {nums5}\"\n\n    print(\"All test cases passed!\")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "Given an array arr[]. The task is to find the largest element and return it.\n\nExamples:\n\nInput: arr[] = [1, 8, 7, 56, 90]\nOutput: 90\nExplanation: The largest element of the given array is 90.\n\nInput: arr[] = [5, 5, 5, 5]\nOutput: 5\nExplanation: The largest element of the given array is 5.\n\nInput: arr[] = [10]\nOutput: 10\nExplanation: There is only one element which is the largest.\n\nConstraints:\n1 <= arr.size()<= 10^6\n0 <= arr[i] <= 10^6",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Largest element in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/largest-element-in-array4009/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/1_Largest_element_in_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Sort the array in descending order to get largest element at index 0",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        return sorted(arr, reverse=True)[0]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "traverse the entire array to find the max element",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        max_element = arr[0]\n\n        for i in range(1, len(arr)):\n            if arr[i] > max_element:\n                max_element = arr[i]\n\n        return max_element",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given an array of positive integers arr[], return the second largest element from the array. If the second largest element doesn't exist then return -1.\n\nNote: The second largest element should not be equal to the largest element.\n\nExamples:\n\nInput: arr[] = [12, 35, 1, 10, 34, 1]\nOutput: 34\nExplanation: The largest element of the array is 35 and the second largest element is 34.\n\nInput: arr[] = [10, 5, 10]\nOutput: 5\nExplanation: The largest element of the array is 10 and the second largest element is 5.\n\nInput: arr[] = [10, 10, 10]\nOutput: -1\nExplanation: The largest element of the array is 10 and the second largest element does not exist.\n\nConstraints:\n2 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^5",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Second Largest in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/second-largest3735/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/2_Second_Largest_in_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "first find the largest then again find the largest excluding already found largest value",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > largest:\n                largest = arr[i]\n\n        sec_largest = -1\n        for j in range(len(arr)):\n            if arr[j] != largest and arr[j] > sec_largest:\n                sec_largest = arr[j]\n\n        return sec_largest",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "in one pass we try to find max and sec_largest\nby utilizing 2 condition\n+ if current element is greater than sec_largest,but smaller than largest\n+ if current element is greater than largest",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        sec_largest = -1\n\n        for i in range(1, len(arr)):\n            if arr[i] < largest and arr[i] > sec_largest:\n                sec_largest = arr[i]\n\n            if arr[i] > largest:\n                sec_largest = largest\n                largest = arr[i]\n\n        return sec_largest",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\n\nExample 1:\n\nInput: nums = [10,20,30,5,10,50]\nOutput: 65\nExplanation: [5,10,50] is the ascending subarray with the maximum sum of 65.\nExample 2:\n\nInput: nums = [10,20,30,40,50]\nOutput: 150\nExplanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\nExample 3:\n\nInput: nums = [12,17,15,13,10,11,12]\nOutput: 33\nExplanation: [10,11,12] is the ascending subarray with the maximum sum of 33.\n\n\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Max Ascending Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-ascending-subarray-sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/3_Max_Ascending_Subarray_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep track of curr_sum and max_sum\nwhenever a peak drop comes update max_sum\nkeep adding to curr_sum",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = -sys.maxsize\n        curr_sum = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i - 1]:\n                max_sum = max(curr_sum, max_sum)\n                curr_sum = nums[i]\n            else:\n                curr_sum += nums[i]\n\n        max_sum = max(curr_sum, max_sum)\n\n        return max_sum",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given an array arr[], check whether it is sorted in non-decreasing order. Return true if it is sorted otherwise false.\n\nExamples:\n\nInput: arr[] = [10, 20, 30, 40, 50]\nOutput: true\nExplanation: The given array is sorted.\n\nInput: arr[] = [90, 80, 100, 70, 40, 30]\nOutput: false\nExplanation: The given array is not sorted.\n\nConstraints:\n1 \u2264 arr.size \u2264 10^6\n- 10^9 \u2264 arr[i] \u2264 10^9",
        "topic": "ArraysandHashing",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check Array Sorted",
        "problem_link": "https://practice.geeksforgeeks.org/problems/check-if-an-array-is-sorted0701/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/4_Check_Array_Sorted.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep checking that current element must be greater than equal to previous element\nif current element lesser than previous element return false",
                "code": "class Solution:\n    def arraySortedOrNot(self, arr) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Given an array nums, return true if the array was originally sorted in non-decreasing order,\nthen rotated some number of positions (including zero). Otherwise, return false.\n\nThere may be duplicates in the original array.\n\nNote: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.\n\n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: true\nExplanation: [1,2,3,4,5] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the element of value 3: [3,4,5,1,2].\nExample 2:\n\nInput: nums = [2,1,3,4]\nOutput: false\nExplanation: There is no sorted array once rotated that can make nums.\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: true\nExplanation: [1,2,3] is the original sorted array.\nYou can rotate the array by x = 0 positions (i.e. no rotation) to make nums.\n\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "topic": "ArraysandHashing",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check Array is Sorted and Rotated",
        "problem_link": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/5_Check_Array_is_Sorted_and_Rotated.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "keep rotating the array by one n times then check if the current rotated array is sorted or not if in at any pass we see that the array becomes equal to its sorted state we return true otherwise we return false  Suppose ->  [3 4 5 1 2] ----- --- R1    R2 Check for valid increasing order in region I Check for valid increasing order in region II and also all elements in region II should be lesser than equal to first element in region I Think for [1,3,2] also for return case",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotateByOne(self, nums: list[int]):\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def check_array_sorted(self, nums: list[int]) -> bool:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                return False\n        return True\n\n    def check(self, nums: List[int]) -> bool:\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            if self.check_array_sorted(nums):\n                return True\n        return False\n\n\n# Optimal1\n# T.C. - O(N)\n# S.C  - O(1)\n\nfrom typing import List\n\n\nclass Solution:\n    def check(self, nums: List[int]) -> bool:\n        break_point = -1\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                break_point = i\n                break\n\n        if break_point == -1:\n            return True\n\n        first_element = nums[0]\n        for j in range(break_point + 1, len(nums)):\n            if nums[j] > first_element:\n                return False\n            if nums[j] < nums[j - 1]:\n                return False\n\n        return True if nums[-1] <= nums[0] else False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Suppose ->  [3 4 5 1 2]\nNumber of dips should be 0 or 1\nif more than 1 return False\nThink for [1,3,2] also for return case",
                "code": "from typing import List\n\n\nclass Solution:\n    def check(self, nums: List[int]) -> bool:\n        dips = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                dips += 1\n\n            if dips > 1:\n                return False\n\n        if dips == 0:\n            return True\n\n        return nums[-1] <= nums[0] and dips == 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once.\nThe relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\nassert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Remove Duplicates Sorted Array",
        "problem_link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/6_Remove_Duplicates_Sorted_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(Klog(K))+O(K)",
                "sc": "S.C  - O(K)",
                "intuition": "store the unique nums to a set datastructure fill the first k position of the array with elements in the datastructure",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        visited_nums = set()\n        for i in range(len(nums)):\n            visited_nums.add(nums[i])\n\n        for idx, val in enumerate(\n            sorted(visited_nums)\n        ):  # since sets do not maintain order we need to sort again\n            nums[idx] = val\n\n        return len(visited_nums)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "keep track of k which is the last element inserted position\nwe also declare a last num which keeps track of the last number visited\nif we visit a new number we update last visited num and insert the number\nat k position and atlast return k",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 1\n        last_visted_num = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != last_visted_num:\n                last_visted_num = nums[i]\n                nums[k] = nums[i]\n                k += 1\n            else:\n                last_visted_num = nums[i]\n        return k",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "You are given an integer array arr of size n. You need to implement two functions to perform rotations on this array:\n\nLeft Rotate: Implement a function left_rotate(arr: List[int]) -> List[int] that rotates the array to the left by one position. The first\nelement of the array should move to the end.\n\nRight Rotate: Implement a function right_rotate(arr: List[int]) -> List[int] that rotates the array to the right by one position.\nThe last element of the array should move to the front.\n\nLeft Rotate Test Cases:\n\nExample 1:\n\nInput:\narr = [1, 2, 3, 4, 5]\n\nOutput:\n[2, 3, 4, 5, 1]\n\nExample 2:\n\nInput:\narr = [10, 20, 30, 40, 50]\n\nOutput:\n[20, 30, 40, 50, 10]\n\n--------------------------------\n\nRight Rotate Test Cases:\n\nExample 1:\n\nInput:\narr = [1, 2, 3, 4, 5]\n\nOutput:\n[5, 1, 2, 3, 4]\n\nExample 2:\n\nInput:\narr = [10, 20, 30, 40, 50]\n\nOutput:\n[50, 10, 20, 30, 40]\n\nConstraints:\n\nThe input array will contain at least one integer.\nThe array can contain both positive and negative integers.\n\n\nIntuition",
        "topic": "ArraysandHashing",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Left Rotate Right Rotate Array By One",
        "problem_link": "NA",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/7_Left_Rotate_Right_Rotate_Array_By_One.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "For left rotation move the first element to the last index by continous swapping\nFor right rotation move the last element to the first index by continous swapping",
                "code": "from typing import List\n\n\ndef left_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1):\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n    return arr\n\n\ndef right_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[i - 1] = arr[i - 1], arr[i]\n    return arr\n\n\n# Example usage with assertions\nif __name__ == \"__main__\":\n    # Test left rotation\n    assert left_rotate([1, 2, 3, 4, 5]) == [2, 3, 4, 5, 1], \"Test Case 1 Failed\"\n    assert left_rotate([10, 20, 30, 40, 50]) == [\n        20,\n        30,\n        40,\n        50,\n        10,\n    ], \"Test Case 2 Failed\"\n    assert left_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    # Test right rotation\n    assert right_rotate([1, 2, 3, 4, 5]) == [5, 1, 2, 3, 4], \"Test Case 1 Failed\"\n    assert right_rotate([10, 20, 30, 40, 50]) == [\n        50,\n        10,\n        20,\n        30,\n        40,\n    ], \"Test Case 2 Failed\"\n    assert right_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    print(\"All test cases passed!\")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given an array arr[]. The task is to rotate the array by d elements where d \u2264 arr.size.\n\nExamples:\n\nInput: arr[] = [-1, -2, -3, 4, 5, 6, 7], d = 2\nOutput: [-3, 4, 5, 6, 7, -1, -2]\nExplanation:\nRotate by 1: [-2, -3, 4, 5, 6, 7, -1]\nRotate by 2: [-3, 4, 5, 6, 7, -1, -2]\n\nInput: arr[] = [1, 3, 4, 2], d = 3\nOutput: [2, 1, 3, 4]\nExplanation: After rotating the array three times, the first three elements shift one by one to the right.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(1)\n\nConstraints:\n1 \u2264 arr.size \u2264 10^6\n-10^9 \u2264 arr[i] \u2264 10^9\n0 \u2264 d \u2264 arr.size",
        "topic": "ArraysandHashing",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Rotate Left K Places",
        "problem_link": "https://practice.geeksforgeeks.org/problems/reversal-algorithm5340/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/8_Rotate_Left_K_Places.py",
        "approaches": [
            {
                "tc": "T.C. - O(d*N)",
                "sc": "S.C  - O(1)",
                "intuition": "keep left rotating by one place for d times",
                "code": "class Solution:\n    def rotate(self, arr: list[int]):\n        for i in range(len(arr) - 1):\n            arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    def leftRotate(self, arr: list[int], d: int) -> None:\n        while d:\n            self.rotate(arr)\n            d -= 1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(k)+O(N-k)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "reverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nreverse the whole array",
                "code": "class Solution:\n    def leftRotate(self, arr: list[int], d: int) -> None:\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(arr, 0, d - 1)\n        rev_array(arr, d, len(arr) - 1)\n        rev_array(arr, 0, len(arr) - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n0 <= k <= 10^5",
        "topic": "ArraysandHashing",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rotate Right K Places",
        "problem_link": "https://leetcode.com/problems/rotate-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/9_Rotate_Right_K_Places.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*k)",
                "sc": "S.C  - O(1)",
                "intuition": "keep right rotating by one place for d times",
                "code": "from typing import List\n\n\nclass Solution:\n    def right_rotate(self, arr: List[int]):\n        for i in range(len(arr) - 1, 0, -1):\n            arr[i], arr[i - 1] = arr[i - 1], arr[i]\n\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        while k:\n            self.right_rotate(nums)\n            k -= 1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(k)+O(N-k)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "reverse the whole array\nreverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nperform k normalization",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        k = k % len(nums)\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(nums, 0, len(nums) - 1)\n        rev_array(nums, 0, k - 1)\n        rev_array(nums, k, len(nums) - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n\n\nConstraints:\n\n1 <= nums.length <= 10^4\n-^231 <= nums[i] <= 2^31 - 1",
        "topic": "ArraysandHashing",
        "pattern": "Element-Swap",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Move Zeroes at the End",
        "problem_link": "https://leetcode.com/problems/move-zeroes",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/10_Move_Zeroes_at_the_End.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "make a copy of the array and push non negative values at first",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        cp_nums = [0] * len(nums)\n\n        idx = 0\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                cp_nums[idx] = nums[i]\n                idx += 1\n\n        nums[:] = cp_nums[:]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "maintain a idx variable which will tell us the postion to insert the\nnon zero values,if we encounter a non zero value we swap it with the value\nat that index and we increment one to the index",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        idx = 0\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[idx], nums[i] = nums[i], nums[idx]\n                idx += 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 11,
        "question": "Given an array, arr[] sorted in ascending order and an integer k. Return true if k is present in the array, otherwise, false.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4, 6], k = 6\nOutput: true\nExplanation: Since, 6 is present in the array at index 4 (0-based indexing), output is true.\n\nInput: arr[] = [1, 2, 4, 5, 6], k = 3\nOutput: false\nExplanation: Since, 3 is not present in the array, output is false.\n\nInput: arr[] = [2, 3, 5, 6], k = 1\nOutput: false\nConstraints:\n1 <= arr.size() <= 10^6\n1 <= k <= 10^6\n1 <= arr[i] <= 10^6",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Linear Search",
        "problem_link": "https://practice.geeksforgeeks.org/problems/who-will-win-1587115621/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/11_Linear_Search.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Traverse the array until you encounter the element you are searching",
                "code": "class Solution:\n    def searchInSorted(self, arr: list[int], k: int):\n        for i in range(len(arr)):\n            if arr[i] == k:\n                return True\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 12,
        "question": "Given two sorted arrays a[] and b[], where each array may contain duplicate elements , the task is to return the elements in the union of the two arrays in sorted order.\n\nUnion of two arrays can be defined as the set containing distinct common elements that are present in either of the arrays.\nExamples:\n\nInput: a[] = [1, 2, 3, 4, 5], b[] = [1, 2, 3, 6, 7]\nOutput: 1 2 3 4 5 6 7\nExplanation: Distinct elements including both the arrays are: 1 2 3 4 5 6 7.\n\nInput: a[] = [2, 2, 3, 4, 5], b[] = [1, 1, 2, 3, 4]\nOutput: 1 2 3 4 5\nExplanation: Distinct elements including both the arrays are: 1 2 3 4 5.\n\nInput: a[] = [1, 1, 1, 1, 1], b[] = [2, 2, 2, 2, 2]\nOutput: 1 2\nExplanation: Distinct elements including both the arrays are: 1 2.\n\nConstraints:\n1  <=  a.size(), b.size()  <=  10^5\n-10^9  <=  a[i] , b[i]  <=  10^9",
        "topic": "ArraysandHashing",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Union of two sorted arrays with duplicates",
        "problem_link": "https://www.geeksforgeeks.org/problems/union-of-two-sorted-arrays-1587115621/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/12_Union_of_two_sorted_arrays_with_duplicates.py",
        "approaches": [
            {
                "tc": "T.C. - O(m+n)+O((m+n)log(m+n))+O(m+n)+O(k) ~ O((m+n)log(m+n))",
                "sc": "S.C  - O(m+n)+O(m+n)",
                "intuition": "merge two arrays into a list in sorted form convert the merged list to set convert the set to list and return a ssorted list",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        return sorted(list(set(sorted([*a, *b]))))",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(m+n)",
                "sc": "S.C  - O(1)",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nand follow the merge sort algorithm",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        union: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(a) and j < len(b):\n            if a[i] <= b[j]:\n                if last_inserted != a[i]:\n                    union.append(a[i])\n                    last_inserted = a[i]\n                i += 1\n            else:\n                if last_inserted != b[j]:\n                    union.append(b[j])\n                    last_inserted = b[j]\n                j += 1\n\n        while i < len(a):\n            if last_inserted != a[i]:\n                union.append(a[i])\n                last_inserted = a[i]\n            i += 1\n\n        while j < len(b):\n            if last_inserted != b[j]:\n                union.append(b[j])\n                last_inserted = b[j]\n            j += 1\n\n        return union",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 13,
        "question": "Given two sorted arrays arr1[] and arr2[]. Your task is to return the intersection of both arrays.\n\nIntersection of two arrays is said to be elements that are common in both arrays. The intersection should not count duplicate elements.\n\nNote: If there is no intersection then return an empty array.\n\nExamples:\n\nInput: arr1[] = [1, 2, 3, 4], arr2[] = [2, 4, 6, 7, 8]\nOutput: [2, 4]\nExplanation: 2 and 4 are only common elements in both the arrays.\n\nInput: arr1[] = [1, 2, 2, 3, 4], arr2[] = [2, 2, 4, 6, 7, 8]\nOutput: [2, 4]\nExplanation: 2 and 4 are the only common elements.\n\nInput: arr1[] = [1, 2], arr2[] = [3, 4]\nOutput: []\nExplanation: No common elements.\n\nExpected Time Complexity: O(n + m)\nExpected Auxiliary Space: O(min(n,m))\n\nConstraints:\n1 <= arr1.size(),arr2.size() <= 10^5\n1 <= arr1[i], arr2[i] <= 10^6",
        "topic": "ArraysandHashing",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Intersection of two sorted arrays",
        "problem_link": "https://www.geeksforgeeks.org/problems/intersection-of-two-sorted-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/13_Intersection_of_two_sorted_arrays.py",
        "approaches": [
            {
                "tc": "T.C. - O(m)+O(n)+O((m+n)log(m+n))+O(m+n) ~ O((m+n)log(m+n))",
                "sc": "S.C  - O(m+n)",
                "intuition": "convert the two arrays into set find the intersection between them return the intersection converted into list in a sorted manner",
                "code": "class Solution:\n    # Function to return a list containing the intersection of two arrays.\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        st1 = set(arr1)\n        st2 = set(arr2)\n\n        return sorted(list(st1.intersection(st2)))",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(m+n)",
                "sc": "S.C  - O(1)",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nJust follow merge sort algorithm and when equal elements\nare encounter insert only based on the above condition",
                "code": "class Solution:\n\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        intersection: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                i += 1\n            elif arr1[i] > arr2[j]:\n                if last_inserted != arr2[j]:\n                    last_inserted = arr2[j]\n                j += 1\n            else:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                    intersection.append(arr1[i])\n                i += 1\n                j += 1\n\n        return intersection",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 14,
        "question": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\nConstraints:\n\n2 <= nums.length <= 10^4\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9\nOnly one valid answer exists.",
        "topic": "ArraysandHashing",
        "pattern": "2Sum",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "2 Sum I",
        "problem_link": "https://leetcode.com/problems/two-sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/14_2_Sum_I.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all the pairs and check whether pair exists or not",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "keep marking the element as you visit them\njust check target-current_element present in seen_map or not\nX+Y=target, if target-Y is present then we can definitely say\nwe have a pair",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen_map = {}\n\n        for idx, num in enumerate(nums):\n            diff = target - num\n            if diff in seen_map:\n                return [seen_map[diff], idx]\n            seen_map[num] = idx",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 15,
        "question": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find\ntwo numbers such that they add up to a specific target number. Let these two numbers\nbe numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\n\nExample 1:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\nExample 2:\n\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\nExample 3:\n\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n\n\nConstraints:\n\n2 <= numbers.length <= 3 * 104\n-1000 <= numbers[i] <= 1000\nnumbers is sorted in non-decreasing order.\n-1000 <= target <= 1000\nThe tests are generated such that there is exactly one solution.",
        "topic": "ArraysandHashing",
        "pattern": "2Sum",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "2 Sum II",
        "problem_link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/15_2_Sum_II.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "generate all pairs and see whethet target sum exists",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use two pointers i and j\ni is at 0th and j is at last index\nif the sum becomes greater decrease range\nif the sum is lesser increase range",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        i, j = 0, len(numbers) - 1\n\n        while i < j:\n            if numbers[i] + numbers[j] > target:\n                j -= 1\n            elif numbers[i] + numbers[j] < target:\n                i += 1\n            else:\n                return [i + 1, j + 1]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 16,
        "question": "Given an integer array nums, return all the\ntriplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\nConstraints:\n\n3 <= nums.length <= 3000\n-10^5 <= nums[i] <= 10^5",
        "topic": "ArraysandHashing",
        "pattern": "2Sum",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "3 Sum",
        "problem_link": "https://leetcode.com/problems/3sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/16_3_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^3)+O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Sort the array to generate distinct pairs generate all possible triplet combination and see whether they add to 0",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ans = set()\n        nums.sort()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        ans.add((nums[i], nums[j], nums[k]))\n\n        return list(ans)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N^2)+O(Nlog(N))",
                "sc": "S.C  - O(N)",
                "intuition": "Fix one element at index i and perform 2 sum hashmap technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            h = {}\n            for j in range(i + 1, len(nums)):\n                diff = 0 - nums[i] - nums[j]\n                if diff in h:\n                    ans.add((nums[i], nums[j], nums[h[diff]]))\n                h[nums[j]] = j\n\n        return list(ans)",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N^2)+O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Fix one element at index i and perform 2 sum sorted array technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            j, k = i + 1, len(nums) - 1\n\n            if (\n                i != 0 and nums[i] == nums[i - 1]\n            ):  # we dont want to generate same triplets\n                continue\n\n            while j < k:\n                if nums[i] + nums[j] + nums[k] > 0:\n                    k -= 1\n                elif nums[i] + nums[j] + nums[k] < 0:\n                    j += 1\n                elif nums[i] + nums[j] + nums[k] == 0:\n                    ans.add((nums[i], nums[j], nums[k]))\n                    j += 1\n                    k -= 1\n\n                    # we dont want to generate same triplets\n                    while nums[j] == nums[j - 1] and j < k:\n                        j += 1\n                    while nums[k] == nums[k + 1] and j < k:\n                        k -= 1\n\n        return list(ans)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 17,
        "question": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n\n\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\nConstraints:\n\n1 <= nums.length <= 200\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9",
        "topic": "ArraysandHashing",
        "pattern": "2Sum",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "4 Sum",
        "problem_link": "https://leetcode.com/problems/4sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/17_4_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^4)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all possible pairs and check if target sum exists",
                "code": "from contextlib import contextmanager\nfrom typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    for l in range(k + 1, len(nums)):\n                        sm = nums[i] + nums[j] + nums[k] + nums[l]\n\n                        if sm == target:\n                            ans.add((nums[i], nums[j], nums[k], nums[l]))\n\n        return list(ans)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N^3)",
                "sc": "S.C  - O(N)",
                "intuition": "Fix one element at index i and other at j and perform 2 sum hashmap technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                h = {}\n                for k in range(j + 1, len(nums)):\n                    diff = target - nums[i] - nums[j] - nums[k]\n                    if diff in h:\n                        ans.add((nums[i], nums[j], nums[k], nums[h[diff]]))\n                    h[nums[k]] = k\n\n        return list(ans)",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N^3)",
                "sc": "S.C  - O(1)",
                "intuition": "Fix one element at index i and other at j and perform 2 sum sorted array technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            if i != 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums)):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n\n                k, l = j + 1, len(nums) - 1\n                while k < l:\n                    sm = nums[i] + nums[j] + nums[k] + nums[l]\n                    if sm > target:\n                        l -= 1\n                    elif sm < target:\n                        k += 1\n                    elif sm == target:\n                        ans.add((nums[i], nums[j], nums[k], nums[l]))\n                        k += 1\n                        l -= 1\n\n                        while nums[k] == nums[k - 1] and k < l:\n                            k += 1\n\n                        while nums[l] == nums[l + 1] and k < l:\n                            l -= 1\n\n        return list(ans)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 18,
        "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n\nExample 1:\n\nInput: nums = [3,0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n\nExample 2:\n\nInput: nums = [0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n\nExample 3:\n\nInput: nums = [9,6,4,2,3,5,7,0,1]\n\nOutput: 8\n\nExplanation:\n\nn = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^4\n0 <= nums[i] <= n\nAll the numbers of nums are unique.",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Missing Number",
        "problem_link": "https://leetcode.com/problems/missing-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/18_Missing_Number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Since numbers are in range of 1 to n first find sum of natural numbers from 1 to n and substract the current sum of the array , we will get the missing number",
                "code": "from typing import List\n\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        actualSum = n * (n + 1) // 2\n        currSum = sum(nums)\n        return actualSum - currSum",
                "type": "Optimal"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "use cyclic sort",
                "code": "from typing import List\n\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        i = 0\n\n        while i < len(nums):\n            actualPos = nums[i]\n            if nums[i] < len(nums) and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n\n        return len(nums)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 19,
        "question": "Given an array nums of n integers where nums[i] is in the range [1, n], return an\narray of all the integers in the range [1, n] that do not appear in nums.\n\n\nExample 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\n\nInput: nums = [1,1]\nOutput: [2]\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^5\n1 <= nums[i] <= n\n\n\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find All Numbers Disappeared in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/19_Find_All_Numbers_Disappeared_in_an_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(3N) ~ O(N)",
                "sc": "S.C  - O(2N)",
                "intuition": "create a map containing items that should be present create a map containing current items in array iterate through the should_contain_map and check which elements are not in curr_contain_map",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n        curr_contain_map = {i: True for i in nums}\n\n        ans = []\n        for k, v in should_contain_map.items():\n            if k not in curr_contain_map:\n                ans.append(k)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Do cyclic sort\nafter cyclic sort does the element expected for that index match",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, arr: List[int]) -> None:\n        idx = 0\n\n        while idx < len(arr):\n            actualPos = arr[idx] - 1\n\n            if arr[actualPos] != arr[idx]:\n                arr[actualPos], arr[idx] = arr[idx], arr[actualPos]\n            else:\n                idx += 1\n\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        ans = []\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(i + 1)\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 20,
        "question": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and using only constant extra space.\n\n\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\nExample 3:\n\nInput: nums = [3,3,3,3,3]\nOutput: 3\n\n\nConstraints:\n\n1 <= n <= 10^5\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n\n\nFollow up:\n\nHow can we prove that at least one duplicate number must exist in nums?\nCan you solve the problem in linear runtime complexity?",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find the Duplicate Number",
        "problem_link": "https://leetcode.com/problems/find-the-duplicate-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/20_Find_the_Duplicate_Number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Use a hasmap to keep track of seen elements if we see a elements more than twice return that element",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        seen = {}\n\n        for i in nums:\n            if i in seen:\n                return i\n            seen[i] = True\n\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use the cylic sort algoritm\nsort the array using cyclic sort\nthe first number not at its correct place is the duplicate",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicate(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return nums[i]\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 21,
        "question": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer\nappears at most twice, return an array of all the integers that appears twice.\n\nYou must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output\n\n\nExample 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExample 2:\n\nInput: nums = [1,1,2]\nOutput: [1]\nExample 3:\n\nInput: nums = [1]\nOutput: []\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^5\n1 <= nums[i] <= n\nEach element in nums appears once or twice.",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find All Duplicates in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-duplicates-in-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/21_Find_All_Duplicates_in_an_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "use map to keep track of frequency number occuring more than 2 are duplicates",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        freq_mp = {}\n\n        for num in nums:\n            freq_mp[num] = 1 + freq_mp.get(num, 0)\n\n        ans = []\n        for num in freq_mp:\n            if freq_mp[num] >= 2:\n                ans.append(num)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "do cyclic sort\nnumbers not at its correct place are the duplicates",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n        ans = []\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(nums[i])\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 22,
        "question": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error,\none of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n\nYou are given an integer array nums representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return them in the form of an array.\n\n\nExample 1:\n\nInput: nums = [1,2,2,4]\nOutput: [2,3]\nExample 2:\n\nInput: nums = [1,1]\nOutput: [1,2]\n\n\nConstraints:\n\n2 <= nums.length <= 10^4\n1 <= nums[i] <= 10^4",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Set Mismatch",
        "problem_link": "https://leetcode.com/problems/set-mismatch",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/22_Set_Mismatch.py",
        "approaches": [
            {
                "tc": "T.C. - O(4N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "For missing number keep track of what should be present and compare it with current present map For duplicate find the number with frequency more than 2",
                "code": "class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        ans = []\n\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n\n        current_contain_map = {}\n        for num in nums:\n            current_contain_map[num] = 1 + current_contain_map.get(num, 0)\n\n        for num in current_contain_map:\n            if current_contain_map[num] > 1:\n                ans.append(num)\n\n        for num in should_contain_map:\n            if num not in current_contain_map:\n                ans.append(num)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "do cyclic sort\nnumbers not at correct place is the duplicate and index is the missing",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return [nums[i], i + 1]\n\n        return []",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 23,
        "question": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\n\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1",
        "topic": "ArraysandHashing",
        "pattern": "CyclicSort",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "First Missing Positive",
        "problem_link": "https://leetcode.com/problems/first-missing-positive",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/23_First_Missing_Positive.py",
        "approaches": [
            {
                "tc": "T.C. - O(max*N)",
                "sc": "S.C  - O(1)",
                "intuition": "we know that all the positive numbers will lie from 1 to max_number+2 max_number is taken because suppose we have [1,2] then the first missing positive will be 3 just check sequentially from starting whether any number in this is range is absent then that will be our missing first positive termination condition is 1 becuase what if we have ony negatives [-1,-2]",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        for i in range(1, max(nums) + 2):\n            found = False\n            for j in range(len(nums)):\n                if nums[j] <= 0:\n                    continue\n                if i == nums[j]:\n                    found = True\n                    break\n            if not found:\n                return i\n\n        return 1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(max_number)",
                "sc": "S.C  - O(max_number)",
                "intuition": "Keep track of what element should be present increment the number in the map wrt to elements present in original map see which numbers count is still zero",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        should_contain_map = {}\n        for i in range(1, max(nums) + 2):\n            should_contain_map[i] = 0\n\n        for num in nums:\n            if num in should_contain_map:\n                should_contain_map[num] += 1\n\n        for num in should_contain_map:\n            if should_contain_map[num] == 0:\n                return num\n\n        return 1",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Do cyclic cyclic_sort\nignore number greater than size of array and negative numbers since zero based indexing\nthe first number at wro",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[i] < len(nums) and nums[i] > 0 and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 24,
        "question": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn the single element that appears only once.\n\nYour solution must run in O(log n) time and O(1) space.\n\n\nExample 1:\n\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\n\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^5",
        "topic": "ArraysandHashing",
        "pattern": "XOR",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find Element Appeating more than once",
        "problem_link": "https://leetcode.com/problems/single-element-in-a-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/24_Find_Element_Appeating_more_than_once.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "just check one by one the count of each element in the array if count is equal to return nums",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            cnt = 0\n            for j in range(len(nums)):\n                if nums[i] == nums[j]:\n                    cnt += 1\n                if cnt >= 2:\n                    break\n            if cnt == 1:\n                return nums[i]\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "maintain a frequency map return element with frequency 1",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        freq_map = {}\n\n        for num in nums:\n            freq_map[num] = 1 + freq_map.get(num, 0)\n\n        for num in freq_map:\n            if freq_map[num] == 1:\n                return num\n\n        return -1",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we know xor of any 2 same number is 0\nand xor of 0 with any number (x) is x\nso same number get cancelled out leaving\nthe element appeating once",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        xor = 0\n\n        for num in nums:\n            xor ^= num\n\n        return xor",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 25,
        "question": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\n\n\nExample 1:\n\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\nnums[i] is either 0 or 1.",
        "topic": "ArraysandHashing",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Max Consecutive Ones",
        "problem_link": "https://leetcode.com/problems/max-consecutive-ones",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/25_Max_Consecutive_Ones.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep track of number of 1s encountered till now\nif current num is 1 increment 1s encountered\nat every step you encounter 1 find max of count and max_ones\nif current num is 0 reset counter",
                "code": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        max_ones = 0\n        c = 0\n\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                c += 1\n                max_ones = max(max_ones, c)\n            else:\n                c = 0\n\n        return max_ones",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 26,
        "question": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\n\nExample 1:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "topic": "ArraysandHashing",
        "pattern": "Algo",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Sort an array of 0's 1's & 2's",
        "problem_link": "https://leetcode.com/problems/sort-colors",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/26_Sort_an_array_of_0's_1's_&_2's.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "sort using inbilt function",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(3*N) ~ O(N)",
                "sc": "S.C  - O(3)",
                "intuition": "Count occurences of 0s,1s,2s and store them in a map Then fill the array with the number of times each element occurs",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        count_map = {0: 0, 1: 0, 2: 0}\n\n        for num in nums:\n            count_map[num] += 1\n\n        idx = 0\n        for num, count in count_map.items():\n            for i in range(count):\n                nums[idx] = num\n                idx += 1",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use dutch national flag algorithm\ngoal of this algo is to push all the low values to left\nand high values to right\nat first our entire array is unsorted\nso we can put the mid at 0 and high at len(array)-1\nand start in the 0 th postiion\n\n00000000000000     111111111111     ?????????         2222222222\n^            ^     ^          ^     ^       ^         ^        ^\n0         low-1   low     mid-1    mid      high     high+1   n-1\n\n? is ith unsorted portion",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low, mid = 0, 0\n        high = len(nums) - 1\n\n        for _ in range(len(nums)):\n            # if unsorted portion has zero\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n\n            # if unsorted portion has one\n            elif nums[mid] == 1:\n                mid += 1\n\n            # if unsorted portion has two\n            elif nums[mid] == 2:\n                nums[high], nums[mid] = nums[mid], nums[high]\n                high -= 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 27,
        "question": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\n\nYou should return the array of nums such that the the array follows the given conditions:\n\nEvery consecutive pair of integers have opposite signs.\nFor all integers with the same sign, the order in which they were present in nums is preserved.\nThe rearranged array begins with a positive integer.\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.\n\n\nExample 1:\n\nInput: nums = [3,1,-2,-5,2,-4]\nOutput: [3,-2,1,-5,2,-4]\nExplanation:\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.\nExample 2:\n\nInput: nums = [-1,1]\nOutput: [1,-1]\nExplanation:\n1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1].\n\n\nConstraints:\n\n2 <= nums.length <= 2 * 10^5\nnums.length is even\n1 <= |nums[i]| <= 10^5\nnums consists of equal number of positive and negative integers.",
        "topic": "ArraysandHashing",
        "pattern": "SignArrange",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rearrange Array Elements by Sign",
        "problem_link": "https://leetcode.com/problems/rearrange-array-elements-by-sign",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/27_Rearrange_Array_Elements_by_Sign.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N) ~ O(N)",
                "sc": "S.C  - O(N/2)+O(N/2)+O(N) ~ O(2N)",
                "intuition": "Store all the positive,negative numbers in 2 seperate list since array consists of equal number of positive and negative integers so we are sure that at even index we will have positive number and at odd index we will have negative numbers",
                "code": "from typing import List\n\n\nclass Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        pos, neg = [], []\n\n        for num in nums:\n            if num < 0:\n                neg.append(num)\n            if num >= 0:\n                pos.append(num)\n\n        ans = []\n        posIdx, negIdx = 0, 0\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                ans.append(pos[posIdx])\n                posIdx += 1\n            else:\n                ans.append(neg[negIdx])\n                negIdx += 1\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "since array consists of equal number of positive and negative integers\nso we are sure that at even index we will have positive number and\nat odd index we will have negative numbers\nkeep track of next positive index and next negative index",
                "code": "from typing import List\n\n\nclass Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        ans = [0 for _ in range(len(nums))]\n\n        posIdx = 0\n        negIdx = 1\n\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                ans[posIdx] = nums[i]\n                posIdx += 2\n            else:\n                ans[negIdx] = nums[i]\n                negIdx += 2\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 28,
        "question": "Given an unsorted array arr containing both positive and negative numbers. Your task is to rearrange the array and convert it\ninto an array of alternate positive and negative numbers without changing the relative order.\n\nNote:\n- Resulting array should start with a positive integer (0 will also be considered as a positive integer).\n- If any of the positive or negative integers are exhausted, then add the remaining integers in the answer\nas it is by maintaining the relative order.\n- The array may or may not have the equal number of positive and negative integers.\n\nExamples:\n\nInput: arr[] = [9, 4, -2, -1, 5, 0, -5, -3, 2]\nOutput: [9, -2, 4, -1, 5, -5, 0, -3, 2]\nExplanation: The positive numbers are [9, 4, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 4 and then -1 and so on.\n\nInput: arr[] = [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8]\nOutput: [5, -5, 2, -2, 4, -8, 7, 1, 8, 0]\nExplanation : The positive numbers are [5, 2, 4, 7, 1, 8, 0] and the negative integers are [-5,-2,-8]. According to the given conditions we will start from the positive integer 5 and then -5 and so on. After reaching -8 there are no negative elements left, so according to the given rule, we will add the remaining elements (in this case positive elements are remaining) as it in by maintaining the relative order.\n\nInput: arr[] = [9, 5, -2, -1, 5, 0, -5, -3, 2]\nOutput: [9, -2, 5, -1, 5, -5, 0, -3, 2]\nExplanation: The positive numbers are [9, 5, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 5 and then -1 and so on.\n\nConstraints:\n1 \u2264 arr.size() \u2264 106\n-106 \u2264 arr[i] \u2264 106",
        "topic": "ArraysandHashing",
        "pattern": "SignArrange",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Alternate Positive Negative",
        "problem_link": "https://www.geeksforgeeks.org/problems/array-of-alternate-ve-and-ve-nos1401/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/28_Alternate_Positive_Negative.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N) ~ O(N)",
                "sc": "S.C  - O(N)+O(N/2)+O(N/2)",
                "intuition": "Separate Positive and Negative numbers Merge the Two Vectors Alternately After append the remaining elements to the ans",
                "code": "class Solution:\n    def rearrange(self, arr: list[int]):\n        ans: list[int] = [0 for _ in range(len(arr))]\n\n        pos, neg = [], []\n\n        for num in arr:\n            if num >= 0:\n                pos.append(num)\n            else:\n                neg.append(num)\n\n        idx = 0\n        if len(pos) <= len(neg):\n            for i in range(len(pos)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(pos), len(neg)):\n                ans[idx] = neg[j]\n                idx += 1\n        else:\n            for i in range(len(neg)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(neg), len(pos)):\n                ans[idx] = pos[j]\n                idx += 1\n\n        arr[::] = ans[::]",
                "type": "Brute"
            },
            {
                "tc": "T.C. -",
                "sc": "S.C  -",
                "intuition": "",
                "code": "",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 29,
        "question": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^4",
        "topic": "ArraysandHashing",
        "pattern": "MaintainMinMaxSoFar",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Best Time to Buy and Sell Stock",
        "problem_link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/29_Best_Time_to_Buy_and_Sell_Stock.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Suppose you are at index i just ask yourself\ncan i sell this stock on this day if i have\nthe minimum stock cost from left side of the index\nbuy in less price and sell in high price",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_cp_till_now = prices[0]\n        max_profit = -sys.maxsize\n\n        for i in range(len(prices)):\n            max_profit = max(max_profit, prices[i] - min_cp_till_now)\n            min_cp_till_now = min(min_cp_till_now, prices[i])\n\n        return max_profit",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 30,
        "question": "You are given an array arr of positive integers. Your task is to find all the leaders\nin the array. An element is considered a leader if it is greater than or equal\nto all elements to its right. The rightmost element is always a leader.\n\nExamples:\n\nInput: arr = [16, 17, 4, 3, 5, 2]\nOutput: [17, 5, 2]\nExplanation: Note that there is nothing greater on the right side of 17, 5 and, 2.\n\nInput: arr = [10, 4, 2, 4, 1]\nOutput: [10, 4, 4, 1]\nExplanation: Note that both of the 4s are in output, as to be a leader an equal element is also allowed on the right. side\n\nInput: arr = [5, 10, 20, 40]\nOutput: [40]\nExplanation: When an array is sorted in increasing order, only the rightmost element is leader.\n\nInput: arr = [30, 10, 10, 5]\nOutput: [30, 10, 10, 5]\nExplanation: When an array is sorted in non-increasing order, all elements are leaders.\n\nConstraints:\n1 <= arr.size() <= 106\n0 <= arr[i] <= 106",
        "topic": "ArraysandHashing",
        "pattern": "MaintainMinMaxSoFar",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Leaders in an array",
        "problem_link": "https://www.geeksforgeeks.org/problems/leaders-in-an-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/30_Leaders_in_an_array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "traverse the array from right\nkeep track of the maximum height from the right till now\ncompare the value at current index with the max_from_right so far\nif it is greater then we can say its a leader",
                "code": "class Solution:\n    def leaders(self, arr: list[int]) -> list[int]:\n        max_from_right = arr[-1]\n\n        n = len(arr)\n        ans = [arr[-1]]\n\n        for i in range(n - 2, -1, -1):\n            if arr[i] >= max_from_right:\n                ans.append(arr[i])\n                max_from_right = arr[i]\n\n        return ans[::-1]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 31,
        "question": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the\ninput 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "topic": "ArraysandHashing",
        "pattern": "Matrix",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rotate Image",
        "problem_link": "https://leetcode.com/problems/rotate-image",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/31_Rotate Image.py",
        "approaches": [
            {
                "tc": "T.C. - O(2*N*M) ~ O(N*M)",
                "sc": "S.C  - O(1)",
                "intuition": "Do transpose of a matrix\nReverse every row",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # Transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(\n                i + 1, len(matrix[0])\n            ):  # swap values above diagonal to avoid overwriting\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # Reverse each row\n        for i in range(len(matrix)):\n            j = 0\n            while j < len(matrix[0]) // 2:\n                n = len(matrix[0])\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\n                j += 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 32,
        "question": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
        "topic": "ArraysandHashing",
        "pattern": "Matrix",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Spiral Matrix",
        "problem_link": "https://leetcode.com/problems/spiral-matrix",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/32_Spiral_Matrix.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*M)",
                "sc": "S.C  - O(N*M)",
                "intuition": "keep 4 pointes top,left,right,bottom\njust do what they have said till left<=right and top<=bottom",
                "code": "from typing import List\n\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        top = 0\n        left = 0\n        right = len(matrix[0]) - 1\n        bottom = len(matrix) - 1\n\n        ans = []\n\n        while left <= right and top <= bottom:\n            # Left to Right\n            for i in range(left, right + 1):\n                ans.append(matrix[top][i])\n            top += 1\n\n            # Top to Bottom\n            for i in range(top, bottom + 1):\n                ans.append(matrix[i][right])\n            right -= 1\n\n            # Right to Left\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    ans.append(matrix[bottom][i])\n                bottom -= 1\n\n            # Bottom to Top\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    ans.append(matrix[i][left])\n                left += 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 33,
        "question": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the\nmajority element always exists in the array.\n\n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9",
        "topic": "ArraysandHashing",
        "pattern": "Algo",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Majority Element I",
        "problem_link": "https://leetcode.com/problems/majority-element",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/34_Majority_Element_I.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep track of the element appearing more than n//2 times using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        majority_element = -1\n        appear_count = len(nums) // 2\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_element = nums[i]\n\n        return majority_element",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//2 times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        appear_count = len(nums) // 2\n        freq_mp = {}\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                return num\n\n        return -1",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times\n+ assume first element as majority element\n+ if you see majority element again increment count\n+ if you see new element decrement count\n+ if count is zero new majority element has come",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        maj = nums[0]\n        c = 1\n\n        for i in range(1, len(nums)):\n            # increment count if its the same majority element\n            if nums[i] == maj:\n                c += 1\n\n            elif c == 0:  # reset majority element\n                c = 1\n                maj = nums[i]\n\n            # decrement count if its not the current majority element\n            elif nums[i] != maj:\n                c -= 1\n\n        return maj",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 34,
        "question": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times.\n\n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: [3]\nExample 2:\n\nInput: nums = [1]\nOutput: [1]\nExample 3:\n\nInput: nums = [1,2]\nOutput: [1,2]\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9",
        "topic": "ArraysandHashing",
        "pattern": "Algo",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Majority Element II",
        "problem_link": "https://leetcode.com/problems/majority-element-ii",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/35_Majority_Element_II.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep track of the element appearing more than n//3 times using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        majority_elements: set[int] = set()\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_elements.add(nums[i])\n\n        return list(majority_elements)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//3 times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        freq_mp = {}\n        majority_elements: set[int] = set()\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                majority_elements.add(num)\n\n        return list(majority_elements)",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        maj1 = nums[0]\n        c1 = 0\n\n        maj2 = nums[0]\n        c2 = 0\n\n        for i in range(len(nums)):\n            # increment count1 if its the same majority element1\n            if nums[i] == maj1:\n                c1 += 1\n\n            # increment count2 if its the same majority element2\n            elif nums[i] == maj2:\n                c2 += 1\n\n            elif c1 == 0:  # reset majority element1\n                c1 = 1\n                maj1 = nums[i]\n\n            elif c2 == 0:  # reset majority element2\n                c2 = 1\n                maj2 = nums[i]\n\n            else:\n                c1 -= 1\n                c2 -= 1\n\n        c1 = 0\n        c2 = 0\n        for i in range(len(nums)):\n            if nums[i] == maj1:\n                c1 += 1\n            elif nums[i] == maj2:\n                c2 += 1\n\n        ans = []\n\n        if c1 > appear_count:\n            ans.append(maj1)\n\n        if c2 > appear_count:\n            ans.append(maj2)\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 35,
        "question": "Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n\n\nConstraints:\n\n1 <= numRows <= 30",
        "topic": "ArraysandHashing",
        "pattern": "AlgoA",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Pascals's Triangle",
        "problem_link": "https://leetcode.com/problems/pascals-triangle",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/36_Pascals's_Triangle.py",
        "approaches": [
            {
                "tc": "T.C. - O(numRows*last_row)",
                "sc": "S.C  - O(N)",
                "intuition": "when starting pad your last seen row with single 0 For example if a last row is [0,1,2,1,0] The next row will be the summation of pairs i,i+1 [(0+1),(1+2),(2+1),(1+0)] = [1,3,3,1]",
                "code": "from typing import List\n\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = [[1]]\n        last_row = [0, 1, 0]\n\n        for i in range(numRows - 1):\n            tmp = []\n            for j in range(len(last_row) - 1):\n                tmp.append(last_row[j] + last_row[j + 1])\n            ans.append(tmp)\n            last_row = [0, *tmp, 0]\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Must Know (1) : Given row and col , find element at row and col , You can find with\nthis formula -> row-1 C col-1\n\nObservation suppose i have 7C2 ->  (7*6)*(5*4*3*2*1)\n-----------------\n(2*1)*(5*4*3*2*1)\nyou will see only first 2 in the numerator and denominator is left others get cancel\ntry it for others you will see only the \"col\"(r) part remains\n------------------------------------------------------------------------------------\n\nMust Know (2) : Given n print the nth pascals-triangle row, you can use the above\nformula and try to find it in O(N*r) complexity ,but we can improve it a further\nIn pascals-triangle the nth row will have n elements\nGiven 6th row of pascals-triangle\n\nCol Idx           0   1        2            3               4                   5\n\nObservation :     1   5       10           10               5                   1\n\nMultiplication:   1   5/1    (5*4)/(1*2)  (5*4*3)/(1*2*3) (5*4*3*4)/(1*2*3*4)  (5*4*3*4*5)/(1*2*3*4*5)\n\n\nFormula for finding the ith element in a row  is : (row-col)/col , you just have to maintain previouse cols value\n------------------------------------------------------------------------------------------------------------------",
                "code": "from typing import List\n\n\nclass Solution:\n    def getNRow(self, n: int) -> list[int]:\n        ans = 1\n        tmp = [1]\n        for i in range(1, n):\n            ans *= n - i\n            ans //= i\n            tmp.append(ans)\n        return tmp\n\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = []\n        for i in range(1, numRows + 1):\n            ans.append(self.getNRow(i))\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 36,
        "question": "Given an array arr containing both positive and negative integers, the task is to compute the length of the largest subarray that has a sum of 0.\n\nExamples:\n\nInput: arr[] = [15, -2, 2, -8, 1, 7, 10, 23]\nOutput: 5\nExplanation: The largest subarray with a sum of 0 is [-2, 2, -8, 1, 7].\n\nInput: arr[] = [2, 10, 4]\nOutput: 0\nExplanation: There is no subarray with a sum of 0.\n\nInput: arr[] = [1, 0, -4, 3, 1, 0]\nOutput: 5\nExplanation: The subarray is [0, -4, 3, 1, 0].\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^6\n\u221210^3 \u2264 arr[i] \u2264 10^3, for each valid i",
        "topic": "ArraysandHashing",
        "pattern": "LongestSubarraySum",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray 0 Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/largest-subarray-with-0-sum/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/38_Longest_Subarray_0_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays find the longest subarray with 0 sum from them",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        sm = 0\n        k = 0\n\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 37,
        "question": "Given an array arr[] containing integers and an integer k, your task is to find the\nlength of the longest subarray where the sum of its elements is equal to the given value k. If there is no subarray with sum equal to k, return 0.\n\nExamples:\n\nInput: arr[] = [10, 5, 2, 7, 1, -10], k = 15\nOutput: 6\nExplanation: Subarrays with sum = 15 are [5, 2, 7, 1], [10, 5] and [10, 5, 2, 7, 1, -10]. The length of the longest subarray with a sum of 15 is 6.\n\nInput: arr[] = [-5, 8, -14, 2, 4, 12], k = -5\nOutput: 5\nExplanation: Only subarray with sum = -5 is [-5, 8, -14, 2, 4] of length 5.\n\nInput: arr[] = [10, -10, 20, 30], k = 5\nOutput: 0\nExplanation: No subarray with sum = 5 is present in arr[].\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^5\n-10^4 \u2264 arr[i] \u2264 10^4\n-10^9 \u2264 k \u2264 10^9",
        "topic": "ArraysandHashing",
        "pattern": "LongestSubarraySum",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray K Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/39_Longest_Subarray_K_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays find the longest subarray with k sum from them",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        # code here\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == k:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        sm = 0\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 38,
        "question": "Given an array arr[] and a positive integer k, find the length of the longest subarray with the sum of the elements divisible by k.\nNote: If there is no subarray with sum divisible by k, then return 0.\n\nExamples :\n\nInput: arr[] = [2, 7, 6, 1, 4, 5], k = 3\nOutput: 4\nExplanation: The subarray [7, 6, 1, 4] has sum = 18, which is divisible by 3.\n\nInput: arr[] = [-2, 2, -5, 12, -11, -1, 7], k = 3\nOutput: 5\nExplanation: The subarray [2, -5, 12, -11, -1] has sum = -3, which is divisible by 3.\n\nInput: arr[] = [1, 2, -2], k = 2\nOutput: 2\nExplanation: The subarray is [2, -2] has sum = 0, which is divisible by 2.\n\nConstraints:\n1 <= arr.size() <= 10^6\n1 <= k <= 10^6\n-10^6 <= arr[i] <= 10^6",
        "topic": "ArraysandHashing",
        "pattern": "LongestSubarraySum",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray Sum Divisible by K",
        "problem_link": "https://leetcode.com/problems/subarray-sums-divisible-by-k",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/40_Longest_Subarray_Sum_Divisible_by_K.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "generate all subarrays among them find the longest subarray divisible by k",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm % k == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n        sm = 0\n        remainder_map = {0: -1}\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            rem = sm % k\n\n            if rem < 0:  # dont store negative remainder\n                rem += k\n\n            if rem in remainder_map:\n                mx_len = max(mx_len, i - remainder_map[rem])\n\n            if rem not in remainder_map:\n                remainder_map[rem] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 39,
        "question": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n\nExample 1:\n\nInput: nums = [1,1,1], k = 2\nOutput: 2\nExample 2:\n\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 2 * 10^4\n-1000 <= nums[i] <= 1000\n-10^7 <= k <= 10^7",
        "topic": "ArraysandHashing",
        "pattern": "SubarraySumCount",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray K Sum",
        "problem_link": "https://leetcode.com/problems/subarray-sum-equals-k",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/41_Count_Subarray_K_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays and count subarrays with sum k",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n\n                if sm == k:\n                    c += 1\n\n        return c",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the count till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum\nUse the concept of prefix sum\nhow many s-k we have to remove inorder from curr sum to get k\nno of s-k will be equivalent to no of k\n\nNow, there may exist multiple subarrays with the prefix sum x-k. So, the number of subarrays\nwith sum k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix sum x-k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        sm = 0\n        k_sum_count_map = {0: 1}\n        count = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n\n            diff = sm - k\n\n            if diff in k_sum_count_map:\n                count += k_sum_count_map[diff]\n\n            if sm not in k_sum_count_map:\n                k_sum_count_map[sm] = 1\n            else:\n                k_sum_count_map[sm] += 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 40,
        "question": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n\nA subarray is a contiguous part of an array.\n\n\nExample 1:\n\nInput: nums = [4,5,0,-2,-3,1], k = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\nExample 2:\n\nInput: nums = [5], k = 9\nOutput: 0\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-10^4 <= nums[i] <= 10^4\n2 <= k <= 10^4",
        "topic": "ArraysandHashing",
        "pattern": "SubarraySumCount",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray Sum Divisible by K",
        "problem_link": "https://leetcode.com/problems/subarray-sums-divisible-by-k",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/42_Count_Subarray_Sum_Divisible_by_K.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays from those subarrays count subarray sum divisible by k",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                if sm % k == 0:\n                    count += 1\n\n        return count",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n        rem_count_mp = {0: 1}\n        sm = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n            rem = sm % k\n\n            if rem < 0:\n                rem += k\n\n            if rem in rem_count_mp:\n                count += rem_count_mp[rem]\n\n            if rem not in rem_count_mp:\n                rem_count_mp[rem] = 1\n            else:\n                rem_count_mp[rem] += 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 41,
        "question": "Given an array of integers arr[] and a number k, count the number of subarrays having XOR of their elements as k.\n\nExamples:\n\nInput: arr[] = [4, 2, 2, 6, 4], k = 6\nOutput: 4\nExplanation: The subarrays having XOR of their elements as 6 are [4, 2], [4, 2, 2, 6, 4], [2, 2, 6], and [6]. Hence, the answer is 4.\n\nInput: arr[] = [5, 6, 7, 8, 9], k = 5\nOutput: 2\nExplanation: The subarrays having XOR of their elements as 5 are [5] and [5, 6, 7, 8, 9]. Hence, the answer is 2.\n\nInput: arr[] = [1, 1, 1, 1], k = 0\nOutput: 4\nExplanation: The subarrays are [1, 1], [1, 1], [1, 1] and [1, 1, 1, 1].\n\nConstraints:\n\n1 \u2264 arr.size() \u2264 10^5\n0 \u2264 arr[i] \u226410^5\n0 \u2264 k \u2264 10^5",
        "topic": "ArraysandHashing",
        "pattern": "SubarrayXORCount",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray K XOR",
        "problem_link": "https://www.geeksforgeeks.org/problems/count-subarray-with-given-xor/0",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/43_Count_Subarray_K_XOR.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(N)",
                "intuition": "Generate all subarrays count subarrays with k xor from them",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(arr)):\n            xor = 0\n            for j in range(i, len(arr)):\n                xor ^= arr[j]\n\n                if xor == k:\n                    c += 1\n\n        return c",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Now, there may exist multiple subarrays with the prefix xor pref^k. So, the number of subarrays\nwith xor k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix xor pref^k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        pref_xor = 0\n        count = 0\n        xor_mp = {0: 1}\n\n        for i in range(len(arr)):\n            pref_xor ^= arr[i]\n\n            diff_xor = pref_xor ^ k\n\n            if diff_xor in xor_mp:\n                count += xor_mp[diff_xor]\n\n            if pref_xor in xor_mp:\n                xor_mp[pref_xor] += 1\n            else:\n                xor_mp[pref_xor] = 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 42,
        "question": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\nExample 3:\n\nInput: nums = [1,0,1,2]\nOutput: 3\n\n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9",
        "topic": "ArraysandHashing",
        "pattern": "LongestSequence",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Consecutive Sequence",
        "problem_link": "https://leetcode.com/problems/longest-consecutive-sequence",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/44_Longest_Consecutive_Sequence.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N)) + O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "sort the array and find the longest consecutive sequence ignore equal length number",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        nums.sort()\n\n        mx_len = 1\n        curr_len = 1\n\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] == 1:\n                curr_len += 1\n                mx_len = max(mx_len, curr_len)\n            elif nums[i] - nums[i - 1] == 0:\n                mx_len = max(mx_len, curr_len)\n                continue\n            else:\n                curr_len = 1\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "The answer lies in visualization\nconsider the below array\n100 4 200 1 3 2\n\n1 2 3 4     100        200\n---------------------------\n\nconvert the given array to set\nstarting values of the sequence does not have left neightbour\nso whenever we find an element which does not have left neightbour\nwe will start a while loop incrementing it by 1 and check if that\nnumber exists and keep on building the sequence and atlast we can\ncheck if its the max length till now or not",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for num in numSet:\n            if (num - 1) not in numSet:\n                length = 1\n                while (num + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 43,
        "question": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
        "topic": "ArraysandHashing",
        "pattern": "KadanesAlgo",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Sum Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/45_Maximum_Sum_Subarray.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays, and find the subarray with max sum",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                mx_sum = max(mx_sum, sm)\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "A subarray with a sum less than 0 will always reduce our answer and so this type of subarray cannot be a part of the subarray with maximum sum among all the sum calculated we take the sum. In each pass we decide whethet to start a new seqeunce or continue or our old seqeunce",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        curr_sum = 0\n        global_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        return global_sum",
                "type": "Optimal"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "print the sequence\nwhen the sum is zero we can say right its a start of the sequnce\ntake 2 pointers ansStart and ansEnd and another variable to track\ncurrent start",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]):\n        curr_sum = 0\n        global_sum = -sys.maxsize\n        resStart, resEnd = 0, 0\n        currStart = 0\n\n        for i in range(len(nums)):\n            if curr_sum == 0:\n                currStart = i\n\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n                resStart = currStart\n                resEnd = i\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        print(\"Maximum subarray sequence:\", nums[resStart : resEnd + 1])\n        print(\"Maximum subarray sum:\", global_sum)\n\n\nobj = Solution()\nls = [1, -2, -1, 0, 3, 4]\nls = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nobj.maxSubArray(ls)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 44,
        "question": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\n\nA circular array means the end of the array connects to the beginning of the array. Formally,\nthe next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\n\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a\nsubarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 3 * 10^4\n-3 * 10^4 <= nums[i] <= 3 * 10^4",
        "topic": "ArraysandHashing",
        "pattern": "KadanesAlgo",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Circular Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/46_Maximum_Circular_Subarray_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "generate all subarrays find the max from those subarrays",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n        n = len(nums)\n        for i in range(n):\n            sm = 0\n            for j in range(n):\n                idx = (i + j) % n\n                sm += nums[idx]\n                mx_sum = max(sm, mx_sum)\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "rotate the array by one find max sum subarray keep track of global sum subarray",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        curr_sum = 0\n        global_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        return global_sum\n\n    def rotateByOne(self, nums: list[int]) -> None:\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            mx_sum = max(mx_sum, self.maxSubArray(nums))\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "T.C. -",
                "sc": "S.C  - O(1)",
                "intuition": "Suppose consider the below array\na b c d e f g h i j k l m\n------- --------- -------\nmax-sum min-sum(b) max-sum(a)\n-------------------------- total-sum(s)\nproof -> We know that a+b = S\nwe are claiming that b is the min sum\nbut suppose we say that in order to make b\nthe min sum, we need to reduce the value of b\nif we are reducing the value of b then we have\nto increase the value of a to inorder to balance\nout the sum , but wait a is already max sum we cannot\nincrease its value , so by contradiction its proven right\nthat b is the min sum\nbut whenever my total sum and min-sum is the same, then return\nthe normal sum , Egde case [-1,-2,-3] here the circular sum\nbecomes 0",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        total_sum = 0\n\n        curr_min_sum = 0\n        min_sum = sys.maxsize\n\n        curr_max_sum = 0\n        max_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            total_sum += nums[i]\n\n            curr_min_sum = min(nums[i], curr_min_sum + nums[i])\n            min_sum = min(min_sum, curr_min_sum)\n\n            curr_max_sum = max(nums[i], curr_max_sum + nums[i])\n            max_sum = max(max_sum, curr_max_sum)\n\n        circular_sum = total_sum - min_sum\n\n        if total_sum == min_sum:\n            return max_sum\n\n        return max(circular_sum, max_sum)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 45,
        "question": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\n\nExample 1:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\nExample 2:\n\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n\n\nConstraints:\n\n1 <= nums.length <= 2 * 10^4\n-10 <= nums[i] <= 10\nThe product of any subarray of nums is guaranteed to fit in a 32-bit integer.",
        "topic": "ArraysandHashing",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Product Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/47_Maximum_Product_Subarray.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all sub arrays and find the max product from it",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        mx_prod = -sys.maxsize\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod *= nums[j]\n                mx_prod = max(mx_prod, prod)\n        return mx_prod",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Observation 1 : if array has all postive then just return the prod of entire array\nObservation 2: if array has even nos of negative just return the prod of entire array\nObservation 3: if array has odd no of negatives just remove one negative (leaving us with even negative) and the answer will lie in either suffix or prefix\nObservation 4: if we have zero then we will not carry it over as it will reduce our maximum product , we will suffix,prefix to 1,1\nTo find the answer, we will check all possible prefix subarrays (starting from index 0) and all possible suffix subarrays (starting from index n-1)\nThe maximum product obtained from these prefix and suffix subarrays will be our final answer.",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        pref = 1\n        suff = 1\n        n = len(nums)\n        mx_prod = -sys.maxsize\n\n        for i in range(len(nums)):\n            if pref == 0:\n                pref = 1\n            if suff == 0:\n                suff = 1\n\n            pref *= nums[i]\n            suff *= nums[n - i - 1]\n\n            mx_prod = max(mx_prod, pref, suff)\n\n        return mx_prod",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 46,
        "question": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\n\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\nConstraints:\n\n2 <= nums.length <= 10^5\n-30 <= nums[i] <= 30\nThe input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.\n\n\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
        "topic": "ArraysandHashing",
        "pattern": "MaintainPrefixSuffix",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Product of array except itself",
        "problem_link": "https://leetcode.com/problems/product-of-array-except-self",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/48_Product_of_array_except_itself.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Find the product of each number except itself using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = []\n\n        for i in range(n):\n            p = 1\n            for j in range(n):\n                if i == j:\n                    continue\n                p *= nums[j]\n            ans.append(p)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N)+O(N)",
                "sc": "S.C  - O(N)+O(N)",
                "intuition": "Product of array except itself for an ith number is nothing but product of prefix sum till i-1 and suffix sum i+1 Example : [1 2 3 4 5 6] Prod of 3 excpe itself is => 1*2 * 4*5*6 --   ----- pref  suff",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        pref = [1] * n\n        for i in range(1, n):\n            pref[i] = pref[i - 1] * nums[i - 1]\n\n        suff = [1] * n\n        for i in range(n - 2, -1, -1):\n            suff[i] = suff[i + 1] * nums[i + 1]\n\n        ans = [1] * n\n        for i in range(n):\n            ans[i] = pref[i] * suff[i]\n\n        return ans",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Fill the result array on the fly\nfirst put the prefix part in the result\nthen put suffix part in the result",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [1] * n\n\n        pref = 1\n        for i in range(n):\n            ans[i] = pref\n            pref *= nums[i]\n\n        suff = 1\n        for j in range(n - 1, -1, -1):\n            ans[j] *= suff\n            suff *= nums[j]\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 47,
        "question": "Given two sorted arrays a[] and b[] of size n and m respectively, the task is to merge them in sorted order\nwithout using any extra space. Modify a[] so that it contains the first n elements and modify b[] so that it contains the last m elements.\n\nExamples:\n\nInput: a[] = [2, 4, 7, 10], b[] = [2, 3]\nOutput:\n2 2 3 4\n7 10\nExplanation: After merging the two non-decreasing arrays, we get, 2 2 3 4 7 10\n\nInput: a[] = [1, 5, 9, 10, 15, 20], b[] = [2, 3, 8, 13]\nOutput:\n1 2 3 5 8 9\n10 13 15 20\nExplanation: After merging two sorted arrays we get 1 2 3 5 8 9 10 13 15 20.\n\nInput: a[] = [0, 1], b[] = [2, 3]\nOutput:\n0 1\n2 3\nExplanation: After merging two sorted arrays we get 0 1 2 3.\n\nConstraints:\n1 <= a.size(), b.size() <= 10^5\n0 <= a[i], b[i] <= 10^7",
        "topic": "ArraysandHashing",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Merge Sorted Array Without Extra Space",
        "problem_link": "https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/49_Merge_Sorted_Array_Without_Extra_Space.py",
        "approaches": [
            {
                "tc": "T.C. - O((M+N) + M*log(M) + N*log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "use 2 pointers\nfix one pointer to the last index of 1st array\nfix another pointer to the first index if 2nd array\nkeep comparing if the j is smaller than i swap\notherwise break",
                "code": "class Solution:\n    def mergeArrays(self, a: list[int], b: list[int]) -> None:\n        i = len(a) - 1\n        j = 0\n\n        while i >= 0 and j < len(b) and b[j] < a[i]:\n            b[j], a[i] = a[i], b[j]\n            j += 1\n            i -= 1\n\n        a.sort()\n        b.sort()",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 48,
        "question": "Given an array of integers arr[]. Find the Inversion Count in the array.\nTwo elements arr[i] and arr[j] form an inversion if arr[i] > arr[j] and i < j.\n\nInversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If the array is already sorted then the inversion count is 0.\nIf an array is sorted in the reverse order then the inversion count is the maximum.\n\nExamples:\n\nInput: arr[] = [2, 4, 1, 3, 5]\nOutput: 3\nExplanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).\n\nInput: arr[] = [2, 3, 4, 5, 6]\nOutput: 0\nExplanation: As the sequence is already sorted so there is no inversion count.\n\nInput: arr[] = [10, 10, 10]\nOutput: 0\nExplanation: As all the elements of array are same, so there is no inversion count.\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^4",
        "topic": "ArraysandHashing",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Inversions",
        "problem_link": "https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/50_Count_Inversions.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Generate all subarrays and find the subarray with the matching condition",
                "code": "class Solution:\n    def inversionCount(self, arr):\n        c = 0\n        for i in range(len(arr)):\n            for j in range(len(arr)):\n                if i < j and arr[i] > arr[j]:\n                    c += 1\n        return c",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,2)(5,3),(5,4)\nwill form pair right as i<j and arr[i]>arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        i, j = l, mid + 1\n        tmp = []\n\n        c = 0\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                c += mid - i + 1  # include all the farther ahead elements too\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def inversionCount(self, arr: list[int]) -> int:\n        return self.mergeSort(0, len(arr) - 1, arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 49,
        "question": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].\n\n\nExample 1:\n\nInput: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\nExample 2:\n\nInput: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-2^31 <= nums[i] <= 2^31 - 1",
        "topic": "ArraysandHashing",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Reverse Pairs",
        "problem_link": "https://leetcode.com/problems/reverse-pairs",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/51_Reverse_Pairs.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "generate all pairs and check which pairs follow the condition",
                "code": "from typing import List\n\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        c = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j] * 2:\n                    c += 1\n        return c",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(NlogN)",
                "sc": "S.C  - O(N)",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,1)(5,2)\nwill form pair right as i<j and arr[i]>2*arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        c = 0\n        i, j = l, mid + 1\n        while i <= mid and j <= h:  #  check the condition before performing merge sort\n            if arr[i] > 2 * arr[j]:\n                c += (mid - i) + 1\n                j += 1\n            else:\n                i += 1\n\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def reversePairs(self, nums: List[int]) -> int:\n        return self.mergeSort(0, len(nums) - 1, nums)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 50,
        "question": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician\nJohn Horton Conway in 1970.\"\n\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0).\nEach cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of\nthe m x n grid board. In this process, births and deaths occur simultaneously.\n\nGiven the current state of the board, update the board to reflect its next state.\n\nNote that you do not need to return anything.\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\nExample 2:\n\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.",
        "topic": "ArraysandHashing",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Game of Life",
        "problem_link": "https://leetcode.com/problems/game-of-life",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/52_Game_of_Life.py",
        "approaches": [
            {
                "tc": "T.C. - O(M*N*8)",
                "sc": "S.C  - O(M*N)",
                "intuition": "Live cell with less than 2 live neighbors die Live cell with more than 2 or 3 live neighbors live Live cell with more than 3 live die Dead cell ressurects with exactly 3 live neighbors",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] == 1:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        ans = [[0 for _ in range(len(board[0]))] for _ in range(len(board))]\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        ans[i][j] = 0\n                    else:\n                        ans[i][j] = 1\n                else:\n                    if live_neighbor_count == 3:\n                        ans[i][j] = 1\n\n        board[::] = ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(M*N*8)+O(M*N) ~ O(M*N)",
                "sc": "S.C  - O(1)",
                "intuition": "we try to preserve the original values of each state\nmark the cell that was alive but will die as -2\nmark the cell that was dead but ressurects with 2",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] in [1, -2]:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        board[i][j] = -2\n                else:\n                    if live_neighbor_count == 3:\n                        board[i][j] = 2\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == -2:\n                    board[i][j] = 0\n                elif board[i][j] == 2:\n                    board[i][j] = 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 51,
        "question": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper,\nreturn the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the\nmaximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\n\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000",
        "topic": "ArraysandHashing",
        "pattern": "CountSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "H Index",
        "problem_link": "https://leetcode.com/problems/h-index",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/53_H_Index.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Do i have h papers that has been cited h times start with 0 and keep increasing the index by 1 and check if there can be h-index of i sice we have an array of size n, the max h-index can be n",
                "code": "from typing import List\n\n\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        h_index = 0\n\n        for i in range(1, len(citations) + 1):\n            c = 0\n            for j in range(len(citations)):\n                if citations[j] >= i:\n                    c += 1\n                if c == i:\n                    h_index = i\n                    break\n\n        return h_index",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N) ~ O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "we use a counting sort techique to solve this problem\nfirst we create an array of size n+1\neach index in the array represents the count of paper having i citaions\nsince we can have citations more than size of the array for those cases\nwe are going to use the last index of the array to store count\nwe start iterating from back of the array and check whether we have\npapers more than i value or not if we have then we just return i",
                "code": "from typing import List\n\n\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        count_arr = [0] * (len(citations) + 1)\n\n        for i in range(len(citations)):\n            if citations[i] >= len(citations):\n                count_arr[len(citations)] += 1\n            else:\n                count_arr[citations[i]] += 1\n\n        paper_count = 0\n        for i in range(len(count_arr) - 1, -1, -1):\n            paper_count += count_arr[i]\n            if paper_count >= i:\n                return i\n\n        return 0",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 52,
        "question": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\nbool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\nint getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n\nExample 1:\n\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\nConstraints:\n\n-2^31 <= val <= 2^31 - 1\nAt most 2 * 10^5 calls will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.",
        "topic": "ArraysandHashing",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Insert Delete GetRandom O(1)",
        "problem_link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/54_Insert_Delete_GetRandom_O(1).py",
        "approaches": [
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(N)+O(N)",
                "intuition": "",
                "code": "import random\n\n\nclass RandomizedSet:\n\n    def __init__(self):\n        self.indices: dict[int, int] = {}\n        self.vals: list[int] = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.indices:\n            return False\n\n        self.indices[val] = len(self.vals)\n        self.vals.append(val)\n\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.indices:\n            return False\n\n        # Swap the last element with this val\n        delete_element_idx = self.indices[val]\n        last_element_idx = len(self.vals) - 1\n\n        self.vals[delete_element_idx], self.vals[last_element_idx] = (\n            self.vals[last_element_idx],\n            self.vals[delete_element_idx],\n        )\n\n        # Update the index of the last element\n        self.indices[self.vals[delete_element_idx]] = delete_element_idx\n\n        self.vals.pop(-1)\n        del self.indices[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.vals)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\n\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\n\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\n\nExample 1:\n\nInput: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation:\nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\nExample 2:\n\nInput: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation:\nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\nExample 3:\n\nInput: s = \"()()\"\nOutput: \"\"\nExplanation:\nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n\n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "topic": "String",
        "pattern": "Parentheses",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Remove Outermost Parentheses",
        "problem_link": "https://leetcode.com/problems/remove-outermost-parentheses",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/1_Remove_Outermost_Parentheses.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Suppose we have an input case : s = \"(()())(())(()(()))\"\n\n(()()) Part1\n121210\n\n(()) Part2\n1210\n\n(()(())) Part3\n12123210\n\nThere is a pattern,\n+ if depth count is 1 and if its opening brace then it is the outermost opening brace\n+ if depth count is 0 and its closing brace, it is the outermost closing brace",
                "code": "class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        depthCount: int = 0\n        res: str = \"\"\n\n        for char in s:\n\n            if char == \"(\":\n                depthCount += 1\n\n            elif char == \")\":\n                depthCount -= 1\n\n            if depthCount == 1 and char == \"(\":\n                continue\n\n            if depthCount == 0 and char == \")\":\n                continue\n\n            res += char\n\n        return res",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.\n\n\nExample 1:\n\nInput: s = \"(1+(2*3)+((8)/4))+1\"\n\nOutput: 3\n\nExplanation:\n\nDigit 8 is inside of 3 nested parentheses in the string.\n\nExample 2:\n\nInput: s = \"(1)+((2))+(((3)))\"\n\nOutput: 3\n\nExplanation:\n\nDigit 3 is inside of 3 nested parentheses in the string.\n\nExample 3:\n\nInput: s = \"()(())((()()))\"\n\nOutput: 3\n\n\nConstraints:\n\n1 <= s.length <= 100\ns consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.\nIt is guaranteed that parentheses expression s is a VPS.",
        "topic": "String",
        "pattern": "Parentheses",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Maximum Nesting Depth of the Parentheses",
        "problem_link": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/2_Maximum_Nesting_Depth_of_the_Parentheses.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "maintain a depth count\nif its an open parentheses add one\nif its a closed parentheses decrement one\nthe max count throught the process will be the max depth",
                "code": "class Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n\n        for char in s:\n            if char == \"(\":\n                depth += 1\n            elif char == \")\":\n                depth -= 1\n            max_depth = max(max_depth, depth)\n\n        return max_depth",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\n\nReturn a string of the words in reverse order concatenated by a single space.\n\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n\nExample 1:\n\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\nExample 2:\n\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\nExample 3:\n\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\nConstraints:\n\n1 <= s.length <= 10^4\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
        "topic": "String",
        "pattern": "Reversal",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Reverse words in a given string",
        "problem_link": "https://leetcode.com/problems/reverse-words-in-a-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/3_Reverse_words_in_a_given_string.py",
        "approaches": [
            {
                "tc": "T.C. - O(2N) ~ O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "extract only words from string and put them into the list reverse the list return the list by using join keyword",
                "code": "class Solution:\n    def split_string_to_words(self, s: str) -> list[str]:\n        words: list[str] = []\n        tmp: str = \"\"\n\n        for i in range(len(s)):\n            if s[i] == \" \":\n                if tmp:\n                    words.append(tmp)\n                    tmp = \"\"\n            else:\n                tmp += s[i]\n\n        if tmp:\n            words.append(tmp)\n\n        return words\n\n    def reverse_list(self, words: list[str]):\n        i, j = 0, len(words) - 1\n\n        while i < j:\n            words[i], words[j] = words[j], words[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        words = self.split_string_to_words(s)\n        self.reverse_list(words)\n        return \" \".join(words)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "use pythons builtin split to split into words then reverse the list return the reversed list using join keyword",
                "code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(s.split()[::-1])",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "reverse whole string first\nTake 2 pointers l and r it will be used to reverse words between them\nkeep moving i until you reach non space character , then assign the character at ith index with the character at r index\nwhen we encounter space , reverse words between l and r index\nmove r to one place after space and assign l to r, repeat the above process until i exhauts the string",
                "code": "class Solution:\n    def rev(self, i: int, j: int, s: list[str]):\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        mutable_str = list(s)\n\n        self.rev(0, len(mutable_str) - 1, mutable_str)\n\n        l, r = 0, 0  # will be used for reversing string\n        i = 0  # will be used to traverse string\n        # r will be used for writing\n\n        while i < len(mutable_str):\n            while i < len(mutable_str) and mutable_str[i] != \" \":\n                mutable_str[r] = mutable_str[i]\n                i += 1\n                r += 1\n\n            if l < r:\n                self.rev(l, r - 1, mutable_str)\n                mutable_str[r] = \" \"\n                r += 1\n                l = r\n\n            i += 1\n\n        return \"\".join(mutable_str[: r - 1])",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that\nis a non-empty substring of num, or an empty string \"\" if no odd integer exists.\nA substring is a contiguous sequence of characters within a string.\n\nExample 1:\n\nInput: num = \"52\"\nOutput: \"5\"\nExplanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number.\nExample 2:\n\nInput: num = \"4206\"\nOutput: \"\"\nExplanation: There are no odd numbers in \"4206\".\nExample 3:\n\nInput: num = \"35427\"\nOutput: \"35427\"\nExplanation: \"35427\" is already an odd number.\n\n\nConstraints:\n\n1 <= num.length <= 10^5\nnum only consists of digits and does not contain any leading zeros.",
        "topic": "String",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Largest Odd Number in string",
        "problem_link": "https://leetcode.com/problems/largest-odd-number-in-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/4_Largest_Odd_Number_in_string.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "An odd number ends with either 1,3,5,7,9\nwe want the largest-valued odd number in\nthe string, so if we traverse from back of the string\nand find the first number that is not divisible by\n2 that will give us the larges possible odd number\nsubstring from the given input string",
                "code": "class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        for i in range(len(num) - 1, -1, -1):\n            if int(num[i]) % 2 != 0:\n                return num[: i + 1]\n        return \"\"",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.",
        "topic": "String",
        "pattern": "LCP",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Longest Common Prefix",
        "problem_link": "https://leetcode.com/problems/longest-common-prefix",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/5_Longest_Common_Prefix.py",
        "approaches": [
            {
                "tc": "T.C. - O(S)",
                "sc": "S.C  - O(1)",
                "intuition": "Take a comparison string suppose the first word in strs\nKeep checking each character of the comparison_str , whether its\npresent in all words in the strs or not, if any time the char is\nnot common or the character index is greater than length of the\nword we return as from that moment onwards we dont have longest\nprefix substring",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if len(strs) == 1:\n            return strs[0]\n\n        comparison_str = strs[0]\n        lcp = \"\"\n\n        for i, char in enumerate(comparison_str):\n            is_char_common = True\n            for st in strs:\n                if i + 1 > len(st) or st[i] != char:\n                    is_char_common = False\n                    return lcp\n            if is_char_common:\n                lcp += char\n\n        return lcp",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters.\nNo two characters may map to the same character, but a character may map to itself.\n\n\nExample 1:\n\nInput: s = \"egg\", t = \"add\"\n\nOutput: true\n\nExplanation:\n\nThe strings s and t can be made identical by:\n\nMapping 'e' to 'a'.\nMapping 'g' to 'd'.\nExample 2:\n\nInput: s = \"foo\", t = \"bar\"\n\nOutput: false\n\nExplanation:\n\nThe strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.\n\nExample 3:\n\nInput: s = \"paper\", t = \"title\"\n\nOutput: true\n\n\nConstraints:\n\n1 <= s.length <= 5 * 10^4\nt.length == s.length\ns and t consist of any valid ascii character.",
        "topic": "String",
        "pattern": "SpecialString",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Isomorphic Strings",
        "problem_link": "https://leetcode.com/problems/isomorphic-strings",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/6_Isomorphic_Strings.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(2N)",
                "intuition": "Just keep 2 hashmaps and assign a char of s to t and vice versa\nif a already assigned char from c does not matches with\nt and vice versa, return False otherwise at the end return True",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        cmap1, cmap2 = {}, {}\n\n        for i in range(len(s)):\n            c1 = s[i]\n            c2 = t[i]\n\n            if (c1 in cmap1 and cmap1[c1] != c2) or (c2 in cmap2 and cmap2[c2] != c1):\n                return False\n\n            cmap1[c1] = c2\n            cmap2[c2] = c1\n\n        return True",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false\n\n\nConstraints:\n\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.\n\n\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "topic": "String",
        "pattern": "SpecialString",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Valid Anagram",
        "problem_link": "https://leetcode.com/problems/valid-anagram",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/7_Valid_Anagram.py",
        "approaches": [
            {
                "tc": "T.C. - O(S)",
                "sc": "S.C  - O(S)+O(T)",
                "intuition": "Just compare the frequency map of\nthe 2 strings",
                "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        freq_map_s = {}\n        freq_map_t = {}\n\n        for i in range(len(s)):\n            freq_map_s[s[i]] = 1 + freq_map_s.get(s[i], 0)\n            freq_map_t[t[i]] = 1 + freq_map_t.get(t[i], 0)\n\n        return freq_map_s == freq_map_t",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n\nExample 1:\n\nInput: s = \"abcde\", goal = \"cdeab\"\nOutput: true\nExample 2:\n\nInput: s = \"abcde\", goal = \"abced\"\nOutput: false\n\n\nConstraints:\n\n1 <= s.length, goal.length <= 100\ns and goal consist of lowercase English letters.",
        "topic": "String",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Rotate String",
        "problem_link": "https://leetcode.com/problems/rotate-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/8_Rotate_String.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep rotating the string by 1 if at any point we reach the goal string return True",
                "code": "class Solution:\n    def rotate_by_one(self, s: list[str]) -> str:\n        for i in range(len(s) - 1):\n            s[i], s[i + 1] = s[i + 1], s[i]\n        return \"\".join(s)\n\n    def rotateString(self, s: str, goal: str) -> bool:\n        for _ in range(len(s)):\n            s = self.rotate_by_one(list(s))\n            if s == goal:\n                return True\n\n        return False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "double concatentate the input string\nand check whether the goal exits in the\nconcatentated string",
                "code": "class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        if len(s) != len(goal):\n            return False\n\n        concatenated = s + s\n\n        return concatenated.find(goal) != -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "topic": "String",
        "pattern": "IntegerRoman",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Roman to Integer",
        "problem_link": "https://leetcode.com/problems/roman-to-integer",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/9_Roman_to_Integer.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(7)",
                "intuition": "Keep iterating and Keep track of the final val\nsince roman nums are written from largest to smallest keep addding the\ncurrrent characters val if curr_char is lesser than prev_char , but\nif curr_char is greater then prev_char take out the prev_char from\nfinal val and add (curr_char-prev_char) to the final val",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_num_map = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000,\n        }\n\n        val: int = 0\n        val += roman_num_map[s[0]]\n\n        for i in range(1, len(s)):\n            curr_char: str = s[i]\n            prev_char: str = s[i - 1]\n\n            if roman_num_map[curr_char] > roman_num_map[prev_char]:\n                val -= roman_num_map[prev_char]\n                val += roman_num_map[curr_char] - roman_num_map[prev_char]\n            else:\n                val += roman_num_map[curr_char]\n\n        return val",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t10\nL\t50\nC\t100\nD\t500\nM\t1000\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\nIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\nGiven an integer, convert it to a Roman numeral.\n\n\nExample 1:\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n700 = DCC as 500 (D) + 100 (C) + 100 (C)\n40 = XL as 10 (X) less of 50 (L)\n9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\nExample 2:\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n8 = VIII\nExample 3:\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n900 = CM\n90 = XC\n4 = IV\n\n\nConstraints:\n\n1 <= num <= 3999",
        "topic": "String",
        "pattern": "IntegerRoman",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Integer to Roman",
        "problem_link": "https://leetcode.com/problems/integer-to-roman",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/10_Integer_to_Roman.py",
        "approaches": [
            {
                "tc": "T.C. -",
                "sc": "S.C  -",
                "intuition": "",
                "code": "",
                "type": "Brute"
            },
            {
                "tc": "T.C. -",
                "sc": "S.C  -",
                "intuition": "",
                "code": "",
                "type": "Better"
            },
            {
                "tc": "T.C. -",
                "sc": "S.C  -",
                "intuition": "",
                "code": "",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.\nIf target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n\nExample 1:\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\nExample 2:\n\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\n\nConstraints:\n\n1 <= nums.length <= 10^4\n-10^4 < nums[i], target < 10^4\nAll the integers in nums are unique.\nnums is sorted in ascending order.",
        "topic": "BinarySearch",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Binary Search",
        "problem_link": "https://leetcode.com/problems/binary-search",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/1_Binary_Search.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Every time find the mid index\nif the element at the mid index is lesser than target ,\nthen move the start pointer to mid+1 as all the elements in\nthe left of mid will always be smaller no need to go in that direction\nif the element at the mid index is greater than target ,\nthen move the end pointer to mid-1 as all the elements in\nthe right of mid will always be greater no need to go in that direction",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given a sorted array arr[] and an integer x, find the index (0-based) of the largest element in arr[] that is less than or equal to x. This element is called the floor of x. If such an element does not exist, return -1.\n\nNote: In case of multiple occurrences of ceil of x, return the index of the last occurrence.\n\nExamples\n\nInput: arr[] = [1, 2, 8, 10, 10, 12, 19], x = 5\nOutput: 1\nExplanation: Largest number less than or equal to 5 is 2, whose index is 1.\n\nInput: arr[] = [1, 2, 8, 10, 10, 12, 19], x = 11\nOutput: 4\nExplanation: Largest Number less than or equal to 11 is 10, whose indices are 3 and 4. The index of last occurrence is 4.\n\nInput: arr[] = [1, 2, 8, 10, 10, 12, 19], x = 0\nOutput: -1\nExplanation: No element less than or equal to 0 is found. So, output is -1.\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^6\n1 \u2264 arr[i] \u2264 10^6\n0 \u2264 x \u2264 arr[n-1]",
        "topic": "BinarySearch",
        "pattern": "lower-bound/floor",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Lower Bound",
        "problem_link": "https://www.geeksforgeeks.org/problems/floor-in-a-sorted-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/2_Lower_Bound.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a binary search for floor\nsince we need to find the value lesser than equal to x but the largest\nwhen we encounter an element with that condition we store the index\nin an answer and move more towards right and if we find number greater\nthan target we move towards left",
                "code": "class Solution:\n    def findFloor(self, arr: list[int], x: int) -> int:\n        st, en = 0, len(arr) - 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] <= x:\n                ans = mid\n                st = mid + 1\n            elif arr[mid] > x:\n                en = mid - 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an unsorted array arr[] of integers and an integer x, find the floor and ceiling of x in arr[].\n\nFloor of x is the largest element which is smaller than or equal to x. Floor of x doesn\u2019t exist if x is smaller than smallest element of arr[].\nCeil of x is the smallest element which is greater than or equal to x. Ceil of x doesn\u2019t exist if x is greater than greatest element of arr[].\n\nReturn an array of integers denoting the [floor, ceil]. Return -1 for floor or ceiling if the floor or ceiling is not present.\n\nExamples:\n\nInput: x = 7 , arr[] = [5, 6, 8, 9, 6, 5, 5, 6]\nOutput: 6, 8\nExplanation: Floor of 7 is 6 and ceil of 7 is 8.\n\nInput: x = 10 , arr[] = [5, 6, 8, 8, 6, 5, 5, 6]\nOutput: 8, -1\nExplanation: Floor of 10 is 8 but ceil of 10 is not possible.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(1)\n\nConstraints :\n1 \u2264 arr.size \u2264 10^5\n1 \u2264 arr[i], x \u2264 10^6",
        "topic": "BinarySearch",
        "pattern": "upper-bound/ceil",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Upper Bound",
        "problem_link": "https://www.geeksforgeeks.org/problems/floor-in-a-sorted-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/3_Upper_Bound.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))+O(log(N)) ~ O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a binary search for floor\nsince we need to find the value lesser than equal to x but the largest\nwhen we encounter an element with that condition we store the index\nin an answer and move more towards right and if we find number greater\nthan target we move towards left\n\nDo a binary search for ceil\nsince we need to find the value greater than equal to x but the smallest\nwhen we encounter an element with that condition we store the index\nin an answer and move more towards left and if we find number lesser\nthan target we move towards right",
                "code": "class Solution:\n    def floor(self, x: int, arr: list[int]):\n        st, en = 0, len(arr) - 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] <= x:\n                ans = arr[mid]\n                st = mid + 1\n            elif arr[mid] > x:\n                en = mid - 1\n\n        return ans\n\n    def ceil(self, x: int, arr: list[int]):\n        st, en = 0, len(arr) - 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] >= x:\n                ans = arr[mid]\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans\n\n    def getFloorAndCeil(self, x: int, arr: list[int]) -> list[int]:\n        arr.sort()\n        floor = self.floor(x, arr)\n        ceil = self.ceil(x, arr)\n\n        return [floor, ceil]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not,\nreturn the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n\nConstraints:\n\n1 <= nums.length <= 10^4\n-10^4 <= nums[i] <= 10^4\nnums contains distinct values sorted in ascending order.\n-10^4 <= target <= 10^4",
        "topic": "BinarySearch",
        "pattern": "upper-bound/ceil",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Search Insert Position",
        "problem_link": "https://leetcode.com/problems/search-insert-position",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/4_Search_Insert_Position.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find the ceil and return",
                "code": "from typing import List\n\n\nclass Solution:\n    def ceil(self, x: int, arr: list[int]):\n        st, en = 0, len(arr) - 1\n        ans = len(arr)\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] >= x:\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans\n\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return self.ceil(target, nums)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n\nExample 1:\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\nnums is a non-decreasing array.\n-10^9 <= target <= 10^9",
        "topic": "BinarySearch",
        "pattern": "floor/ceil",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find First and Last Position of Element in Sorted Array",
        "problem_link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/5_Find_First_and_Last_Position_of_Element_in_Sorted_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Traverse the array and if you find the target number first store it in a variable only if we have not see this in past and keep traversing forward keep track of the last index of the target in a variable called last only if we have seen in the past",
                "code": "from typing import List\n\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first, last = -1, -1\n        hasSeenFirst = False\n\n        for idx, num in enumerate(nums):\n            if num == target and not hasSeenFirst:\n                hasSeenFirst = True\n                first = idx\n                last = idx\n\n            elif hasSeenFirst and num == target:\n                last = idx\n\n        return [first, last]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "For finding first occurence do a bainry search\nkeep finding the mid and if we find the number\nthen keep going left as we want the first possible occurence\n\nFor finding last occurence do a bainry search\nkeep finding the mid and if we find the number\nthen keep going right as we want the last possible occurence",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstOccurence(self, nums: List[int], target: int) -> int:\n        ans = -1\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                en = mid - 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def lastOccurence(self, nums: List[int], target: int) -> int:\n        ans = -1\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                st = mid + 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first = self.firstOccurence(nums, target)\n        last = self.lastOccurence(nums, target)\n\n        return [first, last]\n\n\nls = [1, 0, 0]\nobj = Solution()\nprint(obj.searchRange(ls, 1))",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given a sorted array, arr[] and a number target, you need to find the number of occurrences of target in arr[].\n\nExamples :\n\nInput: arr[] = [1, 1, 2, 2, 2, 2, 3], target = 2\nOutput: 4\nExplanation: target = 2 occurs 4 times in the given array so the output is 4.\n\nInput: arr[] = [1, 1, 2, 2, 2, 2, 3], target = 4\nOutput: 0\nExplanation: target = 4 is not present in the given array so the output is 0.\n\nInput: arr[] = [8, 9, 10, 12, 12, 12], target = 12\nOutput: 3\nExplanation: target = 12 occurs 3 times in the given array so the output is 3.\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^6\n1 \u2264 arr[i] \u2264 10^6\n1 \u2264 target \u2264 10^6",
        "topic": "BinarySearch",
        "pattern": "floor/ceil",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Number of occurrence",
        "problem_link": "https://www.geeksforgeeks.org/problems/number-of-occurrence2259/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/6_Number_of_occurrence.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find first occurence (F)\nFind last occurence (L)\nreturn L-F+1",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstOccurence(self, nums: List[int], target: int) -> int:\n        ans = len(nums)\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                en = mid - 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def lastOccurence(self, nums: List[int], target: int) -> int:\n        ans = len(nums)\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                st = mid + 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def countFreq(self, arr: list[int], target: int):\n        lastOccurence = self.lastOccurence(arr, target)\n        firstOccurence = self.firstOccurence(arr, target)\n        if lastOccurence == len(arr) and firstOccurence == len(arr):\n            return 0\n        return (lastOccurence - firstOccurence) + 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1\n\n\nConstraints:\n\n1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-10^4 <= target <= 10^4",
        "topic": "BinarySearch",
        "pattern": "BS-In-Rotated-Sorted-Array",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Search in Rotated Sorted Array I",
        "problem_link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/7_Search_in_Rotated_Sorted_Array_I.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Do a linear search to find the target",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find which part is sorted\nCheck if target has possibility to be present in sorted part",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            # Check which part is sorted\n\n            # if right is sorted\n            if nums[mid] <= nums[en]:\n                # target is definitely present in right\n                if nums[mid] <= target <= nums[en]:\n                    st = mid + 1\n                else:\n                    en = mid - 1\n            # if left is sorted\n            else:\n                # target is definitely present in left\n                if nums[st] <= target <= nums[mid]:\n                    en = mid - 1\n                else:\n                    st = mid + 1\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\n\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n\nExample 1:\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\n\nConstraints:\n\n1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nnums is guaranteed to be rotated at some pivot.\n-10^4 <= target <= 10^4\n\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "topic": "BinarySearch",
        "pattern": "BS-In-Rotated-Sorted-Array",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Search in Rotated Sorted Array II",
        "problem_link": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/8_Search_in_Rotated_Sorted_Array_II.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Do a linear search to find the target",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return True\n\n        return False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find which part is sorted\nCheck if target has possibility to be present in sorted part\nAt any point we see that arr[mid],arr[st],arr[en] are equal we move\nstart ahead and end pointer backwards and reduce our search space\nas we will not be able to decide which part to go in order to\nreduce search space",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                return True\n\n            # Remove duplicates\n            if nums[st] == nums[mid] and nums[mid] == nums[en]:\n                st += 1\n                en -= 1\n                continue\n\n            # Check which part is sorted\n\n            # if right is sorted\n            if nums[mid] <= nums[en]:\n                # target is definitely present in right\n                if nums[mid] <= target <= nums[en]:\n                    st = mid + 1\n                else:\n                    en = mid - 1\n            # if left is sorted\n            else:\n                # target is definitely present in left\n                if nums[st] <= target <= nums[mid]:\n                    en = mid - 1\n                else:\n                    st = mid + 1\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.",
        "topic": "BinarySearch",
        "pattern": "BS-In-Rotated-Sorted-Array",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find Minimum Rotated Sorted Array",
        "problem_link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/9_Find_Minimum_Rotated_Sorted_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just find the min element in the whole array by making a linear scan",
                "code": "from typing import List\n\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        min_elem = nums[0]\n\n        for i in range(1, len(nums)):\n            min_elem = min(min_elem, nums[i])\n\n        return min_elem",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "One key observation is since array is rotated sorted,for\nevery index one half will be sorted and other will be unsorted\nwe will take the advantage of the sorted property and we are going\nto store the minimum from the sorted in a varaible and discard\nthe sorted half and move to the unsorted half as from sorted we\nhave already picked up the min element",
                "code": "from typing import List\n\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        st, en = 0, len(nums) - 1\n        ans = 500\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            # if we cross the rotated point\n            if nums[st] <= nums[mid] and nums[mid] <= nums[en]:\n                ans = min(ans, nums[st])\n                break\n\n            # if left is sorted\n            if nums[st] <= nums[mid]:\n                # discard sorted half and move to unsorted\n                ans = min(ans, nums[st])\n                st = mid + 1\n\n            # right is sorted\n            else:\n                # discard sorted half and move to unsorted\n                ans = min(ans, nums[mid])\n                en = mid - 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Given an increasing sorted rotated array arr of distinct integers. The array is right-rotated k times. Find the value of k.\nLet's suppose we have an array arr = [2, 4, 6, 9], so if we rotate it by 2 times so that it will look like this:\nAfter 1st Rotation : [9, 2, 4, 6]\nAfter 2nd Rotation : [6, 9, 2, 4]\n\nExamples:\n\nInput: arr = [5, 1, 2, 3, 4]\nOutput: 1\nExplanation: The given array is 5 1 2 3 4. The original sorted array is 1 2 3 4 5. We can see that the array was rotated 1 times to the right.\n\nInput: arr = [1, 2, 3, 4, 5]\nOutput: 0\nExplanation: The given array is not rotated.\n\nConstraints:\n1 \u2264 arr.size() \u226410^5\n1 \u2264 arri \u2264 10^7",
        "topic": "BinarySearch",
        "pattern": "BS-In-Rotated-Sorted-Array",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find out how many times has an array been rotated",
        "problem_link": "https://www.geeksforgeeks.org/problems/rotation4723/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/10_Find_out_how_many_times_has_an_array_been_rotated.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)+O(Nlog(N))",
                "sc": "S.C  - O(N)",
                "intuition": "Keep left rotating the arr by 1 maintain count of rotatios if target array is reached then return",
                "code": "from typing import List\n\n\nclass Solution:\n    def left_rotate(self, arr: List[int]) -> List[int]:\n        for i in range(len(arr) - 1):\n            arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        return arr\n\n    def findKRotation(self, arr: List[int]):\n        c = 0\n        target_arr = sorted(arr)\n        if arr == target_arr:\n            return c\n\n        for i in range(len(arr)):\n            arr = self.left_rotate(arr)\n            c += 1\n            if arr == target_arr:\n                return c\n\n        return c",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find min element index",
                "code": "from typing import List\n\n\nclass Solution:\n    def findMinIndex(self, nums: List[int]) -> int:\n        st, en = 0, len(nums) - 1\n        ans = float(\"inf\")\n        index = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            # if we cross the rotated point\n            if nums[st] <= nums[mid] and nums[mid] <= nums[en]:\n                if nums[st] < ans:\n                    index = st\n                    ans = nums[st]\n                break\n\n            # if left is sorted\n            if nums[st] <= nums[mid]:\n                # discard sorted half and move to unsorted\n                if nums[st] < ans:\n                    index = st\n                    ans = nums[st]\n                st = mid + 1\n\n            # right is sorted\n            else:\n                # discard sorted half and move to unsorted\n                if nums[mid] < ans:\n                    index = mid\n                    ans = nums[mid]\n                en = mid - 1\n\n        return index\n\n    def findKRotation(self, arr: list[int]):\n        return self.findMinIndex(arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 11,
        "question": "You are given a sorted numsay consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn the single element that appears only once.\n\nYour solution must run in O(log n) time and O(1) space.\n\n\nExample 1:\n\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\n\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^5",
        "topic": "BinarySearch",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Single Element in a Sorted Array",
        "problem_link": "https://leetcode.com/problems/single-element-in-a-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/11_Single_Element_in_a_Sorted_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "xor out every element and then return",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        xor = 0\n\n        for num in nums:\n            xor ^= num\n\n        return xor",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "o e o e o e o e o e o\n0,0,1,1,2,3,3,4,4,8,8\n\no-> odd idx\ne-> even idx\n\nif i am at right of single element then if i am at even index\nand the next adjacent number is also same then i am at right side\nof the single element then i will move to left.\nif iam at left of single element then if i am at odd index and\nthe next adjacent number is also same the i am at left side of\nthe single element then i will move to the right.",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        st, en = 1, len(nums) - 2\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid - 1] != nums[mid] and nums[mid] != nums[mid + 1]:\n                return nums[mid]\n\n            # if odd index\n            if mid % 2 == 1:\n                # If at right half\n                if (mid + 1) % 2 == 0 and nums[mid] == nums[mid + 1]:\n                    en = mid - 1\n                # If at left half\n                else:\n                    st = mid + 1\n\n            # if even index\n            else:\n                # If at left half\n                if (mid + 1) % 2 == 1 and nums[mid] == nums[mid + 1]:\n                    st = mid + 1\n                # If at right half\n                else:\n                    en = mid - 1\n\n        if len(nums) == 1:\n            return nums[0]\n\n        if nums[0] != nums[1]:\n            return nums[0]\n\n        if nums[-1] != nums[-2]:\n            return nums[-1]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 12,
        "question": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer numsay nums, find a peak element, and return its index. If the numsay contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the numsay.\n\nYou must write an algorithm that runs in O(log n) time.\n\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\nConstraints:\n\n1 <= nums.length <= 1000\n-2^31 <= nums[i] <= 2^31 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "topic": "BinarySearch",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find Peak Element",
        "problem_link": "https://leetcode.com/problems/find-peak-element",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/12_Find_Peak_Element.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "just check which element is greater than 2 of its neighbour in single pass",
                "code": "from typing import List\n\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 0\n\n        for i in range(len(nums)):\n            if i == 0 and nums[0] > nums[1]:\n                return 0\n            elif i == len(nums) - 1 and nums[len(nums) - 1] > nums[len(nums) - 2]:\n                return len(nums) - 1\n\n            elif nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                return i",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "By observation its clear that\nwe are at position mid then if we\nthat any of the 2 neighbours have\nvalues higher than current mid\nthen we can say that there is a high chance\nwe will find the peak there\nwalk through an example",
                "code": "from typing import List\n\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        st, en = 1, len(nums) - 2\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] > nums[mid - 1] and nums[mid] > nums[mid + 1]:\n                return mid\n\n            # Find promising canditate in which direction we can find peak\n\n            # if Right Neighbour is promising\n            if nums[mid + 1] > nums[mid] and nums[mid + 1] > nums[mid]:\n                st = mid + 1\n\n            else:\n                # if Left Neighbour is promising\n                en = mid - 1\n\n        if len(nums) == 1:\n            return 0\n\n        if nums[0] > nums[1]:\n            return 0\n\n        if nums[-1] > nums[-2]:\n            return len(nums) - 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 13,
        "question": "Given an array of integers arr[] that is first strictly increasing and then maybe strictly decreasing, find the bitonic point, that is the maximum element in the array.\nBitonic Point is a point before which elements are strictly increasing and after which elements are strictly decreasing.\n\nNote: It is guaranteed that the array contains exactly one bitonic point.\n\nExamples:\n\nInput: arr[] = [1, 2, 4, 5, 7, 8, 3]\nOutput: 8\nExplanation: Elements before 8 are strictly increasing [1, 2, 4, 5, 7] and elements after 8 are strictly decreasing [3].\n\nInput: arr[] = [10, 20, 30, 40, 50]\nOutput: 50\nExplanation: Elements before 50 are strictly increasing [10, 20, 30 40] and there are no elements after 50.\n\nInput: arr[] = [120, 100, 80, 20, 0]\nOutput: 120\nExplanation: There are no elements before 120 and elements after 120 are strictly decreasing [100, 80, 20, 0].\n\nConstraints:\n3 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^6",
        "topic": "BinarySearch",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find Bitonic Point",
        "problem_link": "https://www.geeksforgeeks.org/problems/maximum-value-in-a-bitonic-array3001/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/13_Find_Bitonic_Point.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "just check which element is greater than 2 of its neighbour in single pass",
                "code": "from typing import List\n\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 0\n\n        for i in range(len(nums)):\n            if i == 0 and nums[0] > nums[1]:\n                return nums[0]\n            elif i == len(nums) - 1 and nums[len(nums) - 1] > nums[len(nums) - 2]:\n                return nums[len(nums) - 1]\n\n            elif nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                return nums[i]\n\n    def findMaximum(self, arr: list[int]):\n        return self.findPeakElement(arr)",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find peak element using BS",
                "code": "from typing import List\n\n\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        st, en = 1, len(nums) - 2\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] > nums[mid - 1] and nums[mid] > nums[mid + 1]:\n                return nums[mid]\n\n            # Find promising canditate in which direction we can find peak\n\n            # if Right Neighbour is promising\n            if nums[mid + 1] > nums[mid] and nums[mid + 1] > nums[mid]:\n                st = mid + 1\n\n            else:\n                # if Left Neighbour is promising\n                en = mid - 1\n\n        if len(nums) == 1:\n            return nums[0]\n\n        if nums[0] > nums[1]:\n            return nums[0]\n\n        if nums[-1] > nums[-2]:\n            return nums[len(nums) - 1]\n\n    def findMaximum(self, arr: list[int]):\n        return self.findPeakElement(arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 14,
        "question": "Given a positive integer n, find the square root of n. If n is not a perfect square, then return the floor value.\n\nFloor value of any number is the greatest Integer which is less than or equal to that number\n\nExamples:\n\nInput: n = 4\nOutput: 2\nExplanation: Since, 4 is a perfect square, so its square root is 2.\n\nInput: n = 11\nOutput: 3\nExplanation: Since, 11 is not a perfect square, floor of square root of 11 is 3.\n\nInput: n = 1\nOutput: 1\n\nConstraints:\n1 \u2264 n \u2264 3*10^4",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Square root",
        "problem_link": "https://www.geeksforgeeks.org/problems/square-root/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/14_Square_root.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just keep checking if we square the number starting from 1 to n and we get back the input number then return the i , if we exceed the number then we exit out of the loop Also keep track of the number as we iterate",
                "code": "class Solution:\n    def floorSqrt(self, n: int) -> int:\n        ans = 1\n        for i in range(1, n + 1):\n            if i * i == n:\n                return i\n            if i * i > n:\n                break\n            ans = i\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "start a binary search with start\nas 1 and end as number just keep\nchecking if we square the number and\nexceed then we move more towards left\nand if we are less then number we move\ntowards right increasing our search space\nif we see the square of current mid equals\nthe original number we return",
                "code": "class Solution:\n    def floorSqrt(self, n: int) -> int:\n        st, en = 1, n + 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if mid * mid == n:\n                return mid\n\n            if mid * mid < n:\n                st = mid + 1\n                ans = mid\n            else:\n                en = mid - 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 15,
        "question": "You are given 2 numbers n and m, the task is to find n\u221am (nth root of m). If the root is not integer then returns -1.\n\nExamples :\n\nInput: n = 2, m = 9\nOutput: 3\nExplanation: 32 = 9\n\nInput: n = 3, m = 9\nOutput: -1\nExplanation: 3rd root of 9 is not integer.\n\nInput: n = 1, m = 14\nOutput: 14\n\nConstraints:\n1 <= n <= 30\n1 <= m <= 10^9",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "N th root",
        "problem_link": "https://practice.geeksforgeeks.org/problems/find-nth-root-of-m5843/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/15_N_th_root.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just keep checking if number to the pow n starting from 1 to n and we get back the input number then return the i , if we exceed the number then we exit out of the loop",
                "code": "class Solution:\n    def nthRoot(self, n: int, m: int) -> int:\n        for i in range(1, m + 1):\n            if i**n == m:\n                return i\n\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "start a binary search with start\nas 1 and end as number just keep\nchecking if we number to the pow n and\nexceed then we move more towards left\nand if we are less then number we move\ntowards right increasing our search space\nif we see the number to the pow n of current mid equals\nthe original number we return",
                "code": "class Solution:\n    def nthRoot(self, n: int, m: int) -> int:\n        st, en = 1, m + 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if mid**n == m:\n                return mid\n\n            if mid**n < m:\n                st = mid + 1\n            else:\n                en = mid - 1\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 16,
        "question": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\n\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n\nConstraints:\n\n1 <= piles.length <= 10^4\npiles.length <= h <= 10^9\n1 <= piles[i] <= 10^9",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Koko Eating Bananas",
        "problem_link": "https://leetcode.com/problems/koko-eating-bananas",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/16_Koko_Eating_Bananas.py",
        "approaches": [
            {
                "tc": "T.C. - O(max(piles)*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "We start a loop from start index as 1 and end index as the max number of bananas in the pile,the first time we encounter a speed with which we are able to eat all the bananas within given time h we return the speed",
                "code": "import math\nfrom typing import List\n\n\nclass Solution:\n    def timeTakenToEat(self, piles: List[int], curr_speed: int) -> int:\n        time = 0\n\n        for pile in piles:\n            time += math.ceil(pile / curr_speed)\n\n        return time\n\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        for i in range(1, max(piles) + 1):\n            if self.timeTakenToEat(piles, i) <= h:\n                return i\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(max(piles))*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "We choose a starting min speed from 1 and max speed\nwith max bananas in the pile,with the current speed\nwe check if its possible to eat all bananas within\nthe given time,if time taken in more than h we move\nmore towards right increasing our speed otherwise\nwe move more towards the left if we can eat bannana\nwith the curr_speed with motive being to minimize\nour speed and still able to eat all bananas",
                "code": "import math\nfrom typing import List\n\n\nclass Solution:\n    def timeTakenToEat(self, piles: List[int], curr_speed: int) -> int:\n        time = 0\n\n        for pile in piles:\n            time += math.ceil(pile / curr_speed)\n\n        return time\n\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        st, en = 1, max(piles) + 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            t = self.timeTakenToEat(piles, mid)\n\n            if t <= h:\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 17,
        "question": "You are given an integer array bloomDay, an integer m and an integer k.\n\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\n\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\n\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\n\n\nExample 1:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\nOutput: 3\nExplanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\nExample 2:\n\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\nOutput: -1\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\nExample 3:\n\nInput: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\nOutput: 12\nExplanation: We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.\n\n\nConstraints:\n\nbloomDay.length == n\n1 <= n <= 10^5\n1 <= bloomDay[i] <= 10^9\n1 <= m <= 10^6\n1 <= k <= n",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Minimum Number of Days to Make m Bouquets",
        "problem_link": "https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/17_Minimum_Number_of_Days_to_Make_m_Bouquets.py",
        "approaches": [
            {
                "tc": "T.C. - O(max(bloomDay)*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we start with a day range starting from 1 and ending at max of days taken to bloom from given bloomDay array.We start a linear search, the first time we see that with our current day we are able to make m bouquet with k adjacent flowers we return the current day",
                "code": "from typing import List\n\n\nclass Solution:\n    def canMakeBouquet(self, bloomDay: List[int], currDay: int, m: int, k: int) -> bool:\n        tmp = k\n        c = 0\n\n        for i in range(len(bloomDay)):\n            if tmp == 0:\n                c += 1\n                tmp = k\n\n            if bloomDay[i] > currDay:\n                tmp = k\n\n            if bloomDay[i] <= currDay:\n                tmp -= 1\n\n        if tmp == 0:\n            c += 1\n\n        return c >= m\n\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        for i in range(1, max(bloomDay) + 1):\n            if self.canMakeBouquet(bloomDay, i, m, k):\n                return i\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(max(bloomDay))*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we start with a day range starting from\n1 and ending at max of days taken to bloom\nfrom given bloomDay array.We start a binary\nsearch, if we are able to make m bouquet with\nk adjacent flowers with the current day we move\nto the left with our motive being to minimze the\nnumber of days, otherwise we move to the right",
                "code": "from typing import List\n\n\nclass Solution:\n    def canMakeBouquet(self, bloomDay: List[int], currDay: int, m: int, k: int) -> bool:\n        tmp = k\n        c = 0\n\n        for i in range(len(bloomDay)):\n            if tmp == 0:\n                c += 1\n                tmp = k\n\n            if bloomDay[i] > currDay:\n                tmp = k\n\n            if bloomDay[i] <= currDay:\n                tmp -= 1\n\n        if tmp == 0:\n            c += 1\n\n        return c >= m\n\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        st, en = 1, max(bloomDay) + 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.canMakeBouquet(bloomDay, mid, m, k):\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 18,
        "question": "Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\n\nEach result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\n\nThe test cases are generated so that there will be an answer.\n\n\nExample 1:\n\nInput: nums = [1,2,5,9], threshold = 6\nOutput: 5\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1.\nIf the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).\nExample 2:\n\nInput: nums = [44,22,33,11,1], threshold = 5\nOutput: 44\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n1 <= nums[i] <= 10^6\nnums.length <= threshold <= 10^6",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find the Smallest Divisor Given a Threshold",
        "problem_link": "https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/18_Find_the_Smallest_Divisor_Given_a_Threshold.py",
        "approaches": [
            {
                "tc": "T.C. - O(max(nums)*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we start a linear serch with start index as 1 and end index as max number in nums first time we encounter a number which is able to sum up within the given threshold we return the number",
                "code": "import math\nfrom typing import List\n\n\nclass Solution:\n    def sumWithinThreshold(self, nums: List[int], threshold: int, divisor: int):\n        s = 0\n\n        for num in nums:\n            s += math.ceil(num / divisor)\n\n        return s <= threshold\n\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        for i in range(1, max(nums) + 1):\n            if self.sumWithinThreshold(nums, threshold, i):\n                return i\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(max(nums))*N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we start a binary search with start index\nand end index as 1 and max number among the\nthe given array,if we are able to find the\nsum that divides all number within threshold\nwe go left to minimize the number otherwise\nwe go to right",
                "code": "import math\nfrom typing import List\n\n\nclass Solution:\n    def sumWithinThreshold(self, nums: List[int], threshold: int, divisor: int):\n        s = 0\n\n        for num in nums:\n            s += math.ceil(num / divisor)\n\n        return s <= threshold\n\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        st, en = 1, max(nums) + 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.sumWithinThreshold(nums, threshold, mid):\n                en = mid - 1\n                ans = mid\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 19,
        "question": "A conveyor belt has packages that must be shipped from one port to another within days days.\n\nThe ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\n\n\nExample 1:\n\nInput: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\nOutput: 15\nExplanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\nExample 2:\n\nInput: weights = [3,2,2,4,1,4], days = 3\nOutput: 6\nExplanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\nExample 3:\n\nInput: weights = [1,2,3,1,1], days = 4\nOutput: 3\nExplanation:\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\nConstraints:\n\n1 <= days <= weights.length <= 5 * 10^4\n1 <= weights[i] <= 500",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Capacity To Ship Packages Within D Days",
        "problem_link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/19_Capacity_To_Ship_Packages_Within_D_Days.py",
        "approaches": [
            {
                "tc": "T.C. - O(sum(weights)*N)+O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "we start a linear search starting with starting weight as max in given weights array and ending weight as sum of all the weights,the first time we see we are able to ship within the given days d we return the current capacity",
                "code": "from typing import List\n\n\nclass Solution:\n    def canShip(self, weights: List[int], days: int, maxCap: int) -> bool:\n        daysTaken = 0\n        currCap = maxCap\n\n        for i in range(len(weights)):\n            if currCap == 0:\n                daysTaken += 1\n                currCap = maxCap\n\n            if weights[i] <= currCap:\n                currCap -= weights[i]\n            else:\n                daysTaken += 1\n                currCap = maxCap\n                currCap -= weights[i]\n\n        if currCap <= maxCap:\n            daysTaken += 1\n\n        return daysTaken <= days\n\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        for currCap in range(max(weights), sum(weights) + 1):\n            if self.canShip(weights, days, currCap):\n                return currCap\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(log(sum(weights))*N)+O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "We start a binary a binary search\nwith starting weight as max in given weights array and ending\nweight as sum of all the weights,we\ncheck if we are able to ship within\nthe given time d with the current weight\nmax capacity we move to left with the motive\nto minimize capacity,otherwise we go to right",
                "code": "from typing import List\n\n\nclass Solution:\n    def canShip(self, weights: List[int], days: int, maxCap: int) -> bool:\n        daysTaken = 0\n        currCap = maxCap\n\n        for i in range(len(weights)):\n            if currCap == 0:\n                daysTaken += 1\n                currCap = maxCap\n\n            if weights[i] <= currCap:\n                currCap -= weights[i]\n            else:\n                daysTaken += 1\n                currCap = maxCap\n                currCap -= weights[i]\n\n        if currCap <= maxCap:\n            daysTaken += 1\n\n        return daysTaken <= days\n\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        st, en = max(weights), sum(weights) + 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.canShip(weights, days, mid):\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 20,
        "question": "Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\n\nReturn the kth positive integer that is missing from this array.\n\n\nExample 1:\n\nInput: arr = [2,3,4,7,11], k = 5\nOutput: 9\nExplanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.\nExample 2:\n\nInput: arr = [1,2,3,4], k = 2\nOutput: 6\nExplanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.\n\n\nConstraints:\n\n1 <= arr.length <= 1000\n1 <= arr[i] <= 1000\n1 <= k <= 1000\narr[i] < arr[j] for 1 <= i < j <= arr.length",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Kth Missing Positive Number",
        "problem_link": "https://leetcode.com/problems/kth-missing-positive-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/20_Kth_Missing_Positive_Number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(max(nums)+k)",
                "sc": "S.C  - O(N)",
                "intuition": "convert the given array to a set declare 2 var count and i start a loop until count becomes k,keep checking if i is present in set or not otherwise increment count if i not present,atlast return i-1",
                "code": "from typing import List\n\n\nclass Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        count = 0\n        i = 1\n        seen_elem = set(arr)\n\n        while count < k:\n            if i not in seen_elem:\n                count += 1\n            i += 1\n\n        return i - 1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "One thing to note,is that since array is sorted and we are asked to find kth missing element, what we will do is find the count of the missing elemnt at every index,if at any index we see more missing element than given k we stop Formula for ith index missing count is nothing we just ask ourself how many number are there just previous of me if 6 ->then 5 numbers are before 6 (1,2,3,4,5) and then ask how an numbers are present in original array , then we can make a formula of missing count: (arr[i]-1-i),atlast we calculate how many missing are left to explore with k-curr_missing_count then we add the number(prev number just before the count exceeded k)+k-curr_missing_count",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_missing_count(self, idx: int, arr: list[int]) -> int:\n        return arr[idx] - 1 - idx\n\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        prev_idx = -1\n\n        for i in range(len(arr)):\n            if self.get_missing_count(i, arr) >= k:\n                break\n            else:\n                prev_idx = i\n\n        left_missing = k - self.get_missing_count(prev_idx, arr)\n        return arr[prev_idx] + left_missing",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "One thing to note,is that since array is sorted and we\nare asked to find kth missing element, what we will do is\nfind the count of the missing elemnt at every index,if at\nany index we see more missing element than given k we stop\nFormula for ith index missing count is nothing we just\nask ourself how many number are there just previous of me\nif 6 ->then 5 numbers are before 6 (1,2,3,4,5) and then ask\nhow an numbers are present in original array , then we can\nmake a formula of missing count: (arr[i]-1-i),atlast we calculate\nhow many missing are left to explore with k-curr_missing_count\nthen we add the number(prev number just before the count exceeded k)+k-curr_missing_count\nDo a binary search if at any index we see we are getting missing count\nmore then we move left otherwise we move right, we are doing a lower bound\nlinear search and biasing to the left direction,since we are biasing to left\ndirection and moving the right pointer to the left , then we will calculate\nour final answer based on the right index value",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_missing_count(self, idx: int, arr: list[int]) -> int:\n        return arr[idx] - 1 - idx\n\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        st, en = 0, len(arr) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            miss_count = self.get_missing_count(mid, arr)\n\n            if miss_count < k:\n                st = mid + 1\n            else:\n                en = mid - 1\n\n        left_missing = k - self.get_missing_count(en, arr)\n        return arr[en] + left_missing",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 21,
        "question": "Given an array of integers sorted in ascending order, and a target value, find the element\nin the array that has minimum difference with the target value.\n\nExample 1:\n\nInput: a[] = [2, 5, 10, 12, 15], target = 6\nOutput: 5\nExplanation: The difference between the target value '6' and '5' is the minimum.\nExample 2:\n\nInput: a[] = [2, 5, 10, 12, 15], target = 5\nOutput: 5\nExample 3:\n\nInput: a[] = [2, 5, 10, 12, 15], target = 8\nOutput: 10\nExample 4:\n\nInput: a[] = [2, 5, 10, 12, 15], target = 11\nOutput: 10\nExample 5:\n\nInput: a[] = [2, 5, 10, 12, 15], target = 20\nOutput: 15",
        "topic": "BinarySearch",
        "pattern": "floor/ceil",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find the minimum difference element in a sorted array",
        "problem_link": "NA",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/21_Find_the_minimum_difference_element_in_a_sorted_array.py",
        "approaches": [
            {
                "tc": "T.C. - O(log(N))+O(log(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Find the ceil and floor of the given target as the,\nmin diff will always be with them,also check if\ntarget is less than first element in array return the\nfirst element or if target is greater than last element\nin array return the last element",
                "code": "class Solution:\n    def floor(self, x: int, arr: list[int]):\n        st, en = 0, len(arr) - 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] <= x:\n                ans = arr[mid]\n                st = mid + 1\n            elif arr[mid] > x:\n                en = mid - 1\n\n        return ans\n\n    def ceil(self, x: int, arr: list[int]):\n        st, en = 0, len(arr) - 1\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if arr[mid] >= x:\n                ans = arr[mid]\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans\n\n    def find_min_diff(self, arr: list[int], target: int) -> int:\n        if target < arr[0]:\n            return arr[0]\n\n        if target > arr[-1]:\n            return arr[-1]\n\n        ceil = self.ceil(target, arr)\n        floor = self.floor(target, arr)\n\n        diff_ceil = abs(ceil - target)\n        diff_floor = abs(floor - target)\n\n        if diff_ceil < diff_floor:\n            return ceil\n        return floor\n\n\nif __name__ == \"__main__\":\n    # Test cases\n    solution = Solution()\n    arr1 = [2, 5, 10, 12, 15]\n    target1 = 6\n    expected1 = 5\n    assert (\n        solution.find_min_diff(arr1, target1) == expected1\n    ), f\"Test case 1 failed: expected {expected1}, got {solution.find_min_diff(arr1, target1)}\"\n\n    arr2 = [2, 5, 10, 12, 15]\n    target2 = 5\n    expected2 = 5\n    assert (\n        solution.find_min_diff(arr2, target2) == expected2\n    ), f\"Test case 2 failed: expected {expected2}, got {solution.find_min_diff(arr2, target2)}\"\n\n    arr3 = [2, 5, 10, 12, 15]\n    target3 = 8\n    expected3 = 10\n    assert (\n        solution.find_min_diff(arr3, target3) == expected3\n    ), f\"Test case 3 failed: expected {expected3}, got {solution.find_min_diff(arr3, target3)}\"\n\n    arr4 = [2, 5, 10, 12, 15]\n    target4 = 11\n    expected4 = 10\n    assert (\n        solution.find_min_diff(arr4, target4) == expected4\n    ), f\"Test case 4 failed: expected {expected4}, got {solution.find_min_diff(arr4, target4)}\"\n\n    arr5 = [2, 5, 10, 12, 15]\n    target5 = 20\n    expected5 = 15\n    assert (\n        solution.find_min_diff(arr5, target5) == expected5\n    ), f\"Test case 5 failed: expected {expected5}, got {solution.find_min_diff(arr5, target5)}\"\n\n    print(\"All test cases passed!\")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 22,
        "question": "You are given an array with unique elements of stalls[], which denote the position of a stall. You are also given an integer k\nwhich denotes the number of aggressive cows. Your task is to assign stalls to k cows such that\nthe minimum distance between any two of them is the maximum possible.\n\nExamples :\n\nInput: stalls[] = [1, 2, 4, 8, 9], k = 3\nOutput: 3\nExplanation: The first cow can be placed at stalls[0],\nthe second cow can be placed at stalls[2] and\nthe third cow can be placed at stalls[3].\nThe minimum distance between cows, in this case, is 3, which also is the largest among all possible ways.\n\nInput: stalls[] = [10, 1, 2, 7, 5], k = 3\nOutput: 4\nExplanation: The first cow can be placed at stalls[0],\nthe second cow can be placed at stalls[1] and\nthe third cow can be placed at stalls[4].\nThe minimum distance between cows, in this case, is 4, which also is the largest among all possible ways.\n\nInput: stalls[] = [2, 12, 11, 3, 26, 7], k = 5\nOutput: 1\nExplanation: Each cow can be placed in any of the stalls, as the no. of stalls are exactly equal to the number of cows.\nThe minimum distance between cows, in this case, is 1, which also is the largest among all possible ways.\n\nConstraints:\n2 <= stalls.size() <= 10^6\n0 <= stalls[i] <= 10^8\n2 <= k <= stalls.size()",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Aggressive Cows",
        "problem_link": "https://www.geeksforgeeks.org/problems/aggressive-cows/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/22_Aggressive_Cows.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*max(stalls))+O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "First sort the give array as sorting will make our placements deterministic otherwise we might place cows too close or too far, we may miss out on optimal placemnts Sorting gives a predictable structure \u2014 so we can place cows in a left-to-right greedy manner These are like points on a number line. If the stalls aren't sorted, there's no structure Placing the first cow at the first stall gives maximum room for future cows to be placed at a distance of at least minDistance Do a linear search and keep track of whether we can place the cows in an ans variable, as we want the max distance all the possiblities where we can place cows",
                "code": "class Solution:\n    def canPlaceCows(self, stalls: list[int], minDistance: int, cows: int) -> bool:\n        placedCows = 1\n        prevIdx = 0\n\n        for i in range(1, len(stalls)):\n            if stalls[i] - stalls[prevIdx] >= minDistance:\n                prevIdx = i\n                placedCows += 1\n\n            if placedCows >= cows:\n                return True\n\n        return False\n\n    def aggressiveCows(self, stalls: list[int], k: int) -> int:\n        stalls.sort()\n        st, en = 1, stalls[-1] - stalls[0] + 1\n        ans = -1\n\n        for i in range(st, en):\n            if self.canPlaceCows(stalls, i, k):\n                ans = max(ans, i)\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(max(stalls)))+O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "First sort the give array as sorting will make our placements deterministic\notherwise we might place cows too close or too far, we may miss out on optimal placemnts\nSorting gives a predictable structure \u2014 so we can place cows in a left-to-right greedy manner\nThese are like points on a number line. If the stalls aren't sorted, there's no structure\nPlacing the first cow at the first stall gives maximum room for future cows to be placed at a distance of at least minDistance\nDo a binary search and keep going right as we want the max possible distance possible if we are able to place all cows\notherwise go to left",
                "code": "class Solution:\n    def canPlaceCows(self, stalls: list[int], minDistance: int, cows: int) -> bool:\n        placedCows = 1\n        prevIdx = 0\n\n        for i in range(1, len(stalls)):\n            if stalls[i] - stalls[prevIdx] >= minDistance:\n                prevIdx = i\n                placedCows += 1\n\n            if placedCows >= cows:\n                return True\n\n        return False\n\n    def aggressiveCows(self, stalls: list[int], k: int) -> int:\n        stalls.sort()\n        st, en = 1, stalls[-1] - stalls[0]\n        ans = 0\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.canPlaceCows(stalls, mid, k):\n                ans = mid\n                st = mid + 1\n            else:\n                en = mid - 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 23,
        "question": "You are given an array arr[] of integers, where each element arr[i] represents the number of\npages in the ith book. You also have an integer k representing the number of students. The task is to allocate books to each student such that:\n\nEach student receives atleast one book.\nEach student is assigned a contiguous sequence of books.\nNo book is assigned to more than one student.\nThe objective is to minimize the maximum number of pages assigned to any student. In other words, out of all possible allocations, find the arrangement where the student who receives the most pages still has the smallest possible maximum.\n\nNote: Return -1 if a valid assignment is not possible, and allotment should be in contiguous order (see the explanation for better understanding).\n\nExamples:\n\nInput: arr[] = [12, 34, 67, 90], k = 2\nOutput: 113\nExplanation: Allocation can be done in following ways:\n[12] and [34, 67, 90] Maximum Pages = 191\n[12, 34] and [67, 90] Maximum Pages = 157\n[12, 34, 67] and [90] Maximum Pages = 113.\nTherefore, the minimum of these cases is 113, which is selected as the output.\n\nInput: arr[] = [15, 17, 20], k = 5\nOutput: -1\nExplanation: Allocation can not be done.\n\nInput: arr[] = [22, 23, 67], k = 1\nOutput: 112\n\nConstraints:\n1 <=  arr.size() <= 10^6\n1 <= arr[i] <= 10^3\n1 <= k <= 10^3",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Book Allocation",
        "problem_link": "https://www.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/23_Book_Allocation.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*sum(books))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a linear search and the first time you see that we are able to allocate books to fewer than k students we return the current min page value",
                "code": "class Solution:\n\n    def canAllocateBooks(self, books: list[int], minPage: int, k: int) -> int:\n        studentsAllocated = 0\n        currPages = minPage\n\n        for pages in books:\n            if pages <= currPages:\n                currPages -= pages\n            else:\n                studentsAllocated += 1\n                currPages = minPage\n                currPages -= pages\n\n        if currPages >= 0:\n            studentsAllocated += 1\n\n        return studentsAllocated <= k\n\n    def findPages(self, arr: list[int], k: int) -> int:\n        if len(arr) < k:\n            return -1\n\n        st, en = max(arr), sum(arr) + 1\n\n        for i in range(st, en):\n            if self.canAllocateBooks(arr, i, k):\n                return i\n\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(sum(books)))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a binary search if book allocation is possible\ngo as left as possible to get min page otherwise\ngo right",
                "code": "class Solution:\n\n    def canAllocateBooks(self, books: list[int], minPage: int, k: int) -> int:\n        studentsAllocated = 0\n        currPages = minPage\n\n        for pages in books:\n            if pages <= currPages:\n                currPages -= pages\n            else:\n                studentsAllocated += 1\n                currPages = minPage\n                currPages -= pages\n\n        if currPages >= 0:\n            studentsAllocated += 1\n\n        return studentsAllocated <= k\n\n    def findPages(self, arr: list[int], k: int) -> int:\n        if len(arr) < k:\n            return -1\n\n        st, en = max(arr), sum(arr)\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.canAllocateBooks(arr, mid, k):\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 24,
        "question": "Ram wants to paint his dog's home that has n boards with different lengths. The length of ith board is given\nby arr[i] where arr[] is an array of n integers. He hired k painters for this work and each painter takes 1 unit time to paint 1 unit of the board.\n\nReturn the minimum time to get this job done if all painters start together with the constraint that any painter\nwill only paint continuous boards, say boards numbered [2,3,4] or only board [1] or nothing but not boards [2,4,5].\n\nExamples:\n\nInput: arr[] = [5, 10, 30, 20, 15], k = 3\nOutput: 35\nExplanation: The most optimal way will be: Painter 1 allocation : [5,10],\nPainter 2 allocation : [30], Painter 3 allocation : [20,15], Job will be done when all painters finish i.e. at time = max(5+10, 30, 20+15) = 35\n\nInput: arr[] = [10, 20, 30, 40], k = 2\nOutput: 60\nExplanation: The most optimal way to paint: Painter 1 allocation : [10,20,30], Painter 2 allocation : [40], Job will be complete at time = 60\n\nInput: arr[] = [100, 200, 300, 400], k = 1\nOutput: 1000\nExplanation: There is only one painter, so the painter must paint all boards sequentially. The total time taken will be the sum of all board lengths, i.e., 100 + 200 + 300 + 400 = 1000.\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^5\n1 \u2264 k \u2264 10^5",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Painters Partition",
        "problem_link": "https://www.geeksforgeeks.org/problems/the-painters-partition-problem1535/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/24_Painters_Partition.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*sum(books))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a linear search and the first time you see that we are able to allocate books to fewer than k a painters we return the current min page value",
                "code": "class Solution:\n    def isPossible(self, maxTime: int, arr: list[int], k: int) -> bool:\n        paintersAllocated = 0\n        currBoardLength = maxTime\n\n        for val in arr:\n            if val <= currBoardLength:\n                currBoardLength -= val\n            else:\n                paintersAllocated += 1\n                currBoardLength = maxTime\n                currBoardLength -= val\n\n        if currBoardLength >= 0:\n            paintersAllocated += 1\n\n        return paintersAllocated <= k\n\n    def minTime(self, arr: list[int], k: int) -> int:\n        st, en = max(arr), sum(arr) + 1\n\n        for i in range(st, en):\n            if self.isPossible(i, arr, k):\n                return i\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(sum(books)))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a binary search if painter allocation is possible\ngo as left as possible to get min page otherwise\ngo right",
                "code": "class Solution:\n    def isPossible(self, maxTime: int, arr: list[int], k: int) -> bool:\n        paintersAllocated = 0\n        currBoardLength = maxTime\n\n        for val in arr:\n            if val <= currBoardLength:\n                currBoardLength -= val\n            else:\n                paintersAllocated += 1\n                currBoardLength = maxTime\n                currBoardLength -= val\n\n        if currBoardLength >= 0:\n            paintersAllocated += 1\n\n        return paintersAllocated <= k\n\n    def minTime(self, arr: list[int], k: int) -> int:\n        st, en = max(arr), sum(arr)\n        ans = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.isPossible(mid, arr, k):\n                ans = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 25,
        "question": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n\nReturn the minimized largest sum of the split.\n\nA subarray is a contiguous part of the array.\n\n\nExample 1:\n\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n\n\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 10^6\n1 <= k <= min(50, nums.length)",
        "topic": "BinarySearch",
        "pattern": "BS-on-Ans",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Split Largest Sum",
        "problem_link": "https://leetcode.com/problems/split-array-largest-sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/25_Split_Largest_Sum.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*sum(nums))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a linear search and the first time you see that we are able to split to fewer than k a splits we return the current min page value",
                "code": "from typing import List\n\n\nclass Solution:\n    def isPossible(self, maxSum, arr, k):\n        splitsAllocated = 0\n        currVal = maxSum\n\n        for val in arr:\n            if val <= currVal:\n                currVal -= val\n            else:\n                splitsAllocated += 1\n                currVal = maxSum\n                currVal -= val\n\n        if currVal >= 0:\n            splitsAllocated += 1\n\n        return splitsAllocated <= k\n\n    def splitArray(self, nums: List[int], k: int) -> int:\n        st, en = max(nums), sum(nums) + 1\n\n        for i in range(st, en):\n            if self.isPossible(i, nums, k):\n                return i\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(sum(books)))",
                "sc": "S.C  - O(1)",
                "intuition": "Do a binary search if split allocation is possible\ngo as left as possible to get min page otherwise\ngo right",
                "code": "from typing import List\n\n\nclass Solution:\n    def isPossible(self, maxSum, arr, k):\n        splitsAllocated = 0\n        currVal = maxSum\n\n        for val in arr:\n            if val <= currVal:\n                currVal -= val\n            else:\n                splitsAllocated += 1\n                currVal = maxSum\n                currVal -= val\n\n        if currVal >= 0:\n            splitsAllocated += 1\n\n        return splitsAllocated <= k\n\n    def splitArray(self, nums: List[int], k: int) -> int:\n        st, en = max(nums), sum(nums)\n        minSum = -1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if self.isPossible(mid, nums, k):\n                minSum = mid\n                en = mid - 1\n            else:\n                st = mid + 1\n\n        return minSum",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 26,
        "question": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-10^6 <= nums1[i], nums2[i] <= 10^6",
        "topic": "BinarySearch",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Median of 2 sorted array",
        "problem_link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/27_Median_of_2_sorted_array.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(M))",
                "sc": "S.C  - O(N)",
                "intuition": "Merge into a temporary array sort the temporary array find the median",
                "code": "from typing import List\n\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        tmp = sorted([*nums1, *nums2])\n\n        mid = len(tmp) // 2\n        if len(tmp) % 2 == 1:\n            return tmp[mid]\n        return (tmp[mid] + tmp[mid - 1]) / 2",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(M)",
                "sc": "S.C  - O(1)",
                "intuition": "Use the merge sort algo to find the indexes as in merge sort algo we process the array in sorted order,pre calcuate uptill which index to process for even keep track of last and seclast and for odd keep track of last only",
                "code": "from typing import List\n\n\nclass Solution:\n    def merge2SortedArray(\n        self, arr1: list[int], arr2: list[int], target: int\n    ) -> tuple[int, int]:\n        i, j = 0, 0\n        c = 0\n        last = -1\n        secLast = -1\n\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] <= arr2[j]:\n                secLast = last\n                last = arr1[i]\n                i += 1\n                c += 1\n            else:\n                secLast = last\n                last = arr2[j]\n                j += 1\n                c += 1\n\n            if c == target:\n                return last, secLast\n\n        while i < len(arr1):\n            secLast = last\n            last = arr1[i]\n            i += 1\n            c += 1\n\n            if c == target:\n                return last, secLast\n\n        while j < len(arr2):\n            secLast = last\n            last = arr2[j]\n            j += 1\n            c += 1\n\n            if c == target:\n                return last, secLast\n\n        return last, secLast\n\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        mid = (len(nums1) + len(nums2)) // 2\n        n = len(nums1) + len(nums2)\n        last, secLast = self.merge2SortedArray(nums1, nums2, mid + 1)\n\n        if n % 2 == 0:\n            return (last + secLast) / 2\n        return last",
                "type": "Better"
            },
            {
                "tc": "T.C. -",
                "sc": "S.C  -",
                "intuition": "",
                "code": "",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 27,
        "question": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\n\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\n\nReturn an array containing the index of the row, and the number of ones in it.\n\n\nExample 1:\n\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1].\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\nExample 3:\n\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n\nConstraints:\n\nm == mat.length\nn == mat[i].length\n1 <= m, n <= 100\nmat[i][j] is either 0 or 1.",
        "topic": "BinarySearch",
        "pattern": "Bs-on-2d-matrix",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Row with max number of 1s",
        "problem_link": "https://leetcode.com/problems/row-with-maximum-ones",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/29_Row_with_max_number_of_1s.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*M)",
                "sc": "S.C  - O(1)",
                "intuition": "Traverse the entire matrix and find the row with max ones , keeping track of max count of 1 till now for each row",
                "code": "from typing import List\n\n\nclass Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        curr_max_row_index = 0\n        curr_max_row_count = 0\n\n        for i in range(len(mat)):\n            c = 0\n            for j in range(len(mat[0])):\n                if mat[i][j] == 1:\n                    c += 1\n            if c > curr_max_row_count:\n                curr_max_row_index = i\n                curr_max_row_count = c\n\n        return [curr_max_row_index, curr_max_row_count]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(m))",
                "sc": "S.C  - O(1)",
                "intuition": "for each row find the last and first occurence\nof 1 and get the count of 1 in each row by doing\nsustraction of lastOccurence and firstOccurence\nand add 1, keep track of max ones in each row\nand max count",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstOccurence(self, nums: List[int], target: int) -> int:\n        ans = -1\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                en = mid - 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def lastOccurence(self, nums: List[int], target: int) -> int:\n        ans = -1\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                ans = mid\n                st = mid + 1\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return ans\n\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        curr_max_row_index = 0\n        curr_max_row_count = 0\n\n        for i in range(len(mat)):\n            first_occurence = self.firstOccurence(sorted(mat[i]), 1)\n            if first_occurence != -1:\n                last_occurence = self.lastOccurence(sorted(mat[i]), 1)\n                one_count = last_occurence - first_occurence + 1\n                if one_count > curr_max_row_count:\n                    curr_max_row_index = i\n                    curr_max_row_count = one_count\n\n        return [curr_max_row_index, curr_max_row_count]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 28,
        "question": "You are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\nGiven an integer target, return true if target is in matrix or false otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n\nExample 2:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-10^4 <= matrix[i][j], target <= 10^4",
        "topic": "BinarySearch",
        "pattern": "Bs-on-2d-matrix",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Search in 2d matrix i",
        "problem_link": "https://leetcode.com/problems/search-a-2d-matrix",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/30_Search_in_2d_matrix_i.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*M)",
                "sc": "S.C  - O(1)",
                "intuition": "Just do a linear search and check if target present",
                "code": "from typing import List\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == target:\n                    return True\n        return False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(log(M))",
                "sc": "S.C  - O(1)",
                "intuition": "Traverse throgh each row and if a target falls into the row range start a binary search",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                return True\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for i in range(len(matrix)):\n            if matrix[i][0] == target or matrix[i][-1] == target:\n                return True\n\n            if matrix[i][0] < target < matrix[i][-1]:\n                if self.search(matrix[i], target):\n                    return True\n\n        return False",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(log(N*M))",
                "sc": "S.C  - O(1)",
                "intuition": "Just image you have a flattened 1D array\ndo a binary search\nfor converting 1d co-ordinate to 2d Just\nuse the below\nFor row -> mid // n\nFor col -> mid % n",
                "code": "from typing import List\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        st, en = 0, (rows * cols) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n            ro = mid // cols\n            co = mid % cols\n\n            if matrix[ro][co] == target:\n                return True\n\n            if matrix[ro][co] > target:\n                en = mid - 1\n\n            else:\n                st = mid + 1\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 29,
        "question": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\n\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.\n\n\nExample 1:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\n\nExample 2:\nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\nOutput: false\n\n\nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= n, m <= 300\n-10^9 <= matrix[i][j] <= 10^9\nAll the integers in each row are sorted in ascending order.\nAll the integers in each column are sorted in ascending order.\n-10^9 <= target <= 10^9",
        "topic": "BinarySearch",
        "pattern": "Bs-on-2d-matrix",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Search in 2d matrix ii",
        "problem_link": "https://leetcode.com/problems/search-a-2d-matrix-ii",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/4_Binary_Search/31_Search_in_2d_matrix_ii.py",
        "approaches": [
            {
                "tc": "T.C. - O(N*M)",
                "sc": "S.C  - O(1)",
                "intuition": "Just do a linear search and check if target present",
                "code": "from typing import List\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == target:\n                    return True\n        return False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N*log(M))",
                "sc": "S.C  - O(1)",
                "intuition": "For each row do binary search to check if target present",
                "code": "from typing import List\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        st, en = 0, len(nums) - 1\n\n        while st <= en:\n            mid = st + (en - st) // 2\n\n            if nums[mid] == target:\n                return True\n\n            elif nums[mid] < target:\n                st = mid + 1\n\n            elif nums[mid] > target:\n                en = mid - 1\n\n        return False\n\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for i in range(len(matrix)):\n            if self.search(matrix[i], target):\n                return True\n        return False",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N+M)",
                "sc": "S.C  - O(1)",
                "intuition": "Start from either bottom left or top right\nbased on the current value check which direction\nto go down or towards left,if far than target\nincrease column otherwise decrease row",
                "code": "from typing import List\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ro, co = 0, len(matrix[0]) - 1\n\n        while co >= 0 and ro < len(matrix):\n            if matrix[ro][co] == target:\n                return True\n\n            if matrix[ro][co] > target:\n                co -= 1\n            else:\n                ro += 1\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "Given an array of integer arr. Your task is to construct the linked list from arr & return the head of the linked list.\n\nExamples:\n\nInput: arr = [1, 2, 3, 4, 5]\nOutput: LinkedList: 1->2->3->4->5\nExplanation: Linked list for the given array will be\n\nInput: arr = [2, 4, 6, 7, 5, 1, 0]\nOutput: LinkedList: 2->4->6->7->5->1->0\nExplanation: Linked list for the given array will be\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(n)\n\nConstraints:\n1 <= arr.size() <= 10^6\n1 <= arr[i] <= 10^6",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Array to Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/introduction-to-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/1_Array_to_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "initialize two vars head and curr\nhead will be returned as head of final linked list\ncreate a copy of the head in a curr var which will be used\nto assign the next node as we iterate over the array\nTraverse through the array and keep making the curr as next node\nto curr",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def constructLL(self, arr: list[int]) -> Node:\n        head: Node = Node(-1)\n        curr: Node = head\n\n        for num in arr:\n            curr.next = Node(num)\n            curr = curr.next\n\n        return head.next",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given the head of a Singly Linked List and a value x, insert that value x at the end of the LinkedList and return the modified Linked List.\n\nExamples :\n\nInput: LinkedList: 1->2->3->4->5 , x = 6\nOutput: 1->2->3->4->5->6\nExplanation:\n\nWe can see that 6 is inserted at the end of the linkedlist.\nInput: LinkedList: 5->4 , x = 1\nOutput: 5->4->1\nExplanation:\n\nWe can see that 1 is inserted at the end of the linkedlist.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(1)\n\nConstraints:\n0 <= number of nodes <= 10^5\n1 <= node->data , x <= 10^3",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Linked List Insertion At End",
        "problem_link": "https://www.geeksforgeeks.org/problems/linked-list-insertion-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/2_Linked_List_Insertion_At_End.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just keep traversing the link list\nand stop just at the last nodes reference\nnow we have last nodes reference and must\nmake the last node next point to the new\ncreated node",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def insertAtEnd(self, head: Node, x: int) -> Node:\n        if head is None:\n            return Node(x)\n\n        ptr = head\n\n        while ptr.next:\n            ptr = ptr.next\n\n        ptr.next = Node(x)\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "There is a singly-linked list head and we want to delete a node node in it.\n\nYou are given the node to be deleted node. You will not be given access to the first node of head.\n\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\nThe value of the given node should not exist in the linked list.\nThe number of nodes in the linked list should decrease by one.\nAll the values before node should be in the same order.\nAll the values after node should be in the same order.\nCustom testing:\n\nFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\nWe will build the linked list and pass the node to your function.\nThe output will be the entire list after calling your function.\n\n\nExample 1:\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\nExample 2:\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\nConstraints:\n\nThe number of the nodes in the given list is in the range [2, 1000].\n-1000 <= Node.val <= 1000\nThe value of each node in the list is unique.\nThe node to be deleted is in the list and is not a tail node.",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Delete Node in a Linked List",
        "problem_link": "https://leetcode.com/problems/delete-node-in-a-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/3_Delete_Node_in_a_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(1)",
                "intuition": "make the input node vals as its next nodes val\nmake the input node next point to next's next",
                "code": "class ListNode:\n    def __init__(self, x) -> None:\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def deleteNode(self, node: ListNode) -> None:\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given a singly linked list. The task is to find the length of the linked list, where length is defined as the number of nodes in the linked list.\n\nExamples :\n\nInput: LinkedList : 1->2->3->4->5\n\nOutput: 5\nExplanation: Count of nodes in the linked list is 5, which is its length.\nInput: LinkedList : 2->4->6->7->5->1->0\n\nOutput: 7\nExplanation: Count of nodes in the linked list is 7. Hence, the output is 7.\n\nExpected Time Complexity: O(n)\nExpected Auxilliary Space: O(1)\n\nConstraints:\n1 <= number of nodes <= 10^5\n1 <= node->data <= 10^3",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Count Linked List Nodes",
        "problem_link": "https://www.geeksforgeeks.org/problems/count-nodes-of-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/4_Count_Linked_List_Nodes.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep traversing the linked list\nand keep counting the nodes till\nyou reach a null node",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def getCount(self, head: Node) -> int:\n        ptr = head\n        c = 0\n\n        while ptr:\n            ptr = ptr.next\n            c += 1\n\n        return c",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Given a linked list of n nodes and a key, the task is to check if the key is present in the linked list or not.\n\nExample:\n\nInput: n = 4, key = 3\n1->2->3->4\nOutput: true\nExplanation: 3 is present in Linked List, so the function returns true.\n\nConstraint:\n1 <= n <= 10^5\n1 <= key <= 10^5",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Search in Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/search-in-linked-list-1664434326/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/5_Search_in_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Keep traversing the linked list\nif the curr node's val is the key\nval return True\nelse if we have reached the end of\nlinked list return False",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def searchKey(self, n: int, head: Node, key: int) -> bool:\n        ptr = head\n\n        while ptr:\n            if ptr.data == key:\n                return True\n            ptr = ptr.next\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Geek is learning data structures and is familiar with linked lists, but he's curious about how to access the previous element in a linked list in the same way that we access the next element. His teacher explains doubly linked lists to him.\n\nGiven an integer array arr of size n. Construct the doubly linked list from arr and return the head of it.\n\nExample 1:\nInput:\nn = 5\narr = [1,2,3,4,5]\nOutput:\n1 2 3 4 5\nExplanation: Linked list for the given array will be 1<->2<->3<->4<->5.\n\nExample 2:\nInput:\nn = 1\narr = [1]\nOutput:\n1\nExplanation: Linked list for the given array will be 1.\n\nConstraints:\n1 <= n <= 10^5\n1 <= arr[i] <= 100\n\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function constructDLL() which takes arr[] as input parameters and returns the head of the Linked List.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(n)",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Array to Doubly Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/introduction-to-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/6_Array_to_Doubly_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "initialize two vars head and curr\nhead will be returned as head of final linked list\ncreate a copy of the head in a curr var which will be used\nto assign the next node,prev node as we iterate over the array\nTraverse through the array and keep making the curr as next node\nto curr",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def constructDLL(self, arr: list[int]) -> Node:\n        if not arr:\n            return None\n\n        head = Node(arr[0])\n        curr = head\n\n        for num in arr[1:]:\n            new_node = Node(num)\n            new_node.prev = curr\n            curr.next = new_node\n            curr = curr.next\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "Given a doubly-linked list, a position p, and an integer x. The task is to add a new node with value x at the position just after pth node in the doubly linked list and return the head of the updated list.\n\nExamples:\n\nInput: LinkedList: 2<->4<->5, p = 2, x = 6\nOutput: 2<->4<->5<->6\nExplanation: p = 2, and x = 6. So, 6 is inserted after p, i.e, at position 2 (0-based indexing).\n\nInput: LinkedList: 1<->2<->3<->4, p = 0, x = 44\nOutput: 1<->44<->2<->3<->4\nExplanation: p = 0, and x = 44 . So, 44 is inserted after p, i.e, at position 0 (0-based indexing).\n\nConstraints:\n0 <= p < size of doubly linked list <= 10^6\n1 <= x <= 10^6",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Doubly linked list Insertion at given position",
        "problem_link": "https://www.geeksforgeeks.org/problems/insert-a-node-in-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/7_Doubly_linked_list_Insertion_at_given_position.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just stop at the given pth node\nthen insert the node after the pth node\nassign required links",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    # Function to insert a new node at given position in doubly linked list.\n    def addNode(self, head: Node, p: int, x: int) -> Node:\n        ptr = head\n\n        while p:\n            p -= 1\n            ptr = ptr.next\n\n        new_node = Node(x)\n        new_node.prev = ptr\n        new_node.next = ptr.next\n\n        if ptr.next:\n            ptr.next.prev = new_node\n\n        if ptr:\n            ptr.next = new_node\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given a Doubly Linked list and a position. The task is to delete a node from a given position (position starts from 1) in a doubly linked list and return the head of the doubly Linked list.\n\nExamples:\n\nInput: LinkedList = 1 <--> 3 <--> 4, x = 3\nOutput: 1 <--> 3\nExplanation: After deleting the node at position 3 (position starts from 1),the linked list will be now as 1 <--> 3.\n\nInput: LinkedList = 1 <--> 5 <--> 2 <--> 9, x = 1\nOutput: 5 <--> 2 <--> 9\nExplanation:\n\nConstraints:\n2 <= size of the linked list <= 10^6\n1 <= x <= size of the linked list\n1 <= node->data <= 10^4",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Delete in a Doubly Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/delete-node-in-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/8_Delete_in_a_Doubly_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Stop at the node to delete and save its reference to a variable\nthen delete the following links:\n+ make the delete nodes prev nodes next point to deleted nodes next\n+ make the delete nodes next nodes prev point to deleted nodes prev",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def delete_node(self, head: Node, x: int) -> Node:\n        if x == 1:\n            if head.next:\n                head.next.prev = None\n            return head.next\n\n        ptr = head\n        for _ in range(x - 1):\n            ptr = ptr.next\n\n        if ptr and ptr.prev:\n            ptr.prev.next = ptr.next\n\n        if ptr and ptr.next:\n            ptr.next.prev = ptr.prev\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]\n\nExample 3:\nInput: head = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the list is the range [0, 5000].\n-5000 <= Node.val <= 5000\n\nFollow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Reverse a Linked List",
        "problem_link": "https://leetcode.com/problems/reverse-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/8_Reverse_a_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "if you are at ith node make the curr nodes next point to prev node",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev",
                "type": "Optimal"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "if you are at ith node make the curr nodes\nnext point to prev node",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def rev_linked_list(curr: ListNode, prev: ListNode) -> Optional[ListNode]:\n            if curr is None:\n                return prev\n\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            return rev_linked_list(next_node, prev)\n\n        return rev_linked_list(head, None)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Given a doubly linked list. Your task is to reverse the doubly linked list and return its head.\n\nExamples:\n\nInput: LinkedList: 3 <-> 4 <-> 5\nOutput: 5 <-> 4 <-> 3\n\nInput: LinkedList: 75 <-> 122 <-> 59 <-> 196\nOutput: 196 <-> 59 <-> 122 <-> 75\n\nExpected Time Complexity: O(n).\nExpected Auxiliary Space: O(1).\n\nConstraints:\n1 <= number of nodes <= 10^6\n0 <= node->data <= 10^4",
        "topic": "LinkedList",
        "pattern": "Basic",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Reverse a Doubly Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/reverse-a-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/9_Reverse_a_Doubly_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "if you are at ith node make curr nodes\nnext to prev and curr nodes prev to next node",
                "code": "class DLLNode:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def reverseDLL(self, head: DLLNode) -> DLLNode:\n        prev = None\n        ptr = head\n\n        while ptr:\n            next_node = ptr.next\n            ptr.next = prev\n            prev = ptr\n            ptr.prev = next_node\n            ptr = next_node\n\n        return prev",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 11,
        "question": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\n\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n\nExample 2:\nInput: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [1, 100].\n1 <= Node.val <= 100",
        "topic": "LinkedList",
        "pattern": "FloydsAlgo",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find Middle of Linked List",
        "problem_link": "https://leetcode.com/problems/middle-of-the-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/10_Find_Middle_of_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N) ~ O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Find the length of linked list We know for finding the midpoint is length//2 again traverse the linked list till length//2 times then the node at which we stop the traversal is the midpoint",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        length = 0\n        ptr = head\n\n        while ptr:\n            length += 1\n            ptr = ptr.next\n\n        stop_pos = length // 2\n        ptr = head\n\n        while stop_pos:\n            stop_pos -= 1\n            ptr = ptr.next\n\n        return ptr",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "We are going to use the floyds hare and tortoise algorithm\nWe take slow and fast pointer where slow moves one step\nand fast pointer moves 2 steps. One thing to observe for\nodd and even length linked list\nFor Odd length fast pointer will reach the last node before overshooting\na->b->c->d->e->\ns\nf\n\nFor even length fast pointer will overshoot\na->b->c->d->\ns\nf",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 12,
        "question": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be\nreached again by continuously following the next pointer. Internally, pos is\nused to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\n\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 10^4].\n-10^5 <= Node.val <= 10^5\npos is -1 or a valid index in the linked-list.\n\nFollow up: Can you solve it using O(1) (i.e. constant) memory?",
        "topic": "LinkedList",
        "pattern": "FloydsAlgo",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Detect Cycle",
        "problem_link": "https://leetcode.com/problems/linked-list-cycle",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/11_Detect_Cycle.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Keep track of the nodes as you visit if there is a cycle then definitely we will visit a node twice",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        visited_nodes = set()\n        ptr = head\n\n        while ptr:\n            if ptr in visited_nodes:\n                return True\n            visited_nodes.add(ptr)\n            ptr = ptr.next\n\n        return False",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use floyds hare and tortoise algorithm\nif there is a cycle then hare and tortoise are bound to meet\nat each turn the hare becomes closer to the tortoise by 1 unit\nof distance",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                return True\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 13,
        "question": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously\nfollowing the next pointer. Internally, pos is used to denote the index of the node that\ntail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n\nDo not modify the linked list.\n\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\n\n\nConstraints:\n\nThe number of the nodes in the list is in the range [0, 10^4].\n-10^5 <= Node.val <= 10^5\npos is -1 or a valid index in the linked-list.\n\n\nFollow up: Can you solve it using O(1) (i.e. constant) memory?",
        "topic": "LinkedList",
        "pattern": "FloydsAlgo",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Linked List Cycle II",
        "problem_link": "https://leetcode.com/problems/linked-list-cycle-ii",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/12_Linked_List_Cycle_II.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Keep track of the nodes as you visit if we visit a node more than twice then that node is the start of cycle",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        visited_nodes = set()\n        ptr = head\n\n        while ptr:\n            if ptr in visited_nodes:\n                return ptr\n            visited_nodes.add(ptr)\n            ptr = ptr.next\n\n        return None",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use floyds hare and tortoise algo\nWait until they both meet\nafter they meet place hare at start\nand keep moving hare and tortoise one\nstep until the meet",
                "code": "from typing import Optional\n\n\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                break\n\n        if not fast or not fast.next:  # No cycle\n            return None\n\n        fast = head\n\n        while fast != slow:\n            slow = slow.next\n            fast = fast.next\n\n        return slow",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 14,
        "question": "Given the head of a linked list, determine whether the list contains a loop. If a loop is present,\nreturn the number of nodes in the loop, otherwise return 0.\n\nNote: 'c' is the position of the node which is the next pointer of the last node of the linkedlist. If c is 0, then there is no loop.\n\nExamples:\n\nInput: head: 1 \u2192 2 \u2192 3 \u2192 4 \u2192 5, c = 2\nOutput: 4\nExplanation: There exists a loop in the linked list and the length of the loop is 4.\n\nInput: head: 25 \u2192 14 \u2192 19 \u2192 33 \u2192 10 \u2192 21 \u2192 39 \u2192 90 \u2192 58 \u2192 45, c = 4\nOutput: 7\nExplanation: The loop is from 33 to 45. So length of loop is 33 \u2192 10 \u2192 21 \u2192 39 \u2192 90 \u2192 58 \u2192 45 = 7.\nThe number 33 is connected to the last node of the linkedlist to form the loop because according\nto the input the 4th node from the beginning(1 based indexing)\nwill be connected to the last node in the LinkedList.\n\nInput: head: 0 \u2192 1 \u2192 2 \u2192 3, c = 0\nOutput: 0\nExplanation: There is no loop.\n\nConstraints:\n1 \u2264 no. of nodes \u2264 10^6\n0 \u2264 node.data \u2264 10^6\n0 \u2264 c \u2264 n-1",
        "topic": "LinkedList",
        "pattern": "FloydsAlgo",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find length of Loop",
        "problem_link": "https://www.geeksforgeeks.org/problems/find-length-of-loop/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/13_Find_length_of_Loop.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Keep track of index at which we visit node moment we find a node we already visit return curr_idx-visited_nodes[ptr]",
                "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def countNodesInLoop(self, head: Node):\n        visited_nodes: dict[Node, int] = {}\n\n        ptr = head\n        curr_idx = 1\n\n        while ptr:\n            if ptr in visited_nodes:\n                return curr_idx - visited_nodes[ptr]\n\n            visited_nodes[ptr] = curr_idx\n            ptr = ptr.next\n            curr_idx += 1\n\n        return 0",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use hare and floyds algorithm\nafter two pointers meet\nwe move again until we reach\nslow node again [can be modified for fast too]",
                "code": "class Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def countNodesInLoop(self, head: Node):\n        slow, fast = head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                ptr = slow.next\n                c = 1\n                while ptr != slow:\n                    c += 1\n                    ptr = ptr.next\n                return c\n\n        if not fast or not fast.next:  # No cycle\n            return 0",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 15,
        "question": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\n\nExample 1:\nInput: head = [1,2,2,1]\nOutput: true\n\nExample 2:\nInput: head = [1,2]\nOutput: false\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [1, 105].\n0 <= Node.val <= 9\n\n\nFollow up: Could you do it in O(n) time and O(1) space?",
        "topic": "LinkedList",
        "pattern": "FloydsAlgo/Observation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Palindrome Linked List",
        "problem_link": "https://leetcode.com/problems/palindrome-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/14_Palindrome_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "Store the linked list in an array check if list is palindromic or not using 2 pointer technique",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        arr = []\n\n        ptr = head\n        while ptr:\n            arr.append(ptr.val)\n            ptr = ptr.next\n\n        i, j = 0, len(arr) - 1\n\n        while i < j:\n            if arr[i] != arr[j]:\n                return False\n\n            i += 1\n            j -= 1\n\n        return True",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Find the middle of linked list\nreverse from the mid to last and get last nodes head\nnow keep comparing last node and first node like this",
                "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        if fast and not fast.next:  # Handle odd length\n            slow = slow.next\n\n        return slow\n\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n\n    def checkPalindrome(self, a: ListNode, b: ListNode) -> bool:\n        while a and b:\n            if a.val != b.val:\n                return False\n\n            a = a.next\n            b = b.next\n\n        return True\n\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        mid = self.middleNode(head)\n        last_node_head = self.reverseList(mid)\n        return self.checkPalindrome(head, last_node_head)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 16,
        "question": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\n\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [1,3,5,2,4]\n\nExample 2:\nInput: head = [2,1,3,5,6,4,7]\nOutput: [2,3,6,7,1,5,4]\n\n\nConstraints:\nThe number of nodes in the linked list is in the range [0, 10^4].\n-10^6 <= Node.val <= 10^6",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Odd Even Linked List",
        "problem_link": "https://leetcode.com/problems/odd-even-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/15_Odd_Even_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "keep a new_head traverse the given head and put the odd index to the new_head first traverse again in the given head and put the even index to the new_head second",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        new_head = ListNode()\n        curr_new_head = new_head\n        ptr = head\n        idx = 1\n\n        while ptr:\n            if idx % 2 == 1:\n                curr_new_head.next = ListNode(ptr.val)\n                curr_new_head = curr_new_head.next\n            ptr = ptr.next\n            idx += 1\n\n        ptr = head\n        idx = 1\n\n        while ptr:\n            if idx % 2 == 0:\n                curr_new_head.next = ListNode(ptr.val)\n                curr_new_head = curr_new_head.next\n            ptr = ptr.next\n            idx += 1\n\n        return new_head.next",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "take 2 nodes odd,even and even head\n1  2  3  4  5\na->b->c->d->e->\no  e\no  eh\ngoal is to make the current odd index node point to next odd index node\nand make the current event index node point to next even index node",
                "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n\n        odd, even = head, head.next\n        even_head = even\n\n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n\n            even.next = even.next.next\n            even = even.next\n\n        odd.next = even_head\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 17,
        "question": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\nExample 1:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\nConstraints:\n\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n\n\nFollow up: Could you do this in one pass?",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Remove Nth Node From End of List",
        "problem_link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/16_Remove_Nth_Node_From_End_of_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Nth node from back is nothing but C-N from front where C is total length of list",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        c = 0\n        ptr = head\n\n        while ptr:\n            ptr = ptr.next\n            c += 1\n\n        ptr = head\n        node_idx_to_delete = c - n\n        if (node_idx_to_delete) == 0:\n            return head.next\n\n        while node_idx_to_delete != 1:\n            ptr = ptr.next\n            node_idx_to_delete -= 1\n\n        if ptr and ptr.next:\n            ptr.next = ptr.next.next\n\n        return head",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Goal is to first move a fast pointer by given n steps\nif fast becomes null then we were aksed to delete the first node\nThen move a slow and fast pointer simultenously until fast reaches last node\nYou will see at the end the slow pointer will automatically reach the node\njust before the to be deleted node because we\nmaintained an offset of n",
                "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        fast = head\n\n        for _ in range(n):\n            fast = fast.next\n\n        # was aksed to delete the head\n        if not fast:\n            return head.next\n\n        slow = head\n\n        # just stop when fast reach the last node\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 18,
        "question": "You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n\nThe middle node of a linked list of size n is the \u230an / 2\u230bth node from the start using 0-based indexing, where \u230ax\u230b denotes the largest integer less than or equal to x.\n\nFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\n\n\nExample 1:\nInput: head = [1,3,4,7,1,2,6]\nOutput: [1,3,4,1,2,6]\nExplanation:\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node.\n\nExample 2:\nInput: head = [1,2,3,4]\nOutput: [1,2,4]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n\nExample 3:\nInput: head = [2,1]\nOutput: [2]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [1, 10^5].\n1 <= Node.val <= 10^5",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Delete the Middle Node of a Linked List",
        "problem_link": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/17_Delete_the_Middle_Node_of_a_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Find length of linked list Just stop at the index before the midpoint then change links and delete mid node",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ptr = head\n        n = 0\n\n        while ptr:\n            ptr = ptr.next\n            n += 1\n\n        node_idx_to_stop = n // 2\n        if node_idx_to_stop == 0:\n            return head.next\n\n        ptr = head\n        while node_idx_to_stop != 1:\n            ptr = ptr.next\n            node_idx_to_stop -= 1\n\n        if ptr and ptr.next:\n            ptr.next = ptr.next.next\n\n        return head",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just do hares floyd and tortoies algos Intuition\njust keep track of also a slow prev as we want\nto stop just at the node before the deleted node",
                "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n        slow_prev = head\n        while fast and fast.next:\n            slow_prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if slow_prev and slow_prev.next:\n            slow_prev.next = slow_prev.next.next\n        else:\n            return None\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 19,
        "question": "Given the head of a linked list, return the list after sorting it in ascending order.\n\n\nExample 1:\n\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\nExample 2:\n\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\nExample 3:\n\nInput: head = []\nOutput: []\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 5 * 10^4].\n-10^5 <= Node.val <= 10^5\n\n\nFollow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?",
        "topic": "LinkedList",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Sort Linked List",
        "problem_link": "https://leetcode.com/problems/sort-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/18_Sort_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(1)",
                "intuition": "Use Merge Sort Algorithm\nPartitioning is done using the getMid function",
                "code": "class Solution:\n    def getMid(self, head):\n        prev_slow = None\n        slow, fast = head, head\n\n        while fast and fast.next:\n            prev_slow = slow\n            fast = fast.next.next\n            slow = slow.next\n\n        return prev_slow\n\n    def mergeSort(self, head):\n        # We are at single node\n        if head is None or head.next is None:\n            return head\n\n        # Cut links only 2 parts from head to mid\n        # mid+1 to tail\n        mid = self.getMid(head)\n        tmp = mid.next\n        mid.next = None\n        mid = tmp\n\n        left = self.mergeSort(head)\n        right = self.mergeSort(mid)\n        return self.merge(left, right)\n\n    def merge(self, l1, l2):\n        d = cp = ListNode()\n        while l1 and l2:\n            if l1.val <= l2.val:\n                d.next = l1\n                l1 = l1.next\n            else:\n                d.next = l2\n                l2 = l2.next\n\n            d = d.next\n\n        if l1:\n            d.next = l1\n        if l2:\n            d.next = l2\n\n        return cp.next\n\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        return self.mergeSort(head)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 20,
        "question": "Given the head of a linked list where nodes can contain values 0s, 1s, and 2s only. Your task is to rearrange the list so that all 0s appear at the beginning, followed by all 1s, and all 2s are placed at the end.\n\nExamples:\n\nInput: head = 1 \u2192 2 \u2192 2 \u2192 1 \u2192 2 \u2192 0 \u2192 2 \u2192 2\n\nOutput: 0 \u2192 1 \u2192 1 \u2192 2 \u2192 2 \u2192 2 \u2192 2 \u2192 2\n\nExplanation: All the 0s are segregated to the left end of the linked list, 2s to the right end of the list, and 1s in between.\nInput: head = 2 \u2192 2 \u2192 0 \u2192 1\n\nOutput: 0 \u2192 1 \u2192 2 \u2192 2\n\nExplanation: After arranging all the 0s, 1s and 2s in the given format, the output will be 0 \u2192 1 \u2192 2 \u2192 2.\nConstraints:\n1 \u2264 no. of nodes \u2264 10^6\n0 \u2264 node->data \u2264 2",
        "topic": "LinkedList",
        "pattern": "CountSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Sort a linked list of 0s, 1s and 2s",
        "problem_link": "https://www.geeksforgeeks.org/problems/given-a-linked-list-of-0s-1s-and-2s-sort-it/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/19_Sort_a_linked_list_of_0s,_1s_and_2s.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Use count sort",
                "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def segregate(self, head: Node) -> Node:\n        cnt0, cnt1, cnt2 = 0, 0, 0\n        ptr = head\n\n        while ptr:\n            if ptr.data == 0:\n                cnt0 += 1\n            if ptr.data == 1:\n                cnt1 += 1\n            if ptr.data == 2:\n                cnt2 += 1\n            ptr = ptr.next\n\n        ptr = head\n        for _ in range(cnt0):\n            ptr.data = 0\n            ptr = ptr.next\n\n        for _ in range(cnt1):\n            ptr.data = 1\n            ptr = ptr.next\n\n        for _ in range(cnt2):\n            ptr.data = 2\n            ptr = ptr.next\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 21,
        "question": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n\nFor example, the following two linked lists begin to intersect at node c1:\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\nNote that the linked lists must retain their original structure after the function returns.\n\nCustom Judge:\n\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\n\n\nExample 1:\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n\nExample 2:\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\nExample 3:\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\nConstraints:\n\nThe number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 10^4\n1 <= Node.val <= 10^5\n0 <= skipA <= m\n0 <= skipB <= n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.\n\nFollow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory?",
        "topic": "LinkedList",
        "pattern": "Observation",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Intersection of Two Linked Lists",
        "problem_link": "https://leetcode.com/problems/intersection-of-two-linked-lists",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/20_Intersection_of_Two_Linked_Lists.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "traverse one list and store all the visited_nodes traverse the other list and if their is an intersection we will find a common node",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(\n        self, headA: ListNode, headB: ListNode\n    ) -> Optional[ListNode]:\n        visited_nodes = set()\n\n        ptr = headA\n        while ptr:\n            visited_nodes.add(ptr)\n            ptr = ptr.next\n\n        ptr = headB\n        while ptr:\n            if ptr in visited_nodes:\n                return ptr\n            visited_nodes.add(ptr)\n            ptr = ptr.next\n\n        return None",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "find the length of both linked list\nfind the linked list which less length\ntravel the greater size linked list with the size diff steps",
                "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(\n        self, headA: ListNode, headB: ListNode\n    ) -> Optional[ListNode]:\n\n        n1, n2 = 0, 0\n        p1, p2 = headA, headB\n\n        while p1:\n            n1 += 1\n            p1 = p1.next\n\n        while p2:\n            n2 += 1\n            p2 = p2.next\n\n        diff = abs(n1 - n2)\n        p1, p2 = headA, headB\n\n        if n1 < n2:\n            # Move p2 diff placess ahead\n            while diff:\n                p2 = p2.next\n                diff -= 1\n        else:\n            while diff:\n                p1 = p1.next\n                diff -= 1\n\n        while p1 and p2:\n            if p1 == p2:\n                return p1\n\n            p1 = p1.next\n            p2 = p2.next\n\n        return None",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 22,
        "question": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Add Two Numbers",
        "problem_link": "https://leetcode.com/problems/add-two-numbers",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/21_Add_Two_Numbers.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just follow pure maths",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        ptr1, ptr2 = l1, l2\n\n        new_head = ListNode()\n        curr = new_head\n        carry = 0\n\n        while ptr1 and ptr2:\n            sm = ptr1.val + ptr2.val + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = ListNode(res)\n\n            curr = curr.next\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n\n        while ptr1:\n            sm = ptr1.val + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = ListNode(res)\n\n            curr = curr.next\n            ptr1 = ptr1.next\n\n        while ptr2:\n            sm = ptr2.val + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = ListNode(res)\n\n            curr = curr.next\n            ptr2 = ptr2.next\n\n        if carry > 0:\n            curr.next = ListNode(carry)\n\n        return new_head.next",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 23,
        "question": "You are given a linked list where each element in the list is a node and have an integer data. You need to add 1 to the number formed by concatinating all the list node numbers together and return the head of the modified linked list.\n\nNote: The head represents the first element of the given array.\n\nExamples :\n\nInput: LinkedList: 4->5->6\nOutput: 457\n\nExplanation: 4->5->6 represents 456 and when 1 is added it becomes 457.\nInput: LinkedList: 1->2->3\nOutput: 124\n\nExplanation:  1->2->3 represents 123 and when 1 is added it becomes 124.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(1)\n\nConstraints:\n1 <= len(list) <= 10^5\n0 <= list[i] <= 9",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Add 1 to a Linked List Number",
        "problem_link": "https://www.geeksforgeeks.org/problems/add-1-to-a-number-represented-as-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/22_Add_1_to_a_Linked_List_Number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Reverse linked list\nAdd 1\nReverse linked list and return head",
                "code": "from typing import Optional\n\n\nclass Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n\n\nclass Solution:\n    def reverseList(self, head: Optional[Node]) -> Optional[Node]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n\n    def addTwoNumbers(self, l1: Optional[Node], l2: Optional[Node]) -> Optional[Node]:\n        ptr1, ptr2 = l1, l2\n\n        new_head = Node(-1)\n        curr = new_head\n        carry = 0\n\n        while ptr1 and ptr2:\n            sm = ptr1.data + ptr2.data + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = Node(res)\n\n            curr = curr.next\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n\n        while ptr1:\n            sm = ptr1.data + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = Node(res)\n\n            curr = curr.next\n            ptr1 = ptr1.next\n\n        while ptr2:\n            sm = ptr2.data + carry\n            carry = sm // 10\n            res = sm % 10\n            curr.next = Node(res)\n\n            curr = curr.next\n            ptr2 = ptr2.next\n\n        if carry > 0:\n            curr.next = Node(carry)\n\n        return new_head.next\n\n    def addOne(self, head: Node):\n        head = self.addTwoNumbers(Node(1), self.reverseList(head))\n        return self.reverseList(head)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 24,
        "question": "You are given the head_ref of a doubly Linked List and a Key. Your task is to delete all occurrences of the given key if it is present and return the new DLL.\n\nExample1:\n\nInput:\n2<->2<->10<->8<->4<->2<->5<->2\n2\nOutput:\n10<->8<->4<->5\nExplanation:\nAll Occurences of 2 have been deleted.\n\nExample2:\n\nInput:\n9<->1<->3<->4<->5<->1<->8<->4\n9\nOutput:\n1<->3<->4<->5<->1<->8<->4\nExplanation:\nAll Occurences of 9 have been deleted.\nYour Task:\n\nComplete the function void deleteAllOccurOfX(struct Node** head_ref, int key), which takes the reference of the head pointer and an integer value key. Delete all occurrences of the key from the given DLL.\n\nExpected Time Complexity: O(N).\n\nExpected Auxiliary Space: O(1).\n\nConstraints:\n\n1<=Number of Nodes<=10^5\n\n0<=Node Value <=10^9",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Delete all occurrences of a given key in a doubly linked list",
        "problem_link": "https://www.geeksforgeeks.org/problems/delete-all-occurrences-of-a-given-key-in-a-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/23_Delete_all_occurrences_of_a_given_key_in_a_doubly_linked_list.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "First delete all starting nodes if have they have x\nthen keep deleting the nodes with x",
                "code": "class Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def deleteAllOccurOfX(self, head: Node, x: int) -> Node:\n        # Handle edge case where list is empty\n        if not head:\n            return head\n\n        # Traverse the list\n        ptr = head\n        while ptr.data == x:\n            ptr = ptr.next\n            head = ptr\n\n        while ptr:\n            savedNxt = ptr.next\n\n            # If the current node's data matches x\n            if ptr.data == x:\n                if ptr and ptr.prev:\n                    ptr.prev.next = ptr.next\n\n                if ptr and ptr.next:\n                    ptr.next.prev = ptr.prev\n\n            ptr = savedNxt\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 25,
        "question": "Given a sorted doubly linked list of positive distinct elements, the task is to find pairs in a doubly-linked list whose sum is equal to given value target.\n\n\nExample 1:\n\nInput:\n1 <-> 2 <-> 4 <-> 5 <-> 6 <-> 8 <-> 9\ntarget = 7\nOutput: (1, 6), (2,5)\nExplanation: We can see that there are two pairs\n(1, 6) and (2,5) with sum 7.\n\n\nExample 2:\n\nInput:\n1 <-> 5 <-> 6\ntarget = 6\nOutput: (1,5)\nExplanation: We can see that there is one pairs  (1, 5) with sum 6.\n\n\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function findPairsWithGivenSum() which takes head node of the doubly linked list and an integer target as input parameter and returns an array of pairs. If there is no such pair return empty array.\n\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 <= N <= 10^5\n1 <= target <= 10^5",
        "topic": "LinkedList",
        "pattern": "2Pointers",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find pairs with given sum in doubly linked list",
        "problem_link": "https://www.geeksforgeeks.org/problems/find-pairs-with-given-sum-in-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/24_Find_pairs_with_given_sum_in_doubly_linked_list.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Find tail\nuse 2 pointer approach to find pairs\nif we are far from target increase range\nif we are overshooting decrease range",
                "code": "from typing import Optional\nfrom typing import List\n\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def findPairsWithGivenSum(\n        self, target: int, head: Optional[\"Node\"]\n    ) -> List[List[int]]:\n        end = head\n\n        while end.next:\n            end = end.next\n\n        start = head\n        ans = []\n\n        while start.data < end.data:\n            if start.data + end.data > target:\n                end = end.prev\n            elif start.data + end.data < target:\n                start = start.next\n            else:\n                ans.append([start.data, end.data])\n                start = start.next\n                end = end.prev\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 26,
        "question": "Given a doubly linked list of n nodes sorted by values, the task is to remove duplicate nodes present in the linked list.\n\nExample 1:\n\nInput:\nn = 6\n1<->1<->1<->2<->3<->4\nOutput:\n1<->2<->3<->4\nExplanation:\nOnly the first occurance of node with value 1 is\nretained, rest nodes with value = 1 are deleted.\nExample 2:\n\nInput:\nn = 7\n1<->2<->2<->3<->3<->4<->4\nOutput:\n1<->2<->3<->4\nExplanation:\nOnly the first occurance of nodes with values 2,3 and 4 are\nretained, rest repeating nodes are deleted.\nYour Task:\nYou have to complete the method removeDuplicates() which takes 1 argument: the head of the linked list.  Your function should return a pointer to a linked list with no duplicate element.\n\nConstraint:\n1 <= n <= 10^5\nExpected Time Complexity: O(n)\nExpected Space Complexity: O(1)",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Remove Duplicates From Sorted Doubly LinkedList",
        "problem_link": "https://www.geeksforgeeks.org/problems/remove-duplicates-from-a-sorted-doubly-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/25_Remove_Duplicates_From_Sorted_Doubly_LinkedList.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "if prev nodes value is same as current then delete node",
                "code": "class Node:\n    def __init__(self, data):  # data -> value stored in node\n        self.data = data\n        self.next = None\n        self.prev = None\n\n\nclass Solution:\n    def removeDuplicates(self, head):\n        # Handle edge case where list is empty\n        if not head:\n            return head\n\n        ptr = head.next\n\n        while ptr:\n            savedNxt = ptr.next\n\n            # If the current node's data matches x\n            if ptr.data == ptr.prev.data:\n                if ptr and ptr.prev:\n                    ptr.prev.next = ptr.next\n\n                if ptr and ptr.next:\n                    ptr.next.prev = ptr.prev\n\n            ptr = savedNxt\n\n        return head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 27,
        "question": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\n\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\n\nReturn an array of the k parts.\n\n\nExample 1:\nInput: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].\n\nExample 2:\nInput: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "topic": "LinkedList",
        "pattern": "Task",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Split Linked List in K Parts",
        "problem_link": "https://leetcode.com/problems/split-linked-list-in-parts",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/26_Split_Linked_List_in_K_Parts.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(K*N)",
                "sc": "S.C  - O(1)",
                "intuition": "One thing we know if we have suppose n=10,k=5\nWe will have 5 partitions and each parition will\nhave atleast 2 nodes right, but suppose we have\nn=10,k=6 then we have 6 partitions and each partitions\nwill have atleast 1 node and we are left out with\n4 extra nodes, we can now assign these node to the\nleftmost partitions as possible",
                "code": "from typing import List, Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def splitListToParts(\n        self, head: Optional[ListNode], k: int\n    ) -> List[Optional[ListNode]]:\n        n = 0\n        ptr = head\n\n        while ptr:\n            ptr = ptr.next\n            n += 1\n\n        nodes_in_each_part = n // k\n        extra_nodes = n % k\n\n        ans = [None] * k\n        ptr = head\n\n        for i in range(k):\n            curr_head = ptr\n            total_nodes = nodes_in_each_part\n            ans[i] = curr_head\n            if extra_nodes:\n                total_nodes += 1\n                extra_nodes -= 1\n\n            # Keep moving current head until we reach the last node\n            while curr_head and total_nodes != 1:\n                curr_head = curr_head.next\n                total_nodes -= 1\n\n            # delete link and move the pointer to head of next partition start\n            if curr_head:\n                ptr = curr_head.next\n                curr_head.next = None\n            else:\n                curr_head = None\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 28,
        "question": "You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\n\nImplement the BrowserHistory class:\n\nBrowserHistory(string homepage) Initializes the object with the homepage of the browser.\nvoid visit(string url) Visits url from the current page. It clears up all the forward history.\nstring back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.\nstring forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.\n\n\nExample:\n\nInput:\n[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\nOutput:\n[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\n\nExplanation:\nBrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\nbrowserHistory.visit(\"google.com\");       // You are in \"leetcode.com\". Visit \"google.com\"\nbrowserHistory.visit(\"facebook.com\");     // You are in \"google.com\". Visit \"facebook.com\"\nbrowserHistory.visit(\"youtube.com\");      // You are in \"facebook.com\". Visit \"youtube.com\"\nbrowserHistory.back(1);                   // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.back(1);                   // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\nbrowserHistory.forward(1);                // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.visit(\"linkedin.com\");     // You are in \"facebook.com\". Visit \"linkedin.com\"\nbrowserHistory.forward(2);                // You are in \"linkedin.com\", you cannot move forward any steps.\nbrowserHistory.back(2);                   // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\nbrowserHistory.back(7);                   // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\n\n\nConstraints:\n\n1 <= homepage.length <= 20\n1 <= url.length <= 20\n1 <= steps <= 100\nhomepage and url consist of  '.' or lower case English letters.\nAt most 5000 calls will be made to visit, back, and forward.",
        "topic": "LinkedList",
        "pattern": "Design",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Design BrowserHistory",
        "problem_link": "https://leetcode.com/problems/design-browser-history",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/27_Design_BrowserHistory.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Just Keep track of current index Move back k steps on back command but dont go out of bounds Move forward k steps on forward command but dont go out of bounds",
                "code": "class Node:\n    def __init__(self, x: str) -> None:\n        self.prev: \"Node\" = None\n        self.next: \"Node\" = None\n        self.url: str = x\n\n\nclass BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.head = Node(homepage)\n\n    def visit(self, url: str) -> None:\n        if self.head.next:\n            self.head.next.prev = None\n            self.head.next = None\n\n        new_node = Node(url)\n        new_node.prev = self.head\n        self.head.next = new_node\n        self.head = self.head.next\n\n    def back(self, steps: int) -> str:\n        for i in range(steps):\n            if self.head.prev:\n                self.head = self.head.prev\n        return self.head.url\n\n    def forward(self, steps: int) -> str:\n        for i in range(steps):\n            if self.head.next:\n                self.head = self.head.next\n        return self.head.url",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(N)",
                "intuition": "Use a list to keep track of history",
                "code": "class BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.hist: list[str] = [homepage]\n        self.curr_index: int = 0\n\n    def visit(self, url: str) -> None:\n        hasNextElems = self.curr_index + 1 < len(self.hist)\n        if hasNextElems:\n            self.hist = self.hist[: self.curr_index + 1]\n        self.hist.append(url)\n\n    def back(self, steps: int) -> str:\n        index = max(0, self.curr_index - steps)\n        return self.hist[index]\n\n    def forward(self, steps: int) -> str:\n        index = min(len(self.hist) - 1, self.curr_index + steps)\n        return self.hist[index]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 29,
        "question": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid add(key) Inserts the value key into the HashSet.\nbool contains(key) Returns whether the value key exists in the HashSet or not.\nvoid remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.\n\n\nExample 1:\n\nInput\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\nOutput\n[null, null, null, true, false, null, true, null, false]\n\nExplanation\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\n\n\nConstraints:\n\n0 <= key <= 10^6\nAt most 10^4 calls will be made to add, remove, and contains.",
        "topic": "LinkedList",
        "pattern": "Design",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Design Hashset",
        "problem_link": "https://leetcode.com/problems/design-hashset",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/28_Design_Hashset.py",
        "approaches": [
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(10**6)",
                "intuition": "Just use a list of size 10**6 and mark everything to false if aksed to add just mark the index as True if aksed to remove mark the index as False if aksed to check if it contains a value check at that index is True or not",
                "code": "class MyHashSet:\n\n    def __init__(self):\n        self.set = [False] * ((10**6) + 1)\n\n    def add(self, key: int) -> None:\n        self.set[key] = True\n\n    def remove(self, key: int) -> None:\n        if self.set[key]:\n            self.set[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.set[key] == True",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(Dynamic_Size)",
                "intuition": "Use the concept of chaining on collision\nResize on increase in load factor",
                "code": "class Node:\n    def __init__(self, x: int) -> None:\n        self.data: int = x\n        self.next: Node = None\n\n\nclass MyHashSet:\n\n    def __init__(self):\n        self.set: list[Node] = [None] * 5\n        self.num_items = 0\n        self.load_factor = 0.75\n\n    def has_function(self, key: int, size: int) -> int:\n        return key % size\n\n    def _resize(self, set: list[Node]) -> list[Node]:\n        new_size = len(set) * 2\n        new_set: list[Node] = [None] * new_size\n\n        for node in set:\n            if node:\n                ptr = node\n                while ptr:\n                    new_set = self._add(ptr.data, new_set)\n                    ptr = ptr.next\n\n        return new_set\n\n    def _add(self, key: int, set: list[Node]) -> list[Node]:\n        idx = self.has_function(key, len(set))\n        head = set[idx]\n\n        if head is None:\n            set[idx] = Node(key)\n            return set\n\n        ptr = head\n        while ptr and ptr.next:\n            ptr = ptr.next\n\n        new_entry = Node(key)\n        ptr.next = new_entry\n\n        return set\n\n    def add(self, key: int) -> None:\n        curr_load_factor = self.num_items // len(self.set)\n\n        if curr_load_factor > self.load_factor:\n            self.set = self._resize(self.set)\n\n        if self.contains(key):\n            return\n\n        self.set = self._add(key, self.set)\n        self.num_items += 1\n\n    def remove(self, key: int) -> None:\n        if not self.contains(key):\n            return\n\n        idx = self.has_function(key, len(self.set))\n        head = self.set[idx]\n\n        if head.data == key:\n            self.set[idx] = head.next\n            self.num_items -= 1\n            return\n\n        ptr = head\n        while ptr:\n            if ptr.next.data == key:\n                ptr.next = ptr.next.next\n                self.num_items -= 1\n                return\n            ptr = ptr.next\n\n    def contains(self, key: int) -> bool:\n        idx = self.has_function(key, len(self.set))\n        head = self.set[idx]\n\n        if not head:\n            return False\n\n        ptr = head\n        while ptr:\n            if ptr.data == key:\n                return True\n            ptr = ptr.next\n\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 30,
        "question": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nMyHashMap() initializes the object with an empty map.\nvoid put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\nint get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nvoid remove(key) removes the key and its corresponding value if the map contains the mapping for the key.\n\n\nExample 1:\n\nInput\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\nOutput\n[null, null, null, 1, -1, null, 1, null, -1]\n\nExplanation\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n\n\nConstraints:\n\n0 <= key, value <= 10^6\nAt most 10^4 calls will be made to put, get, and remove.",
        "topic": "LinkedList",
        "pattern": "Design",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Design Hashmap",
        "problem_link": "https://leetcode.com/problems/design-hashmap",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/29_Design_Hashmap.py",
        "approaches": [
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(10**6)",
                "intuition": "Just use a list of size 10**6 and mark everything to -1 if aksed to add just at that index assign the value if aksed to remove at that index mark the value as -1 if aksed to check if at that index we have value or -1 (-1 signifies absence of value)",
                "code": "class MyHashMap:\n\n    def __init__(self):\n        self.map = [-1] * 10**6\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map[key]\n\n    def remove(self, key: int) -> None:\n        self.map[key] = -1",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(Dynamic_Size)",
                "intuition": "Use the concept of chaining on collision\nResize on increase in load factor",
                "code": "class Node:\n    def __init__(self, key: int, val: int) -> None:\n        self.key: int = key\n        self.val: int = val\n        self.next: Node = None\n\n\nclass MyHashMap:\n\n    def __init__(self):\n        self.map: list[Node] = [None] * 5\n        self.num_items = 0\n        self.load_factor = 0.75\n\n    def has_function(self, key: int, size: int) -> int:\n        return key % size\n\n    def _resize(self, map: list[Node]) -> list[Node]:\n        new_size = len(map) * 2\n        new_map: list[Node] = [None] * new_size\n\n        for node in map:\n            if node:\n                ptr = node\n                while ptr:\n                    new_map = self._put(ptr.key, ptr.val, new_map)\n                    ptr = ptr.next\n\n        return new_map\n\n    def _put(self, key: int, val: int, map: list[Node]) -> list[Node]:\n        idx = self.has_function(key, len(map))\n        head = map[idx]\n\n        if head is None:\n            map[idx] = Node(key, val)\n            return map\n\n        ptr = head\n        while ptr and ptr.next:\n            ptr = ptr.next\n\n        new_entry = Node(key, val)\n        ptr.next = new_entry\n\n        return map\n\n    def put(self, key: int, value: int) -> None:\n        curr_load_factor = self.num_items // len(self.map)\n\n        if curr_load_factor > self.load_factor:\n            self.map = self._resize(self.map)\n\n        contains, found_node = self._contains(key)\n        if contains and found_node:\n            found_node.val = value\n            return\n\n        self.map = self._put(key, value, self.map)\n\n    def get(self, key: int) -> int:\n        _, found_node = self._contains(key)\n        if found_node:\n            return found_node.val\n        return -1\n\n    def remove(self, key: int) -> None:\n        found, _ = self._contains(key)\n        if not found:\n            return\n\n        idx = self.has_function(key, len(self.map))\n        head = self.map[idx]\n\n        if head.key == key:\n            self.map[idx] = head.next\n            self.num_items -= 1\n            return\n\n        ptr = head\n        while ptr:\n            if ptr.next.key == key:\n                ptr.next = ptr.next.next\n                self.num_items -= 1\n                return\n            ptr = ptr.next\n\n    def _contains(self, key: int) -> tuple[bool, Node | None]:\n        idx = self.has_function(key, len(self.map))\n        head = self.map[idx]\n\n        if not head:\n            return False, None\n\n        ptr = head\n        while ptr:\n            if ptr.key == key:\n                return True, ptr\n            ptr = ptr.next\n\n        return False, None",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 31,
        "question": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.\n\n\nExample 1:\n\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\nConstraints:\n\n1 <= capacity <= 3000\n0 <= key <= 10^4\n0 <= value <= 10^5\nAt most 2 * 105 calls will be made to get and put.",
        "topic": "LinkedList",
        "pattern": "Design",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Design LRU Cache",
        "problem_link": "https://leetcode.com/problems/lru-cache",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/30_Design_LRU_Cache.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(N)",
                "intuition": "Maintain a list to store the LRU cache Store the recently used in front When getting,push the element to get to the front and when pushing,push the element to the front,if max capacity reached delete the end node,if key already exists replace the existing value",
                "code": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = []\n        self.max_cap = capacity\n\n    def get(self, key: int) -> int:\n        for i in range(len(self.cache)):\n            k, v = self.cache[i][0], self.cache[i][1]\n            if k == key:\n                self.cache = self.cache[:i] + self.cache[i + 1 :]\n                self.cache.insert(0, [k, v])\n                return v\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        # if key already exits\n        for i in range(len(self.cache)):\n            k = self.cache[i][0]\n            if k == key:\n                self.cache = self.cache[:i] + self.cache[i + 1 :]\n                break\n\n        # Evict if max cap reached\n        if len(self.cache) >= self.max_cap:\n            self.cache.pop()\n\n        self.cache.insert(0, [key, value])",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(1)",
                "sc": "S.C  - O(N)",
                "intuition": "We will use a combination of a doubly linked list (DLL) and a hash map (dictionary) to implement the LRU Cache.\nThe DLL will allow us to maintain the order of usage, while the hash map will provide O(1) access to the nodes.\nWe will have a head and a tail node to facilitate easy insertion and deletion of nodes.",
                "code": "class Node:\n    def __init__(self, k: int, v: int) -> None:\n        self.key = k  # The key of the node\n        self.val = v  # The value of the node\n        self.prev: Node | None = None  # Pointer to the previous node\n        self.next: Node | None = None  # Pointer to the next node\n\n\nclass DLL:\n    def __init__(self) -> None:\n        # Initialize the doubly linked list with a head and a tail node\n        self.head: Node = Node(-1, -1)  # Dummy head node\n        self.tail: Node = Node(-1, -1)  # Dummy tail node\n        self.head.next = self.tail  # Head points to tail\n        self.tail.prev = self.head  # Tail points back to head\n\n    def insert_after_head(self, node: \"Node|None\") -> None:\n        # Insert a node right after the head\n        if not node:\n            return\n\n        head_next = self.head.next  # Get the current first node after head\n\n        # Adjust pointers to insert the new node\n        head_next.prev = node\n        node.next = head_next\n        self.head.next = node\n        node.prev = self.head\n\n    def delete_node(self, node: \"Node|None\") -> None:\n        # Remove a node from the DLL\n        if not node:\n            return\n\n        next_node = node.next  # Get the next node\n        prev_node = node.prev  # Get the previous node\n\n        # Adjust pointers to bypass the node being deleted\n        next_node.prev = prev_node\n        prev_node.next = next_node\n\n        # Clear the pointers of the deleted node\n        node.next = None\n        node.prev = None\n\n    def get_tail(self) -> Node | None:\n        # Return the last node before the tail\n        return self.tail.prev\n\n    def get_head(self) -> Node | None:\n        # Return the first node after the head\n        return self.head.next\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.max_cap = capacity  # Maximum capacity of the cache\n        self.curr_cap = 0  # Current capacity of the cache\n        self.cache: dict[int, Node] = {}  # Hash map to store key-node pairs\n        self.dll = DLL()  # Initialize the doubly linked list\n\n    def make_recently_use(self, key: int):\n        # Move the accessed node to the front (after head) to mark it as recently used\n        node = self.cache[key]  # Get the node from the cache\n        self.dll.delete_node(node)  # Remove it from its current position\n        self.dll.insert_after_head(node)  # Insert it after the head\n\n    def get(self, key: int) -> int:\n        # Retrieve the value for the given key\n        if key not in self.cache:\n            return -1  # Return -1 if the key is not found\n\n        self.make_recently_use(key)  # Mark the node as recently used\n        return self.cache[key].val  # Return the value of the node\n\n    def put(self, key: int, value: int) -> None:\n        # Insert or update the value for the given key\n        if key in self.cache:\n            self.cache[key].val = value  # Update the value\n            self.make_recently_use(key)  # Mark it as recently used\n            return\n\n        if self.curr_cap >= self.max_cap:\n            # Evict the least recently used node if the cache is full\n            node = self.dll.get_tail()  # Get the last node before the tail\n            self.dll.delete_node(node)  # Remove it from the DLL\n            del self.cache[node.key]  # Remove it from the cache\n            self.curr_cap -= 1  # Decrement the current capacity\n\n        # Insert the new node\n        new_node = Node(key, value)  # Create a new node\n        self.cache[key] = new_node  # Add it to the cache\n        self.dll.insert_after_head(new_node)  # Insert it after the head\n        self.curr_cap += 1  # Increment the current capacity",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 32,
        "question": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n1->4->5,\n1->3->4,\n2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\nExample 2:\n\nInput: lists = []\nOutput: []\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n\nConstraints:\n\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-10^4 <= lists[i][j] <= 10^4\n\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 10^4.",
        "topic": "LinkedList",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Merge k Sorted Lists",
        "problem_link": "https://leetcode.com/problems/merge-k-sorted-lists",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/31_Merge_k_Sorted_Lists.py",
        "approaches": [
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(N)",
                "intuition": "Use merge sort algo",
                "code": "from typing import List, Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def merge2sortedList(self, l1: ListNode, l2: ListNode):\n        d = cp = ListNode()\n        while l1 and l2:\n            if l1.val <= l2.val:\n                d.next = l1\n                l1 = l1.next\n            else:\n                d.next = l2\n                l2 = l2.next\n\n            d = d.next\n\n        if l1:\n            d.next = l1\n        if l2:\n            d.next = l2\n\n        return cp.next\n\n    def mergeSort(self, lists: list[ListNode], st: int, en: int) -> ListNode:\n        if len(lists) == 0:\n            return None\n\n        if st == en:\n            return lists[st]\n\n        mid = (st + en) // 2\n\n        left = self.mergeSort(lists, st, mid)\n        right = self.mergeSort(lists, mid + 1, en)\n        return self.merge2sortedList(left, right)\n\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        return self.mergeSort(lists, 0, len(lists) - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 33,
        "question": "Given the head of a linked list, rotate the list to the right by k places.\n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\nExample 2:\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109",
        "topic": "LinkedList",
        "pattern": "Rotation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rotate List",
        "problem_link": "https://leetcode.com/problems/rotate-list",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/32_Rotate_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "mod k with length of linked list Keep rotating the linked list by one until you have rotated k times",
                "code": "from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def rotateByOne(self, head) -> Optional[ListNode]:\n        ptr = head\n        while ptr:\n            if ptr.next and ptr.next.next is None:\n                break\n            ptr = ptr.next\n\n        nxt = ptr.next\n        ptr.next = None\n        new_head = nxt\n        new_head.next = head\n\n        return new_head\n\n    def get_length(self, head) -> int:\n        n = 0\n        ptr = head\n\n        while ptr:\n            ptr = ptr.next\n            n += 1\n\n        return n\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n\n        k %= self.get_length(head)\n\n        while k:\n            head = self.rotateByOne(head)\n            k -= 1\n\n        return head",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "First find the length of linked list\nnow move at n-k pos and make the node at (n-k) pos next to None\nmake the tail point to head\nalso make the new head as the node just next to node at (n-k) pos",
                "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def getLen(self, head) -> tuple[ListNode, int]:\n        if not head:\n            return head, 0\n\n        n = 1\n        ptr = head\n\n        while ptr.next:\n            ptr = ptr.next\n            n += 1\n\n        return ptr, n\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        last_node, n = self.getLen(head)\n        if n == 0:\n            return head\n\n        k %= n\n        if k == 0:\n            return head\n\n        target_node_pos = n - k\n        c = 1\n        ptr = head\n\n        while ptr and c != target_node_pos:\n            ptr = ptr.next\n            c += 1\n\n        new_head = ptr.next\n        ptr.next = None\n        last_node.next = head\n\n        return new_head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 34,
        "question": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\n\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\nYour code will only be given the head of the original linked list.\n\n\nExample 1:\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nExample 2:\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\nExample 3:\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n\n\nConstraints:\n\n0 <= n <= 1000\n-10^4 <= Node.val <= 10^4\nNode.random is null or is pointing to some node in the linked list.",
        "topic": "LinkedList",
        "pattern": "Task/Observation",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Copy List With Random Pointer",
        "problem_link": "https://leetcode.com/problems/copy-list-with-random-pointer",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/33_Copy_List_With_Random_Pointer.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "First store the new node corresponding to the old node value in a hasmap now again iterate over the old node and assign the links for new node by doing lookups from the hasmap",
                "code": "from typing import Optional\n\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: \"Optional[Node]\") -> \"Optional[Node]\":\n        self.node_map: dict[Node, Node] = {None: None}\n        ptr = head\n\n        while ptr:\n            self.node_map[ptr] = Node(ptr.val)\n            ptr = ptr.next\n\n        ptr = head\n        while ptr:\n            new_node = self.node_map[ptr]\n\n            new_node.next = self.node_map[ptr.next]\n            new_node.random = self.node_map[ptr.random]\n\n            ptr = ptr.next\n\n        return self.node_map[head]",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)+O(N)+O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "First make the next links",
                "code": "from typing import Optional\n\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: \"Optional[Node]\") -> \"Optional[Node]\":\n        pass",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 35,
        "question": "Given a linked list containing n head nodes where every node in the linked list contains two pointers:\n(i) next points to the next node in the list.\n(ii) bottom pointer to a sub-linked list where the current node is the head.\nEach of the sub-linked lists nodes and the head nodes are sorted in ascending order based on their data.\nYour task is to flatten the linked list such that all the nodes appear in a single level while maintaining the sorted order.\n\nNote:\n1. \u2193 represents the bottom pointer and -> represents the next pointer.\n2. The flattened list will be printed using the bottom pointer instead of the next pointer.\n\nExamples:\n\nInput:\n\nOutput: 5-> 7-> 8-> 10 -> 19-> 20-> 22-> 28-> 30-> 35-> 40-> 45-> 50.\nExplanation:\nBottom pointer of 5 is pointing to 7.\nBottom pointer of 7 is pointing to 8.\nBottom pointer of 8 is pointing to 10 and so on.\n\nInput:\n\nOutput: 5-> 7-> 8-> 10-> 19-> 22-> 28-> 30-> 50\nExplanation:\nBottom pointer of 5 is pointing to 7.\nBottom pointer of 7 is pointing to 8.\nBottom pointer of 8 is pointing to 10 and so on.\n\nConstraints:\n0 <= n <= 100\n1 <= number of nodes in sub-linked list(mi) <= 50\n1 <= node->data <= 10^4",
        "topic": "LinkedList",
        "pattern": "MergeSort",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Flatten Linked List",
        "problem_link": "https://www.geeksforgeeks.org/problems/flattening-a-linked-list/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/34_Flatten_Linked_List.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N)",
                "intuition": "",
                "code": "class Node:\n    def __init__(self, d):\n        self.data = d\n        self.next = None\n        self.bottom = None\n\n\nclass Solution:\n    def merge_2_sorted_list(self, head1: Node, head2: Node) -> Node:\n        p1, p2 = head1, head2\n        tmp = Node(-1)\n        cp = tmp\n\n        while p1 and p2:\n            if p1.data <= p2.data:\n                tmp.bottom = p1\n                p1 = p1.bottom\n            else:\n                tmp.bottom = p2\n                p2 = p2.bottom\n\n            tmp = tmp.bottom\n\n        if p1:\n            tmp.bottom = p1\n\n        if p2:\n            tmp.bottom = p2\n\n        return cp.bottom\n\n    def flatten(self, root):\n        flattened_head = None\n        ptr = root\n\n        while ptr:\n            flattened_head = self.merge_2_sorted_list(flattened_head, ptr)\n            ptr = ptr.next\n\n        return flattened_head",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 36,
        "question": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\nConstraints:\n\nThe number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "topic": "LinkedList",
        "pattern": "Recursion/Observation",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Reverse Nodes in K Group",
        "problem_link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/5_Linked_List/35_Reverse_Nodes_in_K_Group.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(K)",
                "intuition": "first reach till k nodes keep a copy of current groups original head node then break link , take the last node in current group and make it point to None reverse the current linked list with original head node copy then make the original head node copy's next point to next K group reversed head Dont reverse if nodes are not equal to k or multiple of k",
                "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n\n        start_node = head\n        c = 1\n        ptr = start_node\n        while True:\n            if not ptr.next or c == k:\n                break\n            c += 1\n            ptr = ptr.next\n\n        # Break Link\n        nxtNode = None\n        if ptr:\n            nxtNode = ptr.next\n            ptr.next = None\n\n        # Reverse List\n        if c % k == 0:\n            rev_head = self.reverseList(start_node)\n\n            # Recursively reverse next group\n            start_node.next = self.reverseKGroup(nxtNode, k)\n\n            return rev_head\n\n        return start_node",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(1)",
                "intuition": "Dont use recursion",
                "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        return prev\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        pass",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "Given an positive integer n, print numbers from 1 to n without using loops.\n\nImplement the function printTillN() to print the numbers from 1 to n as space-separated integers.\n\nExamples\n\nInput: n = 5\nOutput: 1 2 3 4 5\nExplanation: We have to print numbers from 1 to 5.\n\nInput: n = 10\nOutput: 1 2 3 4 5 6 7 8 9 10\nExplanation: We have to print numbers from 1 to 10.\n\nConstraints:\n1 \u2264 n \u2264 1000",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Print 1 to N",
        "problem_link": "https://www.geeksforgeeks.org/problems/print-1-to-n-without-using-loops3621/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/1_Print_1_to_N.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use the IBH method to solve this problem\nlets assume that printTillN will print from 1 to N as hypothesis\nassume N-1 will print from 1 to N-1 then in the induction step\nwe can just print N at last",
                "code": "class Solution:\n    def printTillN(self, N: int) -> None:\n        # Base\n        if N == 0:\n            return\n\n        # Hypo\n        self.printTillN(N - 1)\n\n        # Induction\n        print(N, end=\" \")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Print numbers from N to 1 (space separated) without the help of loops.\n\nExample 1:\n\nInput:\nN = 10\nOutput: 10 9 8 7 6 5 4 3 2 1\nYour Task:\nThis is a function problem. You only need to complete\nthe function printNos() that takes N as parameter and prints number\nfrom N to 1 recursively. Don't print newline, it will be added by the driver code.\n\n\nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(N) (Recursive).\n\nConstraint\n1<=n<=1000",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Print N to 1",
        "problem_link": "https://www.geeksforgeeks.org/problems/print-n-to-1-without-loop/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/2_Print_N_to_1.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use the IBH method to solve this problem\nlets assume that printTillN will print from 1 to N as hypothesis\nwe can just print N first\nassume N-1 will print from 1 to N-1 then in the induction step",
                "code": "class Solution:\n    def printNos(self, n: int) -> None:\n        # Base\n        if n == 0:\n            return\n\n        # Induction\n        print(n, end=\" \")\n\n        # Hypo\n        self.printNos(n - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an integer n, your task is to compute the sum of all natural numbers from 1 to n (inclusive). If n is 0, the sum should be 0.\n\nExamples:\n\nInput: n = 3\nOutput: 6\nExplanation: For n = 3, the sum will be 6. 1 + 2 + 3 = 6.\n\nInput: n = 5\nOutput: 15\nExplanation: For n = 5, the sum will be 15. 1 + 2 + 3 + 4 + 5 = 15.\n\nConstraints:\n1 \u2264 n \u2264 10^4\n\nExpected Complexities\nTime Complexity: O(1)\nAuxiliary Space: O(1)",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Sum of Natural Numbers",
        "problem_link": "https://www.geeksforgeeks.org/problems/sum-of-series2811/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/3_Sum_of_Natural_Numbers.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use the IBH method to solve this problem\nAs hypothesis assume that given n findSum function\nwill calulcate the sum of 1 to n,first calulcate the\nsum of n-1 numbers then we can just add the current number\nwith the result of n-1 sum (induction)",
                "code": "class Solution:\n    def findSum(self, n: int) -> int:\n        # Base\n        if n == 0:\n            return 0\n\n        # Hypo\n        sum_till_prev_num = self.findSum(n - 1)\n\n        # Induction\n        return sum_till_prev_num + n",
                "type": "Better"
            }
        ]
    },
    {
        "id": 4,
        "question": "A number n is called a factorial number if it is the factorial of a positive integer. For example,\nthe first few factorial numbers are 1, 2, 6, 24, 120,\nGiven a number n, the task is to return the list/vector of the factorial numbers smaller than or equal to n.\n\nExamples:\n\nInput: n = 3\nOutput: 1 2\nExplanation: The first factorial number is 1 which is less than equal to n. The second number\nis 2 which is less than equal to n,but the third factorial number is 6 which is greater than n. So we print only 1 and 2.\n\nInput: n = 6\nOutput: 1 2 6\nExplanation: The first three factorial numbers are less than equal to n but the fourth factorial\nnumber 24 is greater than n. So we print only first three factorial numbers.\n\nConstraints:\n1<=n<=10^18",
        "topic": "Recursion",
        "pattern": "Recursive",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Factorials Less than or Equal to n",
        "problem_link": "https://www.geeksforgeeks.org/problems/find-all-factorial-numbers-less-than-or-equal-to-n3548/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/4_Factorials_Less_than_or_Equal_to_n.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)+O(N)",
                "sc": "S.C  - O(N) [recursion stack space] + O(N) [auxilairy space]",
                "intuition": "Use Pure Recursion",
                "code": "class Solution:\n    def factorialNumbers(self, n: int) -> list[int]:\n        def solve(idx: int, n: int) -> list[int]:\n            if idx > n:\n                return []\n\n            res = solve(idx + 1, n)\n\n            if idx < n:\n                res.append(idx)\n\n            return res\n\n        return solve(1, n)[::-1]",
                "type": "Better"
            },
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [auxilairy space]",
                "intuition": "Use Iterative method keeping track of the factorial",
                "code": "class Solution:\n    def factorialNumbers(self, n: int) -> list[int]:\n        ans = []\n\n        p = 1\n        for i in range(1, n + 1):\n            p *= i\n\n            if p > n:\n                break\n            else:\n                ans.append(p)\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Given a positive number n. Find the sum of all the digits of n.\n\nExamples:\n\nInput: n = 687\nOutput: 21\nExplanation: Sum of 687's digits: 6 + 8 + 7 = 21\n\nInput: n = 12\nOutput 3\nExplanation: Sum of 12's digits: 1 + 2 = 3\n\nConstraints:\n1 <= n <= 10^5",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Sum of Digits",
        "problem_link": "https://www.geeksforgeeks.org/problems/sum-of-digits1742/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/5_Sum_of_Digits.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use IBH method to solve the problem\nAssum given n it will return the sum of the\nall digits in n (hypothesis),then recursively\nfind the sum of x-1 digits (if number is 3 digit)\nthen find sum of 2 digits and then add the last digit\nto the sum of x-1 digits and return this (induction)",
                "code": "class Solution:\n    def sumOfDigits(self, n: int) -> int:\n        # Base\n        if n == 0:\n            return 0\n\n        # Hypo\n        s = self.sumOfDigits(n // 10)\n\n        # Induction\n        return s + n % 10",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "You are given an integer n. Your task is to reverse the digits, ensuring that the reversed number has no leading zeroes.\n\nExamples:\n\nInput: n = 122\nOutput: 221\nExplanation: By reversing the digits of number, number will change into 221.\n\nInput : n = 200\nOutput: 2\nExplanation: By reversing the digits of number, number will change into 2.\n\nInput : n = 12345\nOutput: 54321\nExplanation: By reversing the digits of number, number will change into 54321.\n\nConstraints:\n1 <= n <= 10^6",
        "topic": "Recursion",
        "pattern": "Recursion",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Reverse digits",
        "problem_link": "https://www.geeksforgeeks.org/problems/reverse-digit0316/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/6_Reverse_digits.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use Recursion and carry over the rev value in each recursive call",
                "code": "class Solution:\n    def reverseDigits(self, n: int) -> int:\n        def helper(rev: int, n: int) -> int:\n            if n == 0:\n                return rev\n\n            d = n % 10\n            return helper((rev * 10) + d, n // 10)\n\n        return helper(0, n)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "You are given an integer n. Your task is to determine whether it is a palindrome.\n\nA number is considered a palindrome if it reads the same backward as forward, like the string examples \"MADAM\" or \"MOM\".\n\nExamples:\n\nInput: n = 555\nOutput: true\nExplanation: The number 555 reads the same backward as forward, so it is a palindrome.\n\nInput: n = 123\nOutput: false\nExplanation: The number 123 reads differently backward (321), so it is not a palindrome.\n\nInput: n = 1221\nOutput: true\n\nConstraints:\n1 \u2264 n \u2264 109",
        "topic": "Recursion",
        "pattern": "Recursion",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check Palindrom number",
        "problem_link": "https://www.geeksforgeeks.org/problems/palindrome0746/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/7_Check_Palindrom_number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use Recursion and carry over the rev value in each recursive call",
                "code": "class Solution:\n    def reverseDigits(self, n: int) -> int:\n        def helper(rev: int, n: int) -> int:\n            if n == 0:\n                return rev\n\n            d = n % 10\n            return helper((rev * 10) + d, n // 10)\n\n        return helper(0, n)\n\n    def isPalindrome(self, n: int) -> bool:\n        return self.reverseDigits(n) == n",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given an array arr[], check whether it is sorted in non-decreasing order. Return true if it is sorted otherwise false.\n\nExamples:\n\nInput: arr[] = [10, 20, 30, 40, 50]\nOutput: true\nExplanation: The given array is sorted.\n\nInput: arr[] = [90, 80, 100, 70, 40, 30]\nOutput: false\nExplanation: The given array is not sorted.\n\nConstraints:\n1 \u2264 arr.size \u2264 10^6\n- 10^9 \u2264 arr[i] \u2264 10^9",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check if array is sorted",
        "problem_link": "https://www.geeksforgeeks.org/problems/check-if-an-array-is-sorted0701/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/8_Check_if_array_is_sorted.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use IBH method to solve this problem\nAssum that the given function will tell you whether array is sorted or not from\ni+1 to nth position (hypothesis),if array is sorted from i+1 position then we just\nneed to check if the i+1 element is greater than current element or not",
                "code": "class Solution:\n    def isSorted(self, arr: list[int]) -> bool:\n        def helper(idx: int, arr: list[int]) -> bool:\n            # Base Case\n            if idx == len(arr) - 1:\n                return True\n\n            # Hypo\n            isSorted = helper(idx + 1, arr)\n\n            # Induction\n            if not isSorted:\n                return False\n\n            if idx < len(arr) and arr[idx + 1] < arr[idx]:\n                return False\n\n            return True\n\n        return helper(0, arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\nGiven n, calculate F(n).\n\n\nExample 1:\n\nInput: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\nExample 2:\n\nInput: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\nExample 3:\n\nInput: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\nConstraints:\n0 <= n <= 30",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Fibonacci Number",
        "problem_link": "https://leetcode.com/problems/fibonacci-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/9_Fibonacci_Number.py",
        "approaches": [
            {
                "tc": "T.C. - O(N)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use IBH method to solve this problem\nAssume that the fib function gives us the\nthe nth fibonacci-number (hypothesis),then\nwe can easily find seclast and last number\nby recursion and in the induction step we\ncan return the summation of last and second\nlast fibonacci-number",
                "code": "class Solution:\n    def fib(self, n: int) -> int:\n        # Base\n        if n <= 1:\n            return n\n\n        # Hypo\n        last = self.fib(n - 1)\n        sec_last = self.fib(n - 2)\n\n        # Induction\n        return last + sec_last",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "You are given a stack St. You have to reverse the stack using recursion.\n\nExample 1:\n\nInput: St = [3,2,1,7,6]\nOutput: [6,7,1,2,3]\nExplanation: Input stack after reversing will look like the stack in the output.\nExample 2:\n\nInput: St = [4,3,9,6]\nOutput: [6,9,3,4]\nExplanation: Input stack after reversing will look like the stack in the output.\n\nConstraints:\n1 \u2264 stack.size \u2264 10^4\n0 \u2264 stack.element \u2264 10^3",
        "topic": "Recursion",
        "pattern": "IBH",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Reverse a Stack",
        "problem_link": "https://www.geeksforgeeks.org/problems/reverse-a-stack/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/10_Reverse_a_Stack.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(1)",
                "intuition": "Use IBH method to solve this problem\nAssume that in tht reversal function will\nreverse any given array(hypothesis),try reversing\nthe entire array except the last element then at the\ninduction step we just need to insert the last element\nto the front",
                "code": "class Solution:\n    def reverse(self, st: list[int]) -> list[int]:\n        # Base\n        if len(st) == 0:\n            return st\n\n        # Hypothesis\n        last_elem = st.pop(-1)\n        self.reverse(st)\n\n        # Induction\n        st.insert(0, last_elem)\n\n        return st",
                "type": "Brute"
            }
        ]
    },
    {
        "id": 11,
        "question": "Given an array of integers nums, sort the array in ascending order and return it.\n\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\n\n\nExample 1:\n\nInput: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\nExample 2:\n\nInput: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessarily unique.\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-5 * 10^4 <= nums[i] <= 5 * 10^4",
        "topic": "Recursion",
        "pattern": "IBH/DivideAndConquer",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Sort Array",
        "problem_link": "https://leetcode.com/problems/sort-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/6_Recursion/11_Sort_Array.py",
        "approaches": [
            {
                "tc": "T.C. - O(N^2)",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use IBH method Assume the array will get sorted from idx+1 post to end Just insert the element at its correct place, the current elment",
                "code": "from typing import List\nfrom bisect import bisect_right\n\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Base\n        if len(nums) == 0:\n            return nums\n\n        # Hypothesis\n        lastElem = nums.pop(-1)\n        self.sortArray(nums)\n\n        # Induction\n        idx = bisect_right(nums, lastElem)\n        nums.insert(idx, lastElem)\n        return nums",
                "type": "Brute"
            },
            {
                "tc": "T.C. - O(Nlog(N))",
                "sc": "S.C  - O(N) [recursion stack space]",
                "intuition": "Use Merge Sort [inplace]",
                "code": "from typing import List\n\n\nclass Solution:\n    def merge2sortedArray(self, lo: int, mid: int, hi: int, arr: list[int]) -> None:\n        i, j = lo, mid + 1\n\n        tmp = []\n        while i <= mid and j <= hi:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n\n        while j <= hi:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(lo, hi + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n    def merge_sort(self, lo: int, hi: int, arr: list[int]):\n        # Base\n        if lo >= hi:\n            return\n\n        mid = (lo + hi) // 2\n\n        # Hypotheis\n        # Sort Left arr\n        self.merge_sort(lo, mid, arr)\n        # Sort Right arr\n        self.merge_sort(mid + 1, hi, arr)\n\n        # Induction\n        self.merge2sortedArray(lo, mid, hi, arr)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.merge_sort(0, len(nums) - 1, nums)\n        return nums",
                "type": "Optimal"
            }
        ]
    }
]