[
    {
        "id": 1,
        "question": "Given an array arr, use selection sort to sort arr[] in increasing order.\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: Maintain sorted (in bold) and unsorted subarrays.\nSelect 1. Array becomes 1 4 3 9 7.\nSelect 3.  Array becomes 1 3 4 9 7.\nSelect 4. Array becomes 1 3 4 9 7.\nSelect 7. Array becomes 1 3 4 7 9.\nSelect 9. Array becomes 1 3 4 7 9.\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nInput: arr[] = [38, 31, 20, 14, 30]\nOutput: [14, 20, 30, 31, 38]\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^3\n1 \u2264 arr[i] \u2264 10^6",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Selection Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/selection-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/1_Selection_Sort.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "This is an unstable sorting algorithm but can be made stable to maintain relative\nordering of element but will increase time complexity.\nThis algorithms worst,best,avg time complexity is O(N^2)\nIn each iteration place the minimum/maximum most element to its correct place.\nFor example for ascending in 1st iteration place the most minimum to 0th index\n, next iteration 2nd minimum to 1st index like this.",
                "code": "class Solution:\n    def selectionSort(self, arr: list[int]):\n        for i in range(len(arr)):\n            min_idx = i\n            for j in range(i, len(arr)):\n                if arr[j] < arr[min_idx]:\n                    min_idx = j\n            arr[i], arr[min_idx] = arr[min_idx], arr[i]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given an array, arr[]. Sort the array using bubble sort algorithm.\n\nExamples :\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nInput: arr[] = [1, 2, 3, 4, 5]\nOutput: [1, 2, 3, 4, 5]\n\nExplanation: An array that is already sorted should remain unchanged after applying bubble sort.\n\nConstraints:\n1 <= arr.size() <= 10^3\n1 <= arr[i] <= 10^3",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Bubble Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/bubble-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/2_Bubble_Sort.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.This is a stable\nsorting algo.\nIn each iteration place the minimum/maximum most element to the end of\nthe array making swaps on the go.For example , for ascending order in\nfirst iteration the most maximum will be placed at last,then next iteration\n2nd maximum will be placed at 2nd last index like this.",
                "code": "class Solution:\n    # Function to sort the array using bubble sort algorithm.\n    def bubbleSort(self, arr: list[int]):\n        for i in range(\n            len(arr) - 1\n        ):  # since at last iteration last element will be at its correct place\n            did_swap = False\n            for j in range(0, len(arr) - i - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                    did_swap = True\n\n            if not did_swap:  # if array is sorted no swaps will take place\n                break",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "The task is to complete the insertsort() function which is used to implement Insertion Sort.\n\nExamples:\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: The sorted array will be [1, 3, 4, 7, 9].\n\nInput: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nExplanation: The sorted array will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\nInput: arr[] = [4, 1, 9]\nOutput: [1, 4, 9]\nExplanation: The sorted array will be [1, 4, 9].\n\nConstraints:\n1 <= arr.size() <= 1000\n1 <= arr[i] <= 1000",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Insertion Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/insertion-sort/0",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/3_Insertion_Sort.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.\nThis is a stable sorting algo.\nIn this algorithm in every pass we try to place the\nnumber at its correct position,from the current position\nin which the number is in we try to check with its left\nneighbours whether its lesser than its left neighbour,\nif its lesser than its left neighbour we swap places\nwe keep doing it unitl its placed in its correct place",
                "code": "class Solution:\n    def insertionSort(self, arr: list[int]):\n        # we start from 1 index as 1 does not have any left neighbours\n        for i in range(1, len(arr)):\n            j = i\n            while j > 0 and arr[j] < arr[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                j -= 1\n\n        return arr",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given an array of integers nums, sort the array in ascending order and return it.\n\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the\nsmallest space complexity possible.\n\nExample 1:\n\nInput: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions\nof other numbers are changed (for example, 1 and 5).\n\nExample 2:\n\nInput: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique.\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-5 * 10^4 <= nums[i] <= 5 * 10^4",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Merge Sort",
        "problem_link": "https://leetcode.com/problems/sort-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/4_Merge_Sort.py",
        "approaches": [
            {
                "tc": "O(Nlog(N))",
                "sc": "O(N)+O(N)",
                "intuition": "This algorithms worst,avg,best time complexity is O(Nlog(N)).\nThis also use a recursion stack space of O(N) and O(N) auxiliary space to\nstore array elements.\nThis is a stable sorting algo.\nWe follow a divide and conquer strategy we keep divind the\narray into 2 equal halves until they cannot be divided or we are left with array with one element\nand then we keep on merging the two halves until no subarrays are left.",
                "code": "from typing import List\n\n\nclass Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> None:\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> None:\n        if l >= h:  # array has 1 element\n            return\n\n        mid = (l + h) // 2\n\n        self.mergeSort(l, mid, arr)\n        self.mergeSort(mid + 1, h, arr)\n        self.merge(l, mid, h, arr)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(0, len(nums) - 1, nums)\n        return nums",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Implement Quick Sort, a Divide and Conquer algorithm, to sort an array, arr[] in ascending order. Given an array, arr[], with starting index low and ending index high, complete the functions partition() and quickSort(). Use the last element as the pivot so that all elements less than or equal to the pivot come before it, and elements greater than the pivot follow it.\n\nNote: The low and high are inclusive.\n\nExamples:\n\nInput: arr[] = [4, 1, 3, 9, 7]\nOutput: [1, 3, 4, 7, 9]\nExplanation: After sorting, all elements are arranged in ascending order.\n\nInput: arr[] = [2, 1, 6, 10, 4, 1, 3, 9, 7]\nOutput: [1, 1, 2, 3, 4, 6, 7, 9, 10]\nExplanation: Duplicate elements (1) are retained in sorted order.\n\nInput: arr[] = [5, 5, 5, 5]\nOutput: [5, 5, 5, 5]\nExplanation: All elements are identical, so the array remains unchanged.\n\nConstraints:\n1 <= arr.size() <= 10^5\n1 <= arr[i] <= 10^5",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Quick Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/quick-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/5_Quick_Sort.py",
        "approaches": [
            {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "This algorithms avg,best time complexity is O(Nlog(N)) and worst case\ntime complexity is O(N^2).\nThis is a unstable sorting algo.\nWe pick a pivot,pivot can be first,last element.we try to place all\nthe elements smaller to pivot to its left and bigger to right,\nnow this two partions (left and right) created are sorted recursively with the same logic.\ntake 2 pointers i and j i points to start and j points to end given in the function call.\nfor finding pivot find the first smallest from right anf first biggest from left.\nkeep doing this till i<j and swap after every finding of these two position.\natlast place pivot at its correct place swap pivot with j and return j.",
                "code": "class Solution:\n    # Function to sort a list using quick sort algorithm.\n    def quickSort(self, arr: list[int], low: int, high: int):\n        if low >= high:  # return if has only one element\n            return\n\n        pivot = self.partitionv2(arr, low, high)\n        self.quickSort(arr, low, pivot - 1)\n        self.quickSort(arr, pivot + 1, high)\n\n    def partitionv2(self, arr: list[int], low: int, high: int) -> int:  # algorithmic\n        i, j = low, high\n        pivot = arr[low]\n\n        while i < j:\n            # bigger from left\n            while i < high and arr[i] <= pivot:\n                i += 1\n\n            # smaller from right\n            while j > low and arr[j] > pivot:\n                j -= 1\n\n            # swap only of i<j\n            if i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n\n        # place the pivot in its correct place\n        arr[low], arr[j] = arr[j], arr[low]\n\n        return j\n\n    # Naive way of partitioning [last as pivot]\n    def partitionv1_0(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[high]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low, high):  # ignore the last element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)\n\n    # Naive way of partitioning [first as pivot]\n    def partitionv1_1(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[low]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low + 1, high + 1):  # ignore the first element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given a string arr consisting of lowercase english letters, arrange all its letters in lexicographical order using Counting Sort.\n\nExample 1:\n\nInput:\nN = 5\nS = \"edsab\"\nOutput:\nabdes\nExplanation:\nIn lexicographical order, string will be\nabdes.\nExample 2:\n\nInput:\nN = 13\nS = \"geeksforgeeks\"\nOutput:\neeeefggkkorss\nExplanation:\nIn lexicographical order, string will be\neeeefggkkorss.\nYour Task:\nThis is a function problem. You only need to complete the function countSort() that takes string arr as a parameter and returns the sorted string. The printing is done by the driver code.\n\nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(N).\n\nConstraints:\n1 \u2264 N \u2264 10^5",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Count Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/counting-sort/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/6_Count_Sort.py",
        "approaches": [
            {
                "tc": "O(N+26)",
                "sc": "O(26)+O(N)",
                "intuition": "This is a non comparison basesd algo\nThis algo work best when all input elements are within a given range k.\nThis algorithms avg,best,worst time complexity is O(Nlog(N)) and worst case\nThis is a unstable sorting algo.\ncreate a count array of size either max element+1 or given k+1\nstore the frequence of each element in the count array\nthen replace everything in the count array with prefix sum\nsuch that count[i]=count[i]+count[i-1]\nloop from back of the input array suppose we enconter number 2\nin our input array then we go to the index 2 in the count array\nthe value at that index 2 will gives us where to place 2 in the final output array\ndecrement count of 2 in the count array\nplace the 2 in that index postion got from count array",
                "code": "class Solution:\n    def countSort(self, arr: list[str]):\n        count_arr = [0] * 27\n\n        # calculate frequency\n        for char in arr:\n            count_arr[ord(char) - 97] += 1\n\n        # calculate prefix sum\n        for i in range(1, len(count_arr)):\n            count_arr[i] = count_arr[i] + count_arr[i - 1]\n\n        # build output array\n        out = [\"\"] * len(arr)\n        for i in range(len(arr) - 1, -1, -1):\n            num = ord(arr[i]) - 97\n            count_arr[num] -= 1\n            out[count_arr[num]] = arr[i]\n\n        return \"\".join(out)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "You are given an integer array nums containing n + 1 integers where each integer is in the\nrange [1, n]. There is only one duplicate number in the array, but it could be repeated more than once.\nYou must solve the problem without modifying the input array and using O(1) extra space.\n\n\nInput: nums = [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\nInput: nums = [1, 3, 4, 2]\nOutput: [1, 2, 3, 4]\n\nInput: nums = [2, 1, 3]\nOutput: [1, 2, 3]",
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Cyclic Sort",
        "problem_link": "NA",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/7_Cyclic_Sort.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Check whether current number is at its correct index\nThis algorithm works for small ranged numbers\nmust be in range of 1 to N or 0 to N\nFor one based indexing , correct index of number is val-1\nFor one based indexing , element at index i should be at i+1\nFor zero based indexing , correct index of number is val\nFor zero based indexing , element at index i should be at i\nAlways remember -> ignore numbers greater than size of array for zero based indexing\nAlways remember -> cyclic sort will make the duplicate numbers go at wrong place\nAlways remember -> duplicate numbers will not be at its correct place say i , then nums[i] is the duplicate and i+1 is missing",
                "code": "from typing import List\n\n\ndef cyclic_sort(nums: List[int]) -> None:\n    i = 0\n    while i < len(nums):\n        actualPos = nums[i] - 1\n        if nums[actualPos] != nums[i]:\n            nums[i], nums[actualPos] = nums[actualPos], nums[i]\n        else:\n            i += 1\n\n\nif __name__ == \"__main__\":\n    # Test cases\n    nums1 = [3, 1, 4, 2]\n    cyclic_sort(nums1)\n    assert nums1 == [1, 2, 3, 4], f\"Test case 1 failed: expected [1, 2, 3], got {nums1}\"\n\n    nums2 = [1, 3, 4, 2]\n    cyclic_sort(nums2)\n    assert nums2 == [1, 2, 3, 4], f\"Test case 2 failed: expected [1, 2, 3], got {nums2}\"\n\n    nums3 = [2, 1, 3]\n    cyclic_sort(nums3)\n    assert nums3 == [1, 2, 3], f\"Test case 3 failed: expected [1, 2, 3], got {nums3}\"\n\n    nums4 = [4, 3, 2, 1]\n    cyclic_sort(nums4)\n    assert nums4 == [\n        1,\n        2,\n        3,\n        4,\n    ], f\"Test case 4 failed: expected [1, 2, 3, 4], got {nums4}\"\n\n    nums5 = [5, 4, 3, 2, 1]\n    cyclic_sort(nums5)\n    assert nums5 == [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ], f\"Test case 5 failed: expected [1, 2, 3, 4, 5], got {nums5}\"\n\n    print(\"All test cases passed!\")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "Given an array arr[]. The task is to find the largest element and return it.\n\nExamples:\n\nInput: arr[] = [1, 8, 7, 56, 90]\nOutput: 90\nExplanation: The largest element of the given array is 90.\n\nInput: arr[] = [5, 5, 5, 5]\nOutput: 5\nExplanation: The largest element of the given array is 5.\n\nInput: arr[] = [10]\nOutput: 10\nExplanation: There is only one element which is the largest.\n\nConstraints:\n1 <= arr.size()<= 10^6\n0 <= arr[i] <= 10^6",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Largest element in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/largest-element-in-array4009/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/1_Largest_element_in_Array.py",
        "approaches": [
            {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "Sort the array in descending order to get largest element at index 0",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        return sorted(arr, reverse=True)[0]",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "traverse the entire array to find the max element",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        max_element = arr[0]\n\n        for i in range(1, len(arr)):\n            if arr[i] > max_element:\n                max_element = arr[i]\n\n        return max_element",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given an array of positive integers arr[], return the second largest element from the array. If the second largest element doesn't exist then return -1.\n\nNote: The second largest element should not be equal to the largest element.\n\nExamples:\n\nInput: arr[] = [12, 35, 1, 10, 34, 1]\nOutput: 34\nExplanation: The largest element of the array is 35 and the second largest element is 34.\n\nInput: arr[] = [10, 5, 10]\nOutput: 5\nExplanation: The largest element of the array is 10 and the second largest element is 5.\n\nInput: arr[] = [10, 10, 10]\nOutput: -1\nExplanation: The largest element of the array is 10 and the second largest element does not exist.\n\nConstraints:\n2 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^5",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Second Largest in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/second-largest3735/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/2_Second_Largest_in_Array.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "first find the largest then again find the largest excluding already found largest value",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > largest:\n                largest = arr[i]\n\n        sec_largest = -1\n        for j in range(len(arr)):\n            if arr[j] != largest and arr[j] > sec_largest:\n                sec_largest = arr[j]\n\n        return sec_largest",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "in one pass we try to find max and sec_largest\nby utilizing 2 condition\n+ if current element is greater than sec_largest,but smaller than largest\n+ if current element is greater than largest",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        sec_largest = -1\n\n        for i in range(1, len(arr)):\n            if arr[i] < largest and arr[i] > sec_largest:\n                sec_largest = arr[i]\n\n            if arr[i] > largest:\n                sec_largest = largest\n                largest = arr[i]\n\n        return sec_largest",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\n\nExample 1:\n\nInput: nums = [10,20,30,5,10,50]\nOutput: 65\nExplanation: [5,10,50] is the ascending subarray with the maximum sum of 65.\nExample 2:\n\nInput: nums = [10,20,30,40,50]\nOutput: 150\nExplanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\nExample 3:\n\nInput: nums = [12,17,15,13,10,11,12]\nOutput: 33\nExplanation: [10,11,12] is the ascending subarray with the maximum sum of 33.\n\n\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Max Ascending Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-ascending-subarray-sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/3_Max_Ascending_Subarray_Sum.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Keep track of curr_sum and max_sum\nwhenever a peak drop comes update max_sum\nkeep adding to curr_sum",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = -sys.maxsize\n        curr_sum = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i - 1]:\n                max_sum = max(curr_sum, max_sum)\n                curr_sum = nums[i]\n            else:\n                curr_sum += nums[i]\n\n        max_sum = max(curr_sum, max_sum)\n\n        return max_sum",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "Given an array arr[], check whether it is sorted in non-decreasing order. Return true if it is sorted otherwise false.\n\nExamples:\n\nInput: arr[] = [10, 20, 30, 40, 50]\nOutput: true\nExplanation: The given array is sorted.\n\nInput: arr[] = [90, 80, 100, 70, 40, 30]\nOutput: false\nExplanation: The given array is not sorted.\n\nConstraints:\n1 \u2264 arr.size \u2264 10^6\n- 10^9 \u2264 arr[i] \u2264 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check Array Sorted",
        "problem_link": "https://practice.geeksforgeeks.org/problems/check-if-an-array-is-sorted0701/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/4_Check_Array_Sorted.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Keep checking that current element must be greater than equal to previous element\nif current element lesser than previous element return false",
                "code": "class Solution:\n    def arraySortedOrNot(self, arr) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Given an array nums, return true if the array was originally sorted in non-decreasing order,\nthen rotated some number of positions (including zero). Otherwise, return false.\n\nThere may be duplicates in the original array.\n\nNote: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.\n\n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: true\nExplanation: [1,2,3,4,5] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the element of value 3: [3,4,5,1,2].\nExample 2:\n\nInput: nums = [2,1,3,4]\nOutput: false\nExplanation: There is no sorted array once rotated that can make nums.\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: true\nExplanation: [1,2,3] is the original sorted array.\nYou can rotate the array by x = 0 positions (i.e. no rotation) to make nums.\n\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Check Array is Sorted and Rotated",
        "problem_link": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/5_Check_Array_is_Sorted_and_Rotated.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "keep rotating the array by one n times then check if the current rotated array is sorted or not if in at any pass we see that the array becomes equal to its sorted state we return true otherwise we return false",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotateByOne(self, nums: list[int]):\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def check_array_sorted(self, nums: list[int]) -> bool:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                return False\n        return True\n\n    def check(self, nums: List[int]) -> bool:\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            if self.check_array_sorted(nums):\n                return True\n        return False",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Suppose ->  [3 4 5 1 2] ----- --- R1    R2 Check for valid increasing order in region I Check for valid increasing order in region II and also all elements in region II should be lesser than equal to first element in region I Think for [1,3,2] also for return case",
                "code": "from typing import List\n\n\nclass Solution:\n    def check(self, nums: List[int]) -> bool:\n        break_point = -1\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                break_point = i\n                break\n\n        if break_point == -1:\n            return True\n\n        first_element = nums[0]\n        for j in range(break_point + 1, len(nums)):\n            if nums[j] > first_element:\n                return False\n            if nums[j] < nums[j - 1]:\n                return False\n\n        return True if nums[-1] <= nums[0] else False",
                "type": "Optimal"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Suppose ->  [3 4 5 1 2]\nNumber of dips should be 0 or 1\nif more than 1 return False\nThink for [1,3,2] also for return case",
                "code": "from typing import List\n\n\nclass Solution:\n    def check(self, nums: List[int]) -> bool:\n        dips = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                dips += 1\n\n            if dips > 1:\n                return False\n\n        if dips == 0:\n            return True\n\n        return nums[-1] <= nums[0] and dips == 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once.\nThe relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\nassert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Remove Duplicates Sorted Array",
        "problem_link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/6_Remove_Duplicates_Sorted_Array.py",
        "approaches": [
            {
                "tc": "O(N)+O(Klog(K))+O(K)",
                "sc": "O(K)",
                "intuition": "store the unique nums to a set datastructure fill the first k position of the array with elements in the datastructure",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        visited_nums = set()\n        for i in range(len(nums)):\n            visited_nums.add(nums[i])\n\n        for idx, val in enumerate(\n            sorted(visited_nums)\n        ):  # since sets do not maintain order we need to sort again\n            nums[idx] = val\n\n        return len(visited_nums)",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "keep track of k which is the last element inserted position\nwe also declare a last num which keeps track of the last number visited\nif we visit a new number we update last visited num and insert the number\nat k position and atlast return k",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 1\n        last_visted_num = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != last_visted_num:\n                last_visted_num = nums[i]\n                nums[k] = nums[i]\n                k += 1\n            else:\n                last_visted_num = nums[i]\n        return k",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "You are given an integer array arr of size n. You need to implement two functions to perform rotations on this array:\n\nLeft Rotate: Implement a function left_rotate(arr: List[int]) -> List[int] that rotates the array to the left by one position. The first\nelement of the array should move to the end.\n\nRight Rotate: Implement a function right_rotate(arr: List[int]) -> List[int] that rotates the array to the right by one position.\nThe last element of the array should move to the front.\n\nLeft Rotate Test Cases:\n\nExample 1:\n\nInput:\narr = [1, 2, 3, 4, 5]\n\nOutput:\n[2, 3, 4, 5, 1]\n\nExample 2:\n\nInput:\narr = [10, 20, 30, 40, 50]\n\nOutput:\n[20, 30, 40, 50, 10]\n\n--------------------------------\n\nRight Rotate Test Cases:\n\nExample 1:\n\nInput:\narr = [1, 2, 3, 4, 5]\n\nOutput:\n[5, 1, 2, 3, 4]\n\nExample 2:\n\nInput:\narr = [10, 20, 30, 40, 50]\n\nOutput:\n[50, 10, 20, 30, 40]\n\nConstraints:\n\nThe input array will contain at least one integer.\nThe array can contain both positive and negative integers.\n\n\nIntuition",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Left Rotate Right Rotate Array By One",
        "problem_link": "NA",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/7_Left_Rotate_Right_Rotate_Array_By_One.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "For left rotation move the first element to the last index by continous swapping\nFor right rotation move the last element to the first index by continous swapping",
                "code": "from typing import List\n\n\ndef left_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1):\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n    return arr\n\n\ndef right_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[i - 1] = arr[i - 1], arr[i]\n    return arr\n\n\n# Example usage with assertions\nif __name__ == \"__main__\":\n    # Test left rotation\n    assert left_rotate([1, 2, 3, 4, 5]) == [2, 3, 4, 5, 1], \"Test Case 1 Failed\"\n    assert left_rotate([10, 20, 30, 40, 50]) == [\n        20,\n        30,\n        40,\n        50,\n        10,\n    ], \"Test Case 2 Failed\"\n    assert left_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    # Test right rotation\n    assert right_rotate([1, 2, 3, 4, 5]) == [5, 1, 2, 3, 4], \"Test Case 1 Failed\"\n    assert right_rotate([10, 20, 30, 40, 50]) == [\n        50,\n        10,\n        20,\n        30,\n        40,\n    ], \"Test Case 2 Failed\"\n    assert right_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    print(\"All test cases passed!\")",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given an array arr[]. The task is to rotate the array by d elements where d \u2264 arr.size.\n\nExamples:\n\nInput: arr[] = [-1, -2, -3, 4, 5, 6, 7], d = 2\nOutput: [-3, 4, 5, 6, 7, -1, -2]\nExplanation:\nRotate by 1: [-2, -3, 4, 5, 6, 7, -1]\nRotate by 2: [-3, 4, 5, 6, 7, -1, -2]\n\nInput: arr[] = [1, 3, 4, 2], d = 3\nOutput: [2, 1, 3, 4]\nExplanation: After rotating the array three times, the first three elements shift one by one to the right.\n\nExpected Time Complexity: O(n)\nExpected Auxiliary Space: O(1)\n\nConstraints:\n1 \u2264 arr.size \u2264 10^6\n-10^9 \u2264 arr[i] \u2264 10^9\n0 \u2264 d \u2264 arr.size",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Rotate Left K Places",
        "problem_link": "https://practice.geeksforgeeks.org/problems/reversal-algorithm5340/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/8_Rotate_Left_K_Places.py",
        "approaches": [
            {
                "tc": "O(d*N)",
                "sc": "O(1)",
                "intuition": "keep left rotating by one place for d times",
                "code": "class Solution:\n    def rotate(self, arr: list[int]):\n        for i in range(len(arr) - 1):\n            arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    def leftRotate(self, arr: list[int], d: int) -> None:\n        while d:\n            self.rotate(arr)\n            d -= 1",
                "type": "Brute"
            },
            {
                "tc": "O(k)+O(N-k)+O(N)",
                "sc": "O(1)",
                "intuition": "reverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nreverse the whole array",
                "code": "class Solution:\n    def leftRotate(self, arr: list[int], d: int) -> None:\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(arr, 0, d - 1)\n        rev_array(arr, d, len(arr) - 1)\n        rev_array(arr, 0, len(arr) - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n0 <= k <= 10^5",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rotate Right K Places",
        "problem_link": "https://leetcode.com/problems/rotate-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/9_Rotate_Right_K_Places.py",
        "approaches": [
            {
                "tc": "O(N*k)",
                "sc": "O(1)",
                "intuition": "keep right rotating by one place for d times",
                "code": "from typing import List\n\n\nclass Solution:\n    def right_rotate(self, arr: List[int]):\n        for i in range(len(arr) - 1, 0, -1):\n            arr[i], arr[i - 1] = arr[i - 1], arr[i]\n\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        while k:\n            self.right_rotate(nums)\n            k -= 1",
                "type": "Brute"
            },
            {
                "tc": "O(k)+O(N-k)+O(N)",
                "sc": "O(1)",
                "intuition": "reverse the whole array\nreverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nperform k normalization",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        k = k % len(nums)\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(nums, 0, len(nums) - 1)\n        rev_array(nums, 0, k - 1)\n        rev_array(nums, k, len(nums) - 1)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n\n\nConstraints:\n\n1 <= nums.length <= 10^4\n-^231 <= nums[i] <= 2^31 - 1",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Move Zeroes at the End",
        "problem_link": "https://leetcode.com/problems/move-zeroes",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/10_Move_Zeroes_at_the_End.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "make a copy of the array and push non negative values at first",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        cp_nums = [0] * len(nums)\n\n        idx = 0\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                cp_nums[idx] = nums[i]\n                idx += 1\n\n        nums[:] = cp_nums[:]",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "maintain a idx variable which will tell us the postion to insert the\nnon zero values,if we encounter a non zero value we swap it with the value\nat that index and we increment one to the index",
                "code": "from typing_extensions import List\n\n\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        idx = 0\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[idx], nums[i] = nums[i], nums[idx]\n                idx += 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 11,
        "question": "Given an array, arr[] sorted in ascending order and an integer k. Return true if k is present in the array, otherwise, false.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4, 6], k = 6\nOutput: true\nExplanation: Since, 6 is present in the array at index 4 (0-based indexing), output is true.\n\nInput: arr[] = [1, 2, 4, 5, 6], k = 3\nOutput: false\nExplanation: Since, 3 is not present in the array, output is false.\n\nInput: arr[] = [2, 3, 5, 6], k = 1\nOutput: false\nConstraints:\n1 <= arr.size() <= 10^6\n1 <= k <= 10^6\n1 <= arr[i] <= 10^6",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Linear Search",
        "problem_link": "https://practice.geeksforgeeks.org/problems/who-will-win-1587115621/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/11_Linear_Search.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Traverse the array until you encounter the element you are searching",
                "code": "class Solution:\n    def searchInSorted(self, arr: list[int], k: int):\n        for i in range(len(arr)):\n            if arr[i] == k:\n                return True\n        return False",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 12,
        "question": "Given two sorted arrays a[] and b[], where each array may contain duplicate elements , the task is to return the elements in the union of the two arrays in sorted order.\n\nUnion of two arrays can be defined as the set containing distinct common elements that are present in either of the arrays.\nExamples:\n\nInput: a[] = [1, 2, 3, 4, 5], b[] = [1, 2, 3, 6, 7]\nOutput: 1 2 3 4 5 6 7\nExplanation: Distinct elements including both the arrays are: 1 2 3 4 5 6 7.\n\nInput: a[] = [2, 2, 3, 4, 5], b[] = [1, 1, 2, 3, 4]\nOutput: 1 2 3 4 5\nExplanation: Distinct elements including both the arrays are: 1 2 3 4 5.\n\nInput: a[] = [1, 1, 1, 1, 1], b[] = [2, 2, 2, 2, 2]\nOutput: 1 2\nExplanation: Distinct elements including both the arrays are: 1 2.\n\nConstraints:\n1  <=  a.size(), b.size()  <=  10^5\n-10^9  <=  a[i] , b[i]  <=  10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Union of two sorted arrays with duplicates",
        "problem_link": "https://www.geeksforgeeks.org/problems/union-of-two-sorted-arrays-1587115621/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/12_Union_of_two_sorted_arrays_with_duplicates.py",
        "approaches": [
            {
                "tc": "O((m+n)log(m+n))",
                "sc": "O(m+n)+O(m+n)",
                "intuition": "merge two arrays into a list in sorted form convert the merged list to set convert the set to list and return a ssorted list",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        return sorted(list(set(sorted([*a, *b]))))",
                "type": "Brute"
            },
            {
                "tc": "O(m+n)",
                "sc": "O(1)",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nand follow the merge sort algorithm",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        union: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(a) and j < len(b):\n            if a[i] <= b[j]:\n                if last_inserted != a[i]:\n                    union.append(a[i])\n                    last_inserted = a[i]\n                i += 1\n            else:\n                if last_inserted != b[j]:\n                    union.append(b[j])\n                    last_inserted = b[j]\n                j += 1\n\n        while i < len(a):\n            if last_inserted != a[i]:\n                union.append(a[i])\n                last_inserted = a[i]\n            i += 1\n\n        while j < len(b):\n            if last_inserted != b[j]:\n                union.append(b[j])\n                last_inserted = b[j]\n            j += 1\n\n        return union",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 13,
        "question": "Given two sorted arrays arr1[] and arr2[]. Your task is to return the intersection of both arrays.\n\nIntersection of two arrays is said to be elements that are common in both arrays. The intersection should not count duplicate elements.\n\nNote: If there is no intersection then return an empty array.\n\nExamples:\n\nInput: arr1[] = [1, 2, 3, 4], arr2[] = [2, 4, 6, 7, 8]\nOutput: [2, 4]\nExplanation: 2 and 4 are only common elements in both the arrays.\n\nInput: arr1[] = [1, 2, 2, 3, 4], arr2[] = [2, 2, 4, 6, 7, 8]\nOutput: [2, 4]\nExplanation: 2 and 4 are the only common elements.\n\nInput: arr1[] = [1, 2], arr2[] = [3, 4]\nOutput: []\nExplanation: No common elements.\n\nExpected Time Complexity: O(n + m)\nExpected Auxiliary Space: O(min(n,m))\n\nConstraints:\n1 <= arr1.size(),arr2.size() <= 10^5\n1 <= arr1[i], arr2[i] <= 10^6",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Intersection of two sorted arrays",
        "problem_link": "https://www.geeksforgeeks.org/problems/intersection-of-two-sorted-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/13_Intersection_of_two_sorted_arrays.py",
        "approaches": [
            {
                "tc": "O((m+n)log(m+n))",
                "sc": "O(m+n)",
                "intuition": "convert the two arrays into set find the intersection between them return the intersection converted into list in a sorted manner",
                "code": "class Solution:\n    # Function to return a list containing the intersection of two arrays.\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        st1 = set(arr1)\n        st2 = set(arr2)\n\n        return sorted(list(st1.intersection(st2)))",
                "type": "Brute"
            },
            {
                "tc": "O(m+n)",
                "sc": "O(1)",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nJust follow merge sort algorithm and when equal elements\nare encounter insert only based on the above condition",
                "code": "class Solution:\n\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        intersection: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                i += 1\n            elif arr1[i] > arr2[j]:\n                if last_inserted != arr2[j]:\n                    last_inserted = arr2[j]\n                j += 1\n            else:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                    intersection.append(arr1[i])\n                i += 1\n                j += 1\n\n        return intersection",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 14,
        "question": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\nConstraints:\n\n2 <= nums.length <= 10^4\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9\nOnly one valid answer exists.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "2 Sum I",
        "problem_link": "https://leetcode.com/problems/two-sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/14_2_Sum_I.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all the pairs and check whether pair exists or not",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "keep marking the element as you visit them\njust check target-current_element present in seen_map or not\nX+Y=target, if target-Y is present then we can definitely say\nwe have a pair",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen_map = {}\n\n        for idx, num in enumerate(nums):\n            diff = target - num\n            if diff in seen_map:\n                return [seen_map[diff], idx]\n            seen_map[num] = idx",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 15,
        "question": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find\ntwo numbers such that they add up to a specific target number. Let these two numbers\nbe numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\n\nExample 1:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\nExample 2:\n\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\nExample 3:\n\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n\n\nConstraints:\n\n2 <= numbers.length <= 3 * 104\n-1000 <= numbers[i] <= 1000\nnumbers is sorted in non-decreasing order.\n-1000 <= target <= 1000\nThe tests are generated such that there is exactly one solution.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "2 Sum II",
        "problem_link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/15_2_Sum_II.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all pairs and see whethet target sum exists",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Use two pointers i and j\ni is at 0th and j is at last index\nif the sum becomes greater decrease range\nif the sum is lesser increase range",
                "code": "from typing import List\n\n\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        i, j = 0, len(numbers) - 1\n\n        while i < j:\n            if numbers[i] + numbers[j] > target:\n                j -= 1\n            elif numbers[i] + numbers[j] < target:\n                i += 1\n            else:\n                return [i + 1, j + 1]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 16,
        "question": "Given an integer array nums, return all the\ntriplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\nConstraints:\n\n3 <= nums.length <= 3000\n-10^5 <= nums[i] <= 10^5",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "3 Sum",
        "problem_link": "https://leetcode.com/problems/3sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/16_3_Sum.py",
        "approaches": [
            {
                "tc": "O(N^3)+O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "Sort the array to generate distinct pairs generate all possible triplet combination and see whether they add to 0",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ans = set()\n        nums.sort()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        ans.add((nums[i], nums[j], nums[k]))\n\n        return list(ans)",
                "type": "Brute"
            },
            {
                "tc": "O(N^2)+O(Nlog(N))",
                "sc": "O(N)",
                "intuition": "Fix one element at index i and perform 2 sum hashmap technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            h = {}\n            for j in range(i + 1, len(nums)):\n                diff = 0 - nums[i] - nums[j]\n                if diff in h:\n                    ans.add((nums[i], nums[j], nums[h[diff]]))\n                h[nums[j]] = j\n\n        return list(ans)",
                "type": "Better"
            },
            {
                "tc": "O(N^2)+O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "Fix one element at index i and perform 2 sum sorted array technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            j, k = i + 1, len(nums) - 1\n\n            if (\n                i != 0 and nums[i] == nums[i - 1]\n            ):  # we dont want to generate same triplets\n                continue\n\n            while j < k:\n                if nums[i] + nums[j] + nums[k] > 0:\n                    k -= 1\n                elif nums[i] + nums[j] + nums[k] < 0:\n                    j += 1\n                elif nums[i] + nums[j] + nums[k] == 0:\n                    ans.add((nums[i], nums[j], nums[k]))\n                    j += 1\n                    k -= 1\n\n                    # we dont want to generate same triplets\n                    while nums[j] == nums[j - 1] and j < k:\n                        j += 1\n                    while nums[k] == nums[k + 1] and j < k:\n                        k -= 1\n\n        return list(ans)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 17,
        "question": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n\n\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\nConstraints:\n\n1 <= nums.length <= 200\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "4 Sum",
        "problem_link": "https://leetcode.com/problems/4sum",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/17_4_Sum.py",
        "approaches": [
            {
                "tc": "O(N^4)",
                "sc": "O(1)",
                "intuition": "Generate all possible pairs and check if target sum exists",
                "code": "from contextlib import contextmanager\nfrom typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    for l in range(k + 1, len(nums)):\n                        sm = nums[i] + nums[j] + nums[k] + nums[l]\n\n                        if sm == target:\n                            ans.add((nums[i], nums[j], nums[k], nums[l]))\n\n        return list(ans)",
                "type": "Brute"
            },
            {
                "tc": "O(N^3)",
                "sc": "O(N)",
                "intuition": "Fix one element at index i and other at j and perform 2 sum hashmap technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                h = {}\n                for k in range(j + 1, len(nums)):\n                    diff = target - nums[i] - nums[j] - nums[k]\n                    if diff in h:\n                        ans.add((nums[i], nums[j], nums[k], nums[h[diff]]))\n                    h[nums[k]] = k\n\n        return list(ans)",
                "type": "Better"
            },
            {
                "tc": "O(N^3)",
                "sc": "O(1)",
                "intuition": "Fix one element at index i and other at j and perform 2 sum sorted array technique",
                "code": "from typing import List\n\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            if i != 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums)):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n\n                k, l = j + 1, len(nums) - 1\n                while k < l:\n                    sm = nums[i] + nums[j] + nums[k] + nums[l]\n                    if sm > target:\n                        l -= 1\n                    elif sm < target:\n                        k += 1\n                    elif sm == target:\n                        ans.add((nums[i], nums[j], nums[k], nums[l]))\n                        k += 1\n                        l -= 1\n\n                        while nums[k] == nums[k - 1] and k < l:\n                            k += 1\n\n                        while nums[l] == nums[l + 1] and k < l:\n                            l -= 1\n\n        return list(ans)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 18,
        "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n\nExample 1:\n\nInput: nums = [3,0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n\nExample 2:\n\nInput: nums = [0,1]\n\nOutput: 2\n\nExplanation:\n\nn = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n\nExample 3:\n\nInput: nums = [9,6,4,2,3,5,7,0,1]\n\nOutput: 8\n\nExplanation:\n\nn = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^4\n0 <= nums[i] <= n\nAll the numbers of nums are unique.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Missing Number",
        "problem_link": "https://leetcode.com/problems/missing-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/18_Missing_Number.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Since numbers are in range of 1 to n first find sum of natural numbers from 1 to n and substract the current sum of the array , we will get the missing number",
                "code": "from typing import List\n\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        actualSum = n * (n + 1) // 2\n        currSum = sum(nums)\n        return actualSum - currSum",
                "type": "Optimal"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "use cyclic sort",
                "code": "from typing import List\n\n\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        i = 0\n\n        while i < len(nums):\n            actualPos = nums[i]\n            if nums[i] < len(nums) and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n\n        return len(nums)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 19,
        "question": "Given an array nums of n integers where nums[i] is in the range [1, n], return an\narray of all the integers in the range [1, n] that do not appear in nums.\n\n\nExample 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\n\nInput: nums = [1,1]\nOutput: [2]\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^5\n1 <= nums[i] <= n\n\n\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Find All Numbers Disappeared in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/19_Find_All_Numbers_Disappeared_in_an_Array.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(2N)",
                "intuition": "create a map containing items that should be present create a map containing current items in array iterate through the should_contain_map and check which elements are not in curr_contain_map",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n        curr_contain_map = {i: True for i in nums}\n\n        ans = []\n        for k, v in should_contain_map.items():\n            if k not in curr_contain_map:\n                ans.append(k)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Do cyclic sort\nafter cyclic sort does the element expected for that index match",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, arr: List[int]) -> None:\n        idx = 0\n\n        while idx < len(arr):\n            actualPos = arr[idx] - 1\n\n            if arr[actualPos] != arr[idx]:\n                arr[actualPos], arr[idx] = arr[idx], arr[actualPos]\n            else:\n                idx += 1\n\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        ans = []\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(i + 1)\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 20,
        "question": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and using only constant extra space.\n\n\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\nExample 3:\n\nInput: nums = [3,3,3,3,3]\nOutput: 3\n\n\nConstraints:\n\n1 <= n <= 10^5\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n\n\nFollow up:\n\nHow can we prove that at least one duplicate number must exist in nums?\nCan you solve the problem in linear runtime complexity?",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find the Duplicate Number",
        "problem_link": "https://leetcode.com/problems/find-the-duplicate-number",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/20_Find_the_Duplicate_Number.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Use a hasmap to keep track of seen elements if we see a elements more than twice return that element",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        seen = {}\n\n        for i in nums:\n            if i in seen:\n                return i\n            seen[i] = True\n\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Use the cylic sort algoritm\nsort the array using cyclic sort\nthe first number not at its correct place is the duplicate",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicate(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return nums[i]\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 21,
        "question": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer\nappears at most twice, return an array of all the integers that appears twice.\n\nYou must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output\n\n\nExample 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExample 2:\n\nInput: nums = [1,1,2]\nOutput: [1]\nExample 3:\n\nInput: nums = [1]\nOutput: []\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 10^5\n1 <= nums[i] <= n\nEach element in nums appears once or twice.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find All Duplicates in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-duplicates-in-an-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/21_Find_All_Duplicates_in_an_Array.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "use map to keep track of frequency number occuring more than 2 are duplicates",
                "code": "from typing import List\n\n\nclass Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        freq_mp = {}\n\n        for num in nums:\n            freq_mp[num] = 1 + freq_mp.get(num, 0)\n\n        ans = []\n        for num in freq_mp:\n            if freq_mp[num] >= 2:\n                ans.append(num)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "do cyclic sort\nnumbers not at its correct place are the duplicates",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n        ans = []\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(nums[i])\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 22,
        "question": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error,\none of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n\nYou are given an integer array nums representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return them in the form of an array.\n\n\nExample 1:\n\nInput: nums = [1,2,2,4]\nOutput: [2,3]\nExample 2:\n\nInput: nums = [1,1]\nOutput: [1,2]\n\n\nConstraints:\n\n2 <= nums.length <= 10^4\n1 <= nums[i] <= 10^4",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Set Mismatch",
        "problem_link": "https://leetcode.com/problems/set-mismatch",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/22_Set_Mismatch.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "For missing number keep track of what should be present and compare it with current present map For duplicate find the number with frequency more than 2",
                "code": "class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        ans = []\n\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n\n        current_contain_map = {}\n        for num in nums:\n            current_contain_map[num] = 1 + current_contain_map.get(num, 0)\n\n        for num in current_contain_map:\n            if current_contain_map[num] > 1:\n                ans.append(num)\n\n        for num in should_contain_map:\n            if num not in current_contain_map:\n                ans.append(num)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "do cyclic sort\nnumbers not at correct place is the duplicate and index is the missing",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return [nums[i], i + 1]\n\n        return []",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 23,
        "question": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\n\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "First Missing Positive",
        "problem_link": "https://leetcode.com/problems/first-missing-positive",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/23_First_Missing_Positive.py",
        "approaches": [
            {
                "tc": "O(max*N)",
                "sc": "O(1)",
                "intuition": "we know that all the positive numbers will lie from 1 to max_number+2 max_number is taken because suppose we have [1,2] then the first missing positive will be 3 just check sequentially from starting whether any number in this is range is absent then that will be our missing first positive termination condition is 1 becuase what if we have ony negatives [-1,-2]",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        for i in range(1, max(nums) + 2):\n            found = False\n            for j in range(len(nums)):\n                if nums[j] <= 0:\n                    continue\n                if i == nums[j]:\n                    found = True\n                    break\n            if not found:\n                return i\n\n        return 1",
                "type": "Brute"
            },
            {
                "tc": "O(max_number)",
                "sc": "O(max_number)",
                "intuition": "Keep track of what element should be present increment the number in the map wrt to elements present in original map see which numbers count is still zero",
                "code": "from typing import List\n\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        should_contain_map = {}\n        for i in range(1, max(nums) + 2):\n            should_contain_map[i] = 0\n\n        for num in nums:\n            if num in should_contain_map:\n                should_contain_map[num] += 1\n\n        for num in should_contain_map:\n            if should_contain_map[num] == 0:\n                return num\n\n        return 1",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Do cyclic cyclic_sort\nignore number greater than size of array and negative numbers since zero based indexing\nthe first number at wro",
                "code": "from typing import List\n\n\nclass Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[i] < len(nums) and nums[i] > 0 and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 24,
        "question": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn the single element that appears only once.\n\nYour solution must run in O(log n) time and O(1) space.\n\n\nExample 1:\n\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\n\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^5",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Find Element Appeating more than once",
        "problem_link": "https://leetcode.com/problems/single-element-in-a-sorted-array",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/24_Find_Element_Appeating_more_than_once.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "just check one by one the count of each element in the array if count is equal to return nums",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            cnt = 0\n            for j in range(len(nums)):\n                if nums[i] == nums[j]:\n                    cnt += 1\n                if cnt >= 2:\n                    break\n            if cnt == 1:\n                return nums[i]\n        return -1",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "maintain a frequency map return element with frequency 1",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        freq_map = {}\n\n        for num in nums:\n            freq_map[num] = 1 + freq_map.get(num, 0)\n\n        for num in freq_map:\n            if freq_map[num] == 1:\n                return num\n\n        return -1",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "we know xor of any 2 same number is 0\nand xor of 0 with any number (x) is x\nso same number get cancelled out leaving\nthe element appeating once",
                "code": "from typing import List\n\n\nclass Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        xor = 0\n\n        for num in nums:\n            xor ^= num\n\n        return xor",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 25,
        "question": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\n\n\nExample 1:\n\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\nnums[i] is either 0 or 1.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Max Consecutive Ones",
        "problem_link": "https://leetcode.com/problems/max-consecutive-ones",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/25_Max_Consecutive_Ones.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Keep track of number of 1s encountered till now\nif current num is 1 increment 1s encountered\nat every step you encounter 1 find max of count and max_ones\nif current num is 0 reset counter",
                "code": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        max_ones = 0\n        c = 0\n\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                c += 1\n                max_ones = max(max_ones, c)\n            else:\n                c = 0\n\n        return max_ones",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 26,
        "question": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\n\nExample 1:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Sort an array of 0's 1's & 2's",
        "problem_link": "https://leetcode.com/problems/sort-colors",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/26_Sort_an_array_of_0's_1's_&_2's.py",
        "approaches": [
            {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "sort using inbilt function",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(3)",
                "intuition": "Count occurences of 0s,1s,2s and store them in a map Then fill the array with the number of times each element occurs",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        count_map = {0: 0, 1: 0, 2: 0}\n\n        for num in nums:\n            count_map[num] += 1\n\n        idx = 0\n        for num, count in count_map.items():\n            for i in range(count):\n                nums[idx] = num\n                idx += 1",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Use dutch national flag algorithm\ngoal of this algo is to push all the low values to left\nand high values to right\nat first our entire array is unsorted\nso we can put the mid at 0 and high at len(array)-1\nand start in the 0 th postiion\n\n00000000000000     111111111111     ?????????         2222222222\n^            ^     ^          ^     ^       ^         ^        ^\n0         low-1   low     mid-1    mid      high     high+1   n-1\n\n? is ith unsorted portion",
                "code": "from typing import List\n\n\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low, mid = 0, 0\n        high = len(nums) - 1\n\n        for _ in range(len(nums)):\n            # if unsorted portion has zero\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n\n            # if unsorted portion has one\n            elif nums[mid] == 1:\n                mid += 1\n\n            # if unsorted portion has two\n            elif nums[mid] == 2:\n                nums[high], nums[mid] = nums[mid], nums[high]\n                high -= 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 27,
        "question": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\n\nYou should return the array of nums such that the the array follows the given conditions:\n\nEvery consecutive pair of integers have opposite signs.\nFor all integers with the same sign, the order in which they were present in nums is preserved.\nThe rearranged array begins with a positive integer.\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.\n\n\nExample 1:\n\nInput: nums = [3,1,-2,-5,2,-4]\nOutput: [3,-2,1,-5,2,-4]\nExplanation:\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.\nExample 2:\n\nInput: nums = [-1,1]\nOutput: [1,-1]\nExplanation:\n1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1].\n\n\nConstraints:\n\n2 <= nums.length <= 2 * 10^5\nnums.length is even\n1 <= |nums[i]| <= 10^5\nnums consists of equal number of positive and negative integers.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rearrange Array Elements by Sign",
        "problem_link": "https://leetcode.com/problems/rearrange-array-elements-by-sign",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/27_Rearrange_Array_Elements_by_Sign.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(2N)",
                "intuition": "Store all the positive,negative numbers in 2 seperate list since array consists of equal number of positive and negative integers so we are sure that at even index we will have positive number and at odd index we will have negative numbers",
                "code": "from typing import List\n\n\nclass Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        pos, neg = [], []\n\n        for num in nums:\n            if num < 0:\n                neg.append(num)\n            if num >= 0:\n                pos.append(num)\n\n        ans = []\n        posIdx, negIdx = 0, 0\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                ans.append(pos[posIdx])\n                posIdx += 1\n            else:\n                ans.append(neg[negIdx])\n                negIdx += 1\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "since array consists of equal number of positive and negative integers\nso we are sure that at even index we will have positive number and\nat odd index we will have negative numbers\nkeep track of next positive index and next negative index",
                "code": "from typing import List\n\n\nclass Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        ans = [0 for _ in range(len(nums))]\n\n        posIdx = 0\n        negIdx = 1\n\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                ans[posIdx] = nums[i]\n                posIdx += 2\n            else:\n                ans[negIdx] = nums[i]\n                negIdx += 2\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 28,
        "question": "Given an unsorted array arr containing both positive and negative numbers. Your task is to rearrange the array and convert it\ninto an array of alternate positive and negative numbers without changing the relative order.\n\nNote:\n- Resulting array should start with a positive integer (0 will also be considered as a positive integer).\n- If any of the positive or negative integers are exhausted, then add the remaining integers in the answer\nas it is by maintaining the relative order.\n- The array may or may not have the equal number of positive and negative integers.\n\nExamples:\n\nInput: arr[] = [9, 4, -2, -1, 5, 0, -5, -3, 2]\nOutput: [9, -2, 4, -1, 5, -5, 0, -3, 2]\nExplanation: The positive numbers are [9, 4, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 4 and then -1 and so on.\n\nInput: arr[] = [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8]\nOutput: [5, -5, 2, -2, 4, -8, 7, 1, 8, 0]\nExplanation : The positive numbers are [5, 2, 4, 7, 1, 8, 0] and the negative integers are [-5,-2,-8]. According to the given conditions we will start from the positive integer 5 and then -5 and so on. After reaching -8 there are no negative elements left, so according to the given rule, we will add the remaining elements (in this case positive elements are remaining) as it in by maintaining the relative order.\n\nInput: arr[] = [9, 5, -2, -1, 5, 0, -5, -3, 2]\nOutput: [9, -2, 5, -1, 5, -5, 0, -3, 2]\nExplanation: The positive numbers are [9, 5, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 5 and then -1 and so on.\n\nConstraints:\n1 \u2264 arr.size() \u2264 106\n-106 \u2264 arr[i] \u2264 106",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Alternate Positive Negative",
        "problem_link": "https://www.geeksforgeeks.org/problems/array-of-alternate-ve-and-ve-nos1401/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/28_Alternate_Positive_Negative.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)+O(N/2)+O(N/2)",
                "intuition": "Separate Positive and Negative numbers Merge the Two Vectors Alternately After append the remaining elements to the ans",
                "code": "class Solution:\n    def rearrange(self, arr: list[int]):\n        ans: list[int] = [0 for _ in range(len(arr))]\n\n        pos, neg = [], []\n\n        for num in arr:\n            if num >= 0:\n                pos.append(num)\n            else:\n                neg.append(num)\n\n        idx = 0\n        if len(pos) <= len(neg):\n            for i in range(len(pos)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(pos), len(neg)):\n                ans[idx] = neg[j]\n                idx += 1\n        else:\n            for i in range(len(neg)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(neg), len(pos)):\n                ans[idx] = pos[j]\n                idx += 1\n\n        arr[::] = ans[::]",
                "type": "Brute"
            },
            {
                "tc": "-",
                "sc": "-",
                "intuition": "",
                "code": "",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 29,
        "question": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n\nConstraints:\n\n1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^4",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Best Time to Buy and Sell Stock",
        "problem_link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/29_Best_Time_to_Buy_and_Sell_Stock.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Suppose you are at index i just ask yourself\ncan i sell this stock on this day if i have\nthe minimum stock cost from left side of the index\nbuy in less price and sell in high price",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_cp_till_now = prices[0]\n        max_profit = -sys.maxsize\n\n        for i in range(len(prices)):\n            max_profit = max(max_profit, prices[i] - min_cp_till_now)\n            min_cp_till_now = min(min_cp_till_now, prices[i])\n\n        return max_profit",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 30,
        "question": "You are given an array arr of positive integers. Your task is to find all the leaders\nin the array. An element is considered a leader if it is greater than or equal\nto all elements to its right. The rightmost element is always a leader.\n\nExamples:\n\nInput: arr = [16, 17, 4, 3, 5, 2]\nOutput: [17, 5, 2]\nExplanation: Note that there is nothing greater on the right side of 17, 5 and, 2.\n\nInput: arr = [10, 4, 2, 4, 1]\nOutput: [10, 4, 4, 1]\nExplanation: Note that both of the 4s are in output, as to be a leader an equal element is also allowed on the right. side\n\nInput: arr = [5, 10, 20, 40]\nOutput: [40]\nExplanation: When an array is sorted in increasing order, only the rightmost element is leader.\n\nInput: arr = [30, 10, 10, 5]\nOutput: [30, 10, 10, 5]\nExplanation: When an array is sorted in non-increasing order, all elements are leaders.\n\nConstraints:\n1 <= arr.size() <= 106\n0 <= arr[i] <= 106",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Leaders in an array",
        "problem_link": "https://www.geeksforgeeks.org/problems/leaders-in-an-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/30_Leaders_in_an_array.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "traverse the array from right\nkeep track of the maximum height from the right till now\ncompare the value at current index with the max_from_right so far\nif it is greater then we can say its a leader",
                "code": "class Solution:\n    def leaders(self, arr: list[int]) -> list[int]:\n        max_from_right = arr[-1]\n\n        n = len(arr)\n        ans = [arr[-1]]\n\n        for i in range(n - 2, -1, -1):\n            if arr[i] >= max_from_right:\n                ans.append(arr[i])\n                max_from_right = arr[i]\n\n        return ans[::-1]",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 31,
        "question": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the\ninput 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\nExample 2:\n\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Rotate Image",
        "problem_link": "https://leetcode.com/problems/rotate-image",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/31_Rotate Image.py",
        "approaches": [
            {
                "tc": "O(N*M)",
                "sc": "O(1)",
                "intuition": "Do transpose of a matrix\nReverse every row",
                "code": "from typing import List\n\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # Transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(\n                i + 1, len(matrix[0])\n            ):  # swap values above diagonal to avoid overwriting\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # Reverse each row\n        for i in range(len(matrix)):\n            j = 0\n            while j < len(matrix[0]) // 2:\n                n = len(matrix[0])\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\n                j += 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 32,
        "question": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Spiral Matrix",
        "problem_link": "https://leetcode.com/problems/spiral-matrix",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/32_Spiral_Matrix.py",
        "approaches": [
            {
                "tc": "O(N*M)",
                "sc": "O(N*M)",
                "intuition": "keep 4 pointes top,left,right,bottom\njust do what they have said till left<=right and top<=bottom",
                "code": "from typing import List\n\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        top = 0\n        left = 0\n        right = len(matrix[0]) - 1\n        bottom = len(matrix) - 1\n\n        ans = []\n\n        while left <= right and top <= bottom:\n            # Left to Right\n            for i in range(left, right + 1):\n                ans.append(matrix[top][i])\n            top += 1\n\n            # Top to Bottom\n            for i in range(top, bottom + 1):\n                ans.append(matrix[i][right])\n            right -= 1\n\n            # Right to Left\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    ans.append(matrix[bottom][i])\n                bottom -= 1\n\n            # Bottom to Top\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    ans.append(matrix[i][left])\n                left += 1\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 33,
        "question": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the\nmajority element always exists in the array.\n\n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Majority Element I",
        "problem_link": "https://leetcode.com/problems/majority-element",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/34_Majority_Element_I.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep track of the element appearing more than n//2 times using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        majority_element = -1\n        appear_count = len(nums) // 2\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_element = nums[i]\n\n        return majority_element",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//2 times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        appear_count = len(nums) // 2\n        freq_mp = {}\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                return num\n\n        return -1",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times\n+ assume first element as majority element\n+ if you see majority element again increment count\n+ if you see new element decrement count\n+ if count is zero new majority element has come",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        maj = nums[0]\n        c = 1\n\n        for i in range(1, len(nums)):\n            # increment count if its the same majority element\n            if nums[i] == maj:\n                c += 1\n\n            elif c == 0:  # reset majority element\n                c = 1\n                maj = nums[i]\n\n            # decrement count if its not the current majority element\n            elif nums[i] != maj:\n                c -= 1\n\n        return maj",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 34,
        "question": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times.\n\n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: [3]\nExample 2:\n\nInput: nums = [1]\nOutput: [1]\nExample 3:\n\nInput: nums = [1,2]\nOutput: [1,2]\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Majority Element II",
        "problem_link": "https://leetcode.com/problems/majority-element-ii",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/35_Majority_Element_II.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep track of the element appearing more than n//3 times using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        majority_elements: set[int] = set()\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_elements.add(nums[i])\n\n        return list(majority_elements)",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//3 times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        freq_mp = {}\n        majority_elements: set[int] = set()\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                majority_elements.add(num)\n\n        return list(majority_elements)",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times",
                "code": "from typing import List\n\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        maj1 = nums[0]\n        c1 = 0\n\n        maj2 = nums[0]\n        c2 = 0\n\n        for i in range(len(nums)):\n            # increment count1 if its the same majority element1\n            if nums[i] == maj1:\n                c1 += 1\n\n            # increment count2 if its the same majority element2\n            elif nums[i] == maj2:\n                c2 += 1\n\n            elif c1 == 0:  # reset majority element1\n                c1 = 1\n                maj1 = nums[i]\n\n            elif c2 == 0:  # reset majority element2\n                c2 = 1\n                maj2 = nums[i]\n\n            else:\n                c1 -= 1\n                c2 -= 1\n\n        c1 = 0\n        c2 = 0\n        for i in range(len(nums)):\n            if nums[i] == maj1:\n                c1 += 1\n            elif nums[i] == maj2:\n                c2 += 1\n\n        ans = []\n\n        if c1 > appear_count:\n            ans.append(maj1)\n\n        if c2 > appear_count:\n            ans.append(maj2)\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 35,
        "question": "Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n\n\nConstraints:\n\n1 <= numRows <= 30",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Pascals's Triangle",
        "problem_link": "https://leetcode.com/problems/pascals-triangle",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/36_Pascals's_Triangle.py",
        "approaches": [
            {
                "tc": "O(numRows*last_row)",
                "sc": "O(N)",
                "intuition": "when starting pad your last seen row with single 0 For example if a last row is [0,1,2,1,0] The next row will be the summation of pairs i,i+1 [(0+1),(1+2),(2+1),(1+0)] = [1,3,3,1]",
                "code": "from typing import List\n\n\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = [[1]]\n        last_row = [0, 1, 0]\n\n        for i in range(numRows - 1):\n            tmp = []\n            for j in range(len(last_row) - 1):\n                tmp.append(last_row[j] + last_row[j + 1])\n            ans.append(tmp)\n            last_row = [0, *tmp, 0]\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Must Know (1) : Given row and col , find element at row and col , You can find with\nthis formula -> row-1 C col-1\n\nObservation suppose i have 7C2 ->  (7*6)*(5*4*3*2*1)\n-----------------\n(2*1)*(5*4*3*2*1)\nyou will see only first 2 in the numerator and denominator is left others get cancel\ntry it for others you will see only the \"col\"(r) part remains\n------------------------------------------------------------------------------------\n\nMust Know (2) : Given n print the nth pascals-triangle row, you can use the above\nformula and try to find it in O(N*r) complexity ,but we can improve it a further\nIn pascals-triangle the nth row will have n elements\nGiven 6th row of pascals-triangle\n\nCol Idx           0   1        2            3               4                   5\n\nObservation :     1   5       10           10               5                   1\n\nMultiplication:   1   5/1    (5*4)/(1*2)  (5*4*3)/(1*2*3) (5*4*3*4)/(1*2*3*4)  (5*4*3*4*5)/(1*2*3*4*5)\n\n\nFormula for finding the ith element in a row  is : (row-col)/col , you just have to maintain previouse cols value\n------------------------------------------------------------------------------------------------------------------",
                "code": "from typing import List\n\n\nclass Solution:\n    def getNRow(self, n: int) -> list[int]:\n        ans = 1\n        tmp = [1]\n        for i in range(1, n):\n            ans *= n - i\n            ans //= i\n            tmp.append(ans)\n        return tmp\n\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = []\n        for i in range(1, numRows + 1):\n            ans.append(self.getNRow(i))\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 36,
        "question": "Given an array arr containing both positive and negative integers, the task is to compute the length of the largest subarray that has a sum of 0.\n\nExamples:\n\nInput: arr[] = [15, -2, 2, -8, 1, 7, 10, 23]\nOutput: 5\nExplanation: The largest subarray with a sum of 0 is [-2, 2, -8, 1, 7].\n\nInput: arr[] = [2, 10, 4]\nOutput: 0\nExplanation: There is no subarray with a sum of 0.\n\nInput: arr[] = [1, 0, -4, 3, 1, 0]\nOutput: 5\nExplanation: The subarray is [0, -4, 3, 1, 0].\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^6\n\u221210^3 \u2264 arr[i] \u2264 10^3, for each valid i",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray 0 Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/largest-subarray-with-0-sum/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/38_Longest_Subarray_0_Sum.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays find the longest subarray with 0 sum from them",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        sm = 0\n        k = 0\n\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 37,
        "question": "Given an array arr[] containing integers and an integer k, your task is to find the\nlength of the longest subarray where the sum of its elements is equal to the given value k. If there is no subarray with sum equal to k, return 0.\n\nExamples:\n\nInput: arr[] = [10, 5, 2, 7, 1, -10], k = 15\nOutput: 6\nExplanation: Subarrays with sum = 15 are [5, 2, 7, 1], [10, 5] and [10, 5, 2, 7, 1, -10]. The length of the longest subarray with a sum of 15 is 6.\n\nInput: arr[] = [-5, 8, -14, 2, 4, 12], k = -5\nOutput: 5\nExplanation: Only subarray with sum = -5 is [-5, 8, -14, 2, 4] of length 5.\n\nInput: arr[] = [10, -10, 20, 30], k = 5\nOutput: 0\nExplanation: No subarray with sum = 5 is present in arr[].\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^5\n-10^4 \u2264 arr[i] \u2264 10^4\n-10^9 \u2264 k \u2264 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray K Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/39_Longest_Subarray_K_Sum.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays find the longest subarray with k sum from them",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        # code here\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == k:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        sm = 0\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 38,
        "question": "Given an array arr[] and a positive integer k, find the length of the longest subarray with the sum of the elements divisible by k.\nNote: If there is no subarray with sum divisible by k, then return 0.\n\nExamples :\n\nInput: arr[] = [2, 7, 6, 1, 4, 5], k = 3\nOutput: 4\nExplanation: The subarray [7, 6, 1, 4] has sum = 18, which is divisible by 3.\n\nInput: arr[] = [-2, 2, -5, 12, -11, -1, 7], k = 3\nOutput: 5\nExplanation: The subarray [2, -5, 12, -11, -1] has sum = -3, which is divisible by 3.\n\nInput: arr[] = [1, 2, -2], k = 2\nOutput: 2\nExplanation: The subarray is [2, -2] has sum = 0, which is divisible by 2.\n\nConstraints:\n1 <= arr.size() <= 10^6\n1 <= k <= 10^6\n-10^6 <= arr[i] <= 10^6",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Subarray Sum Divisible by K",
        "problem_link": "<Question Link>",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/40_Longest_Subarray_Sum_Divisible_by_K.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all subarrays among them find the longest subarray divisible by k",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm % k == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n        sm = 0\n        remainder_map = {0: -1}\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            rem = sm % k\n\n            if rem < 0:  # dont store negative remainder\n                rem += k\n\n            if rem in remainder_map:\n                mx_len = max(mx_len, i - remainder_map[rem])\n\n            if rem not in remainder_map:\n                remainder_map[rem] = i\n\n        return mx_len",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 39,
        "question": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n\nExample 1:\n\nInput: nums = [1,1,1], k = 2\nOutput: 2\nExample 2:\n\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\n\nConstraints:\n\n1 <= nums.length <= 2 * 10^4\n-1000 <= nums[i] <= 1000\n-10^7 <= k <= 10^7",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray K Sum",
        "problem_link": "https://leetcode.com/problems/subarray-sum-equals-k",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/41_Count_Subarray_K_Sum.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays and count subarrays with sum k",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n\n                if sm == k:\n                    c += 1\n\n        return c",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the count till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum\nUse the concept of prefix sum\nhow many s-k we have to remove inorder from curr sum to get k\nno of s-k will be equivalent to no of k\n\nNow, there may exist multiple subarrays with the prefix sum x-k. So, the number of subarrays\nwith sum k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix sum x-k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        sm = 0\n        k_sum_count_map = {0: 1}\n        count = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n\n            diff = sm - k\n\n            if diff in k_sum_count_map:\n                count += k_sum_count_map[diff]\n\n            if sm not in k_sum_count_map:\n                k_sum_count_map[sm] = 1\n            else:\n                k_sum_count_map[sm] += 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 40,
        "question": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n\nA subarray is a contiguous part of an array.\n\n\nExample 1:\n\nInput: nums = [4,5,0,-2,-3,1], k = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\nExample 2:\n\nInput: nums = [5], k = 9\nOutput: 0\n\n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-10^4 <= nums[i] <= 10^4\n2 <= k <= 10^4",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray Sum Divisible by K",
        "problem_link": "https://leetcode.com/problems/subarray-sums-divisible-by-k",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/42_Count_Subarray_Sum_Divisible_by_K.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays from those subarrays count subarray sum divisible by k",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                if sm % k == 0:\n                    count += 1\n\n        return count",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before",
                "code": "from typing import List\n\n\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n        rem_count_mp = {0: 1}\n        sm = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n            rem = sm % k\n\n            if rem < 0:\n                rem += k\n\n            if rem in rem_count_mp:\n                count += rem_count_mp[rem]\n\n            if rem not in rem_count_mp:\n                rem_count_mp[rem] = 1\n            else:\n                rem_count_mp[rem] += 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 41,
        "question": "Given an array of integers arr[] and a number k, count the number of subarrays having XOR of their elements as k.\n\nExamples:\n\nInput: arr[] = [4, 2, 2, 6, 4], k = 6\nOutput: 4\nExplanation: The subarrays having XOR of their elements as 6 are [4, 2], [4, 2, 2, 6, 4], [2, 2, 6], and [6]. Hence, the answer is 4.\n\nInput: arr[] = [5, 6, 7, 8, 9], k = 5\nOutput: 2\nExplanation: The subarrays having XOR of their elements as 5 are [5] and [5, 6, 7, 8, 9]. Hence, the answer is 2.\n\nInput: arr[] = [1, 1, 1, 1], k = 0\nOutput: 4\nExplanation: The subarrays are [1, 1], [1, 1], [1, 1] and [1, 1, 1, 1].\n\nConstraints:\n\n1 \u2264 arr.size() \u2264 10^5\n0 \u2264 arr[i] \u226410^5\n0 \u2264 k \u2264 10^5",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Subarray K XOR",
        "problem_link": "https://www.geeksforgeeks.org/problems/count-subarray-with-given-xor/0",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/43_Count_Subarray_K_XOR.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(N)",
                "intuition": "Generate all subarrays count subarrays with k xor from them",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(arr)):\n            xor = 0\n            for j in range(i, len(arr)):\n                xor ^= arr[j]\n\n                if xor == k:\n                    c += 1\n\n        return c",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Now, there may exist multiple subarrays with the prefix xor pref^k. So, the number of subarrays\nwith xor k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix xor pref^k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        pref_xor = 0\n        count = 0\n        xor_mp = {0: 1}\n\n        for i in range(len(arr)):\n            pref_xor ^= arr[i]\n\n            diff_xor = pref_xor ^ k\n\n            if diff_xor in xor_mp:\n                count += xor_mp[diff_xor]\n\n            if pref_xor in xor_mp:\n                xor_mp[pref_xor] += 1\n            else:\n                xor_mp[pref_xor] = 1\n\n        return count",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 42,
        "question": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\nExample 3:\n\nInput: nums = [1,0,1,2]\nOutput: 3\n\n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Longest Consecutive Sequence",
        "problem_link": "https://leetcode.com/problems/longest-consecutive-sequence",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/44_Longest_Consecutive_Sequence.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "sort the array and find the longest consecutive sequence ignore equal length number",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        nums.sort()\n\n        mx_len = 1\n        curr_len = 1\n\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] == 1:\n                curr_len += 1\n                mx_len = max(mx_len, curr_len)\n            elif nums[i] - nums[i - 1] == 0:\n                mx_len = max(mx_len, curr_len)\n                continue\n            else:\n                curr_len = 1\n\n        return mx_len",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "The answer lies in visualization\nconsider the below array\n100 4 200 1 3 2\n\n1 2 3 4     100        200\n---------------------------\n\nconvert the given array to set\nstarting values of the sequence does not have left neightbour\nso whenever we find an element which does not have left neightbour\nwe will start a while loop incrementing it by 1 and check if that\nnumber exists and keep on building the sequence and atlast we can\ncheck if its the max length till now or not",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for num in numSet:\n            if (num - 1) not in numSet:\n                length = 1\n                while (num + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 43,
        "question": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Sum Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/45_Maximum_Sum_Subarray.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays, and find the subarray with max sum",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                mx_sum = max(mx_sum, sm)\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "A subarray with a sum less than 0 will always reduce our answer and so this type of subarray cannot be a part of the subarray with maximum sum among all the sum calculated we take the sum. In each pass we decide whethet to start a new seqeunce or continue or our old seqeunce",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        curr_sum = 0\n        global_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        return global_sum",
                "type": "Optimal"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "print the sequence\nwhen the sum is zero we can say right its a start of the sequnce\ntake 2 pointers ansStart and ansEnd and another variable to track\ncurrent start",
                "code": "from typing import List\nimport sys\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]):\n        curr_sum = 0\n        global_sum = -sys.maxsize\n        resStart, resEnd = 0, 0\n        currStart = 0\n\n        for i in range(len(nums)):\n            if curr_sum == 0:\n                currStart = i\n\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n                resStart = currStart\n                resEnd = i\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        print(\"Maximum subarray sequence:\", nums[resStart : resEnd + 1])\n        print(\"Maximum subarray sum:\", global_sum)\n\n\nobj = Solution()\nls = [1, -2, -1, 0, 3, 4]\nls = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nobj.maxSubArray(ls)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 44,
        "question": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\n\nA circular array means the end of the array connects to the beginning of the array. Formally,\nthe next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\n\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a\nsubarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n\nExample 1:\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\nExample 2:\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\nExample 3:\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n\n\nConstraints:\n\nn == nums.length\n1 <= n <= 3 * 10^4\n-3 * 10^4 <= nums[i] <= 3 * 10^4",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Circular Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/46_Maximum_Circular_Subarray_Sum.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all subarrays find the max from those subarrays",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n        n = len(nums)\n        for i in range(n):\n            sm = 0\n            for j in range(n):\n                idx = (i + j) % n\n                sm += nums[idx]\n                mx_sum = max(sm, mx_sum)\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "rotate the array by one find max sum subarray keep track of global sum subarray",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        curr_sum = 0\n        global_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        return global_sum\n\n    def rotateByOne(self, nums: list[int]) -> None:\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            mx_sum = max(mx_sum, self.maxSubArray(nums))\n\n        return mx_sum",
                "type": "Brute"
            },
            {
                "tc": "-",
                "sc": "O(1)",
                "intuition": "Suppose consider the below array\na b c d e f g h i j k l m\n------- --------- -------\nmax-sum min-sum(b) max-sum(a)\n-------------------------- total-sum(s)\nproof -> We know that a+b = S\nwe are claiming that b is the min sum\nbut suppose we say that in order to make b\nthe min sum, we need to reduce the value of b\nif we are reducing the value of b then we have\nto increase the value of a to inorder to balance\nout the sum , but wait a is already max sum we cannot\nincrease its value , so by contradiction its proven right\nthat b is the min sum\nbut whenever my total sum and min-sum is the same, then return\nthe normal sum , Egde case [-1,-2,-3] here the circular sum\nbecomes 0",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        total_sum = 0\n\n        curr_min_sum = 0\n        min_sum = sys.maxsize\n\n        curr_max_sum = 0\n        max_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            total_sum += nums[i]\n\n            curr_min_sum = min(nums[i], curr_min_sum + nums[i])\n            min_sum = min(min_sum, curr_min_sum)\n\n            curr_max_sum = max(nums[i], curr_max_sum + nums[i])\n            max_sum = max(max_sum, curr_max_sum)\n\n        circular_sum = total_sum - min_sum\n\n        if total_sum == min_sum:\n            return max_sum\n\n        return max(circular_sum, max_sum)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 45,
        "question": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\n\nExample 1:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\nExample 2:\n\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n\n\nConstraints:\n\n1 <= nums.length <= 2 * 10^4\n-10 <= nums[i] <= 10\nThe product of any subarray of nums is guaranteed to fit in a 32-bit integer.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Maximum Product Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/47_Maximum_Product_Subarray.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all sub arrays and find the max product from it",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        mx_prod = -sys.maxsize\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod *= nums[j]\n                mx_prod = max(mx_prod, prod)\n        return mx_prod",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Observation 1 : if array has all postive then just return the prod of entire array\nObservation 2: if array has even nos of negative just return the prod of entire array\nObservation 3: if array has odd no of negatives just remove one negative (leaving us with even negative) and the answer will lie in either suffix or prefix\nObservation 4: if we have zero then we will not carry it over as it will reduce our maximum product , we will suffix,prefix to 1,1\nTo find the answer, we will check all possible prefix subarrays (starting from index 0) and all possible suffix subarrays (starting from index n-1)\nThe maximum product obtained from these prefix and suffix subarrays will be our final answer.",
                "code": "import sys\nfrom typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        pref = 1\n        suff = 1\n        n = len(nums)\n        mx_prod = -sys.maxsize\n\n        for i in range(len(nums)):\n            if pref == 0:\n                pref = 1\n            if suff == 0:\n                suff = 1\n\n            pref *= nums[i]\n            suff *= nums[n - i - 1]\n\n            mx_prod = max(mx_prod, pref, suff)\n\n        return mx_prod",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 46,
        "question": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\n\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\n\nConstraints:\n\n2 <= nums.length <= 10^5\n-30 <= nums[i] <= 30\nThe input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.\n\n\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Product of array except itself",
        "problem_link": "https://leetcode.com/problems/product-of-array-except-self",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/48_Product_of_array_except_itself.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Find the product of each number except itself using 2 loops",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = []\n\n        for i in range(n):\n            p = 1\n            for j in range(n):\n                if i == j:\n                    continue\n                p *= nums[j]\n            ans.append(p)\n\n        return ans",
                "type": "Brute"
            },
            {
                "tc": "O(N)+O(N)+O(N)",
                "sc": "O(N)+O(N)",
                "intuition": "Product of array except itself for an ith number is nothing but product of prefix sum till i-1 and suffix sum i+1 Example : [1 2 3 4 5 6] Prod of 3 excpe itself is => 1*2 * 4*5*6 --   ----- pref  suff",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        pref = [1] * n\n        for i in range(1, n):\n            pref[i] = pref[i - 1] * nums[i - 1]\n\n        suff = [1] * n\n        for i in range(n - 2, -1, -1):\n            suff[i] = suff[i + 1] * nums[i + 1]\n\n        ans = [1] * n\n        for i in range(n):\n            ans[i] = pref[i] * suff[i]\n\n        return ans",
                "type": "Better"
            },
            {
                "tc": "O(N)+O(N)",
                "sc": "O(1)",
                "intuition": "Fill the result array on the fly\nfirst put the prefix part in the result\nthen put suffix part in the result",
                "code": "from typing import List\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [1] * n\n\n        pref = 1\n        for i in range(n):\n            ans[i] = pref\n            pref *= nums[i]\n\n        suff = 1\n        for j in range(n - 1, -1, -1):\n            ans[j] *= suff\n            suff *= nums[j]\n\n        return ans",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 47,
        "question": "Given two sorted arrays a[] and b[] of size n and m respectively, the task is to merge them in sorted order\nwithout using any extra space. Modify a[] so that it contains the first n elements and modify b[] so that it contains the last m elements.\n\nExamples:\n\nInput: a[] = [2, 4, 7, 10], b[] = [2, 3]\nOutput:\n2 2 3 4\n7 10\nExplanation: After merging the two non-decreasing arrays, we get, 2 2 3 4 7 10\n\nInput: a[] = [1, 5, 9, 10, 15, 20], b[] = [2, 3, 8, 13]\nOutput:\n1 2 3 5 8 9\n10 13 15 20\nExplanation: After merging two sorted arrays we get 1 2 3 5 8 9 10 13 15 20.\n\nInput: a[] = [0, 1], b[] = [2, 3]\nOutput:\n0 1\n2 3\nExplanation: After merging two sorted arrays we get 0 1 2 3.\n\nConstraints:\n1 <= a.size(), b.size() <= 10^5\n0 <= a[i], b[i] <= 10^7",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Merge Sorted Array Without Extra Space",
        "problem_link": "https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/49_Merge_Sorted_Array_Without_Extra_Space.py",
        "approaches": [
            {
                "tc": "N*log(N))",
                "sc": "O(1)",
                "intuition": "use 2 pointers\nfix one pointer to the last index of 1st array\nfix another pointer to the first index if 2nd array\nkeep comparing if the j is smaller than i swap\notherwise break",
                "code": "class Solution:\n    def mergeArrays(self, a: list[int], b: list[int]) -> None:\n        i = len(a) - 1\n        j = 0\n\n        while i >= 0 and j < len(b) and b[j] < a[i]:\n            b[j], a[i] = a[i], b[j]\n            j += 1\n            i -= 1\n\n        a.sort()\n        b.sort()",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 48,
        "question": "Given an array of integers arr[]. Find the Inversion Count in the array.\nTwo elements arr[i] and arr[j] form an inversion if arr[i] > arr[j] and i < j.\n\nInversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If the array is already sorted then the inversion count is 0.\nIf an array is sorted in the reverse order then the inversion count is the maximum.\n\nExamples:\n\nInput: arr[] = [2, 4, 1, 3, 5]\nOutput: 3\nExplanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).\n\nInput: arr[] = [2, 3, 4, 5, 6]\nOutput: 0\nExplanation: As the sequence is already sorted so there is no inversion count.\n\nInput: arr[] = [10, 10, 10]\nOutput: 0\nExplanation: As all the elements of array are same, so there is no inversion count.\n\nConstraints:\n1 \u2264 arr.size() \u2264 10^5\n1 \u2264 arr[i] \u2264 10^4",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Count Inversions",
        "problem_link": "https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/50_Count_Inversions.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays and find the subarray with the matching condition",
                "code": "class Solution:\n    def inversionCount(self, arr):\n        c = 0\n        for i in range(len(arr)):\n            for j in range(len(arr)):\n                if i < j and arr[i] > arr[j]:\n                    c += 1\n        return c",
                "type": "Brute"
            },
            {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,2)(5,3),(5,4)\nwill form pair right as i<j and arr[i]>arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        i, j = l, mid + 1\n        tmp = []\n\n        c = 0\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                c += mid - i + 1  # include all the farther ahead elements too\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def inversionCount(self, arr: list[int]) -> int:\n        return self.mergeSort(0, len(arr) - 1, arr)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 49,
        "question": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].\n\n\nExample 1:\n\nInput: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\nExample 2:\n\nInput: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1\n\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-2^31 <= nums[i] <= 2^31 - 1",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Hard",
        "difficulty_num": 3,
        "problem_name": "Reverse Pairs",
        "problem_link": "https://leetcode.com/problems/reverse-pairs",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/51_Reverse_Pairs.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all pairs and check which pairs follow the condition",
                "code": "from typing import List\n\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        c = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j] * 2:\n                    c += 1\n        return c",
                "type": "Brute"
            },
            {
                "tc": "O(NlogN)",
                "sc": "O(N)",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,1)(5,2)\nwill form pair right as i<j and arr[i]>2*arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        c = 0\n        i, j = l, mid + 1\n        while i <= mid and j <= h:  #  check the condition before performing merge sort\n            if arr[i] > 2 * arr[j]:\n                c += (mid - i) + 1\n                j += 1\n            else:\n                i += 1\n\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def reversePairs(self, nums: List[int]) -> int:\n        return self.mergeSort(0, len(nums) - 1, nums)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 50,
        "question": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician\nJohn Horton Conway in 1970.\"\n\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0).\nEach cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of\nthe m x n grid board. In this process, births and deaths occur simultaneously.\n\nGiven the current state of the board, update the board to reflect its next state.\n\nNote that you do not need to return anything.\n\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\nExample 2:\n\n\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n\n\nConstraints:\n\nm == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Game of Life",
        "problem_link": "https://leetcode.com/problems/game-of-life",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/52_Game_of_Life.py",
        "approaches": [
            {
                "tc": "O(M*N*8)",
                "sc": "O(M*N)",
                "intuition": "Live cell with less than 2 live neighbors die Live cell with more than 2 or 3 live neighbors live Live cell with more than 3 live die Dead cell ressurects with exactly 3 live neighbors",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] == 1:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        ans = [[0 for _ in range(len(board[0]))] for _ in range(len(board))]\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        ans[i][j] = 0\n                    else:\n                        ans[i][j] = 1\n                else:\n                    if live_neighbor_count == 3:\n                        ans[i][j] = 1\n\n        board[::] = ans",
                "type": "Brute"
            },
            {
                "tc": "O(M*N)",
                "sc": "O(1)",
                "intuition": "we try to preserve the original values of each state\nmark the cell that was alive but will die as -2\nmark the cell that was dead but ressurects with 2",
                "code": "from typing import List\n\n\nclass Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] in [1, -2]:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        board[i][j] = -2\n                else:\n                    if live_neighbor_count == 3:\n                        board[i][j] = 2\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == -2:\n                    board[i][j] = 0\n                elif board[i][j] == 2:\n                    board[i][j] = 1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 51,
        "question": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper,\nreturn the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the\nmaximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\n\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "H Index",
        "problem_link": "https://leetcode.com/problems/h-index",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/53_H_Index.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Do i have h papers that has been cited h times start with 0 and keep increasing the index by 1 and check if there can be h-index of i sice we have an array of size n, the max h-index can be n",
                "code": "from typing import List\n\n\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        h_index = 0\n\n        for i in range(1, len(citations) + 1):\n            c = 0\n            for j in range(len(citations)):\n                if citations[j] >= i:\n                    c += 1\n                if c == i:\n                    h_index = i\n                    break\n\n        return h_index",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "we use a counting sort techique to solve this problem\nfirst we create an array of size n+1\neach index in the array represents the count of paper having i citaions\nsince we can have citations more than size of the array for those cases\nwe are going to use the last index of the array to store count\nwe start iterating from back of the array and check whether we have\npapers more than i value or not if we have then we just return i",
                "code": "from typing import List\n\n\nclass Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        count_arr = [0] * (len(citations) + 1)\n\n        for i in range(len(citations)):\n            if citations[i] >= len(citations):\n                count_arr[len(citations)] += 1\n            else:\n                count_arr[citations[i]] += 1\n\n        paper_count = 0\n        for i in range(len(count_arr) - 1, -1, -1):\n            paper_count += count_arr[i]\n            if paper_count >= i:\n                return i\n\n        return 0",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 52,
        "question": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\nbool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\nint getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n\nExample 1:\n\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\nConstraints:\n\n-2^31 <= val <= 2^31 - 1\nAt most 2 * 10^5 calls will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.",
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Insert Delete GetRandom O(1)",
        "problem_link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/54_Insert_Delete_GetRandom_O(1).py",
        "approaches": [
            {
                "tc": "O(1)",
                "sc": "O(N)+O(N)",
                "intuition": "",
                "code": "import random\n\n\nclass RandomizedSet:\n\n    def __init__(self):\n        self.indices: dict[int, int] = {}\n        self.vals: list[int] = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.indices:\n            return False\n\n        self.indices[val] = len(self.vals)\n        self.vals.append(val)\n\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.indices:\n            return False\n\n        # Swap the last element with this val\n        delete_element_idx = self.indices[val]\n        last_element_idx = len(self.vals) - 1\n\n        self.vals[delete_element_idx], self.vals[last_element_idx] = (\n            self.vals[last_element_idx],\n            self.vals[delete_element_idx],\n        )\n\n        # Update the index of the last element\n        self.indices[self.vals[delete_element_idx]] = delete_element_idx\n\n        self.vals.pop(-1)\n        del self.indices[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.vals)",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 1,
        "question": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\n\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\n\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\n\nExample 1:\n\nInput: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation:\nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\nExample 2:\n\nInput: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation:\nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\nExample 3:\n\nInput: s = \"()()\"\nOutput: \"\"\nExplanation:\nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n\n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Remove Outermost Parentheses",
        "problem_link": "https://leetcode.com/problems/remove-outermost-parentheses",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/1_Remove_Outermost_Parentheses.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "Suppose we have an input case : s = \"(()())(())(()(()))\"\n\n(()()) Part1\n121210\n\n(()) Part2\n1210\n\n(()(())) Part3\n12123210\n\nThere is a pattern,\n+ if depth count is 1 and if its opening brace then it is the outermost opening brace\n+ if depth count is 0 and its closing brace, it is the outermost closing brace",
                "code": "class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        depthCount: int = 0\n        res: str = \"\"\n\n        for char in s:\n\n            if char == \"(\":\n                depthCount += 1\n\n            elif char == \")\":\n                depthCount -= 1\n\n            if depthCount == 1 and char == \"(\":\n                continue\n\n            if depthCount == 0 and char == \")\":\n                continue\n\n            res += char\n\n        return res",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 2,
        "question": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.\n\n\nExample 1:\n\nInput: s = \"(1+(2*3)+((8)/4))+1\"\n\nOutput: 3\n\nExplanation:\n\nDigit 8 is inside of 3 nested parentheses in the string.\n\nExample 2:\n\nInput: s = \"(1)+((2))+(((3)))\"\n\nOutput: 3\n\nExplanation:\n\nDigit 3 is inside of 3 nested parentheses in the string.\n\nExample 3:\n\nInput: s = \"()(())((()()))\"\n\nOutput: 3\n\n\nConstraints:\n\n1 <= s.length <= 100\ns consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.\nIt is guaranteed that parentheses expression s is a VPS.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Maximum Nesting Depth of the Parentheses",
        "problem_link": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/2_Maximum_Nesting_Depth_of_the_Parentheses.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "maintain a depth count\nif its an open parentheses add one\nif its a closed parentheses decrement one\nthe max count throught the process will be the max depth",
                "code": "class Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n\n        for char in s:\n            if char == \"(\":\n                depth += 1\n            elif char == \")\":\n                depth -= 1\n            max_depth = max(max_depth, depth)\n\n        return max_depth",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 3,
        "question": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\n\nReturn a string of the words in reverse order concatenated by a single space.\n\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n\nExample 1:\n\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\nExample 2:\n\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\nExample 3:\n\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\nConstraints:\n\n1 <= s.length <= 10^4\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
        "topic": "String",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Reverse words in a given string",
        "problem_link": "https://leetcode.com/problems/reverse-words-in-a-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/3_Reverse_words_in_a_given_string.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "extract only words from string and put them into the list reverse the list return the list by using join keyword",
                "code": "class Solution:\n    def split_string_to_words(self, s: str) -> list[str]:\n        words: list[str] = []\n        tmp: str = \"\"\n\n        for i in range(len(s)):\n            if s[i] == \" \":\n                if tmp:\n                    words.append(tmp)\n                    tmp = \"\"\n            else:\n                tmp += s[i]\n\n        if tmp:\n            words.append(tmp)\n\n        return words\n\n    def reverse_list(self, words: list[str]):\n        i, j = 0, len(words) - 1\n\n        while i < j:\n            words[i], words[j] = words[j], words[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        words = self.split_string_to_words(s)\n        self.reverse_list(words)\n        return \" \".join(words)",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "use pythons builtin split to split into words then reverse the list return the reversed list using join keyword",
                "code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(s.split()[::-1])",
                "type": "Better"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "reverse whole string first\nTake 2 pointers l and r it will be used to reverse words between them\nkeep moving i until you reach non space character , then assign the character at ith index with the character at r index\nwhen we encounter space , reverse words between l and r index\nmove r to one place after space and assign l to r, repeat the above process until i exhauts the string",
                "code": "class Solution:\n    def rev(self, i: int, j: int, s: list[str]):\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        mutable_str = list(s)\n\n        self.rev(0, len(mutable_str) - 1, mutable_str)\n\n        l, r = 0, 0  # will be used for reversing string\n        i = 0  # will be used to traverse string\n        # r will be used for writing\n\n        while i < len(mutable_str):\n            while i < len(mutable_str) and mutable_str[i] != \" \":\n                mutable_str[r] = mutable_str[i]\n                i += 1\n                r += 1\n\n            if l < r:\n                self.rev(l, r - 1, mutable_str)\n                mutable_str[r] = \" \"\n                r += 1\n                l = r\n\n            i += 1\n\n        return \"\".join(mutable_str[: r - 1])",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 4,
        "question": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that\nis a non-empty substring of num, or an empty string \"\" if no odd integer exists.\nA substring is a contiguous sequence of characters within a string.\n\nExample 1:\n\nInput: num = \"52\"\nOutput: \"5\"\nExplanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number.\nExample 2:\n\nInput: num = \"4206\"\nOutput: \"\"\nExplanation: There are no odd numbers in \"4206\".\nExample 3:\n\nInput: num = \"35427\"\nOutput: \"35427\"\nExplanation: \"35427\" is already an odd number.\n\n\nConstraints:\n\n1 <= num.length <= 10^5\nnum only consists of digits and does not contain any leading zeros.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Largest Odd Number in string",
        "problem_link": "https://leetcode.com/problems/largest-odd-number-in-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/4_Largest_Odd_Number_in_string.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "An odd number ends with either 1,3,5,7,9\nwe want the largest-valued odd number in\nthe string, so if we traverse from back of the string\nand find the first number that is not divisible by\n2 that will give us the larges possible odd number\nsubstring from the given input string",
                "code": "class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        for i in range(len(num) - 1, -1, -1):\n            if int(num[i]) % 2 != 0:\n                return num[: i + 1]\n        return \"\"",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 5,
        "question": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters if it is non-empty.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Longest Common Prefix",
        "problem_link": "https://leetcode.com/problems/longest-common-prefix",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/5_Longest_Common_Prefix.py",
        "approaches": [
            {
                "tc": "O(S)",
                "sc": "O(1)",
                "intuition": "Take a comparison string suppose the first word in strs\nKeep checking each character of the comparison_str , whether its\npresent in all words in the strs or not, if any time the char is\nnot common or the character index is greater than length of the\nword we return as from that moment onwards we dont have longest\nprefix substring",
                "code": "from typing import List\n\n\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if len(strs) == 1:\n            return strs[0]\n\n        comparison_str = strs[0]\n        lcp = \"\"\n\n        for i, char in enumerate(comparison_str):\n            is_char_common = True\n            for st in strs:\n                if i + 1 > len(st) or st[i] != char:\n                    is_char_common = False\n                    return lcp\n            if is_char_common:\n                lcp += char\n\n        return lcp",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 6,
        "question": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters.\nNo two characters may map to the same character, but a character may map to itself.\n\n\nExample 1:\n\nInput: s = \"egg\", t = \"add\"\n\nOutput: true\n\nExplanation:\n\nThe strings s and t can be made identical by:\n\nMapping 'e' to 'a'.\nMapping 'g' to 'd'.\nExample 2:\n\nInput: s = \"foo\", t = \"bar\"\n\nOutput: false\n\nExplanation:\n\nThe strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.\n\nExample 3:\n\nInput: s = \"paper\", t = \"title\"\n\nOutput: true\n\n\nConstraints:\n\n1 <= s.length <= 5 * 10^4\nt.length == s.length\ns and t consist of any valid ascii character.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Isomorphic Strings",
        "problem_link": "https://leetcode.com/problems/isomorphic-strings",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/6_Isomorphic_Strings.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(2N)",
                "intuition": "Just keep 2 hashmaps and assign a char of s to t and vice versa\nif a already assigned char from c does not matches with\nt and vice versa, return False otherwise at the end return True",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        cmap1, cmap2 = {}, {}\n\n        for i in range(len(s)):\n            c1 = s[i]\n            c2 = t[i]\n\n            if (c1 in cmap1 and cmap1[c1] != c2) or (c2 in cmap2 and cmap2[c2] != c1):\n                return False\n\n            cmap1[c1] = c2\n            cmap2[c2] = c1\n\n        return True",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 7,
        "question": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false\n\n\nConstraints:\n\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.\n\n\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Valid Anagram",
        "problem_link": "https://leetcode.com/problems/valid-anagram",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/7_Valid_Anagram.py",
        "approaches": [
            {
                "tc": "O(S)",
                "sc": "O(S)+O(T)",
                "intuition": "Just compare the frequency map of\nthe 2 strings",
                "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        freq_map_s = {}\n        freq_map_t = {}\n\n        for i in range(len(s)):\n            freq_map_s[s[i]] = 1 + freq_map_s.get(s[i], 0)\n            freq_map_t[t[i]] = 1 + freq_map_t.get(t[i], 0)\n\n        return freq_map_s == freq_map_t",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 8,
        "question": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n\nExample 1:\n\nInput: s = \"abcde\", goal = \"cdeab\"\nOutput: true\nExample 2:\n\nInput: s = \"abcde\", goal = \"abced\"\nOutput: false\n\n\nConstraints:\n\n1 <= s.length, goal.length <= 100\ns and goal consist of lowercase English letters.",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Rotate String",
        "problem_link": "https://leetcode.com/problems/rotate-string",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/8_Rotate_String.py",
        "approaches": [
            {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep rotating the string by 1 if at any point we reach the goal string return True",
                "code": "class Solution:\n    def rotate_by_one(self, s: list[str]) -> str:\n        for i in range(len(s) - 1):\n            s[i], s[i + 1] = s[i + 1], s[i]\n        return \"\".join(s)\n\n    def rotateString(self, s: str, goal: str) -> bool:\n        for _ in range(len(s)):\n            s = self.rotate_by_one(list(s))\n            if s == goal:\n                return True\n\n        return False",
                "type": "Brute"
            },
            {
                "tc": "O(N)",
                "sc": "O(1)",
                "intuition": "double concatentate the input string\nand check whether the goal exits in the\nconcatentated string",
                "code": "class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        if len(s) != len(goal):\n            return False\n\n        concatenated = s + s\n\n        return concatenated.find(goal) != -1",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 9,
        "question": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "difficulty_num": 1,
        "problem_name": "Roman to Integer",
        "problem_link": "https://leetcode.com/problems/roman-to-integer",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/9_Roman_to_Integer.py",
        "approaches": [
            {
                "tc": "O(N)",
                "sc": "O(7)",
                "intuition": "Keep iterating and Keep track of the final val\nsince roman nums are written from largest to smallest keep addding the\ncurrrent characters val if curr_char is lesser than prev_char , but\nif curr_char is greater then prev_char take out the prev_char from\nfinal val and add (curr_char-prev_char) to the final val",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_num_map = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000,\n        }\n\n        val: int = 0\n        val += roman_num_map[s[0]]\n\n        for i in range(1, len(s)):\n            curr_char: str = s[i]\n            prev_char: str = s[i - 1]\n\n            if roman_num_map[curr_char] > roman_num_map[prev_char]:\n                val -= roman_num_map[prev_char]\n                val += roman_num_map[curr_char] - roman_num_map[prev_char]\n            else:\n                val += roman_num_map[curr_char]\n\n        return val",
                "type": "Optimal"
            }
        ]
    },
    {
        "id": 10,
        "question": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t10\nL\t50\nC\t100\nD\t500\nM\t1000\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\nIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\nGiven an integer, convert it to a Roman numeral.\n\n\nExample 1:\n\nInput: num = 3749\n\nOutput: \"MMMDCCXLIX\"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n700 = DCC as 500 (D) + 100 (C) + 100 (C)\n40 = XL as 10 (X) less of 50 (L)\n9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\nExample 2:\n\nInput: num = 58\n\nOutput: \"LVIII\"\n\nExplanation:\n\n50 = L\n8 = VIII\nExample 3:\n\nInput: num = 1994\n\nOutput: \"MCMXCIV\"\n\nExplanation:\n\n1000 = M\n900 = CM\n90 = XC\n4 = IV\n\n\nConstraints:\n\n1 <= num <= 3999",
        "topic": "String",
        "language": "python",
        "difficulty": "Medium",
        "difficulty_num": 2,
        "problem_name": "Integer to Roman",
        "problem_link": "https://leetcode.com/problems/integer-to-roman",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/10_Integer_to_Roman.py",
        "approaches": [
            {
                "tc": "-",
                "sc": "-",
                "intuition": "",
                "code": "",
                "type": "Brute"
            },
            {
                "tc": "-",
                "sc": "-",
                "intuition": "",
                "code": "",
                "type": "Better"
            },
            {
                "tc": "-",
                "sc": "-",
                "intuition": "",
                "code": "",
                "type": "Optimal"
            }
        ]
    }
]