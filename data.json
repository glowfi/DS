[
    {
        "id": 1,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Selection Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/selection-sort/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/1_Selection_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "question": "Given an array arr, use selection sort to sort arr[] in increasing order.  Examples :  Input: arr[] = [4, 1, 3, 9, 7] Output: [1, 3, 4, 7, 9] Explanation: Maintain sorted (in bold) and unsorted subarrays. Select 1. Array becomes 1 4 3 9 7. Select 3.  Array becomes 1 3 4 9 7. Select 4. Array becomes 1 3 4 9 7. Select 7. Array becomes 1 3 4 7 9. Select 9. Array becomes 1 3 4 7 9.  Input: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  Input: arr[] = [38, 31, 20, 14, 30] Output: [14, 20, 30, 31, 38]  Constraints: 1 \u2264 arr.size() \u2264 10^3 1 \u2264 arr[i] \u2264 10^6",
                "intuition": "This is an unstable sorting algorithm but can be made stable to maintain relative\nordering of element but will increase time complexity.\nThis algorithms worst,best,avg time complexity is O(N^2)\nIn each iteration place the minimum/maximum most element to its correct place.\nFor example for ascending in 1st iteration place the most minimum to 0th index\n, next iteration 2nd minimum to 1st index like this.",
                "code": "class Solution:\n    def selectionSort(self, arr: list[int]):\n        for i in range(len(arr)):\n            min_idx = i\n            for j in range(i, len(arr)):\n                if arr[j] < arr[min_idx]:\n                    min_idx = j\n            arr[i], arr[min_idx] = arr[min_idx], arr[i]"
            }
        }
    },
    {
        "id": 2,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Bubble Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/bubble-sort/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/2_Bubble_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "question": "Given an array, arr[]. Sort the array using bubble sort algorithm.  Examples :  Input: arr[] = [4, 1, 3, 9, 7] Output: [1, 3, 4, 7, 9]  Input: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  Input: arr[] = [1, 2, 3, 4, 5] Output: [1, 2, 3, 4, 5]  Explanation: An array that is already sorted should remain unchanged after applying bubble sort.  Constraints: 1 <= arr.size() <= 10^3 1 <= arr[i] <= 10^3",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.This is a stable\nsorting algo.\nIn each iteration place the minimum/maximum most element to the end of\nthe array making swaps on the go.For example , for ascending order in\nfirst iteration the most maximum will be placed at last,then next iteration\n2nd maximum will be placed at 2nd last index like this.",
                "code": "class Solution:\n    # Function to sort the array using bubble sort algorithm.\n    def bubbleSort(self, arr: list[int]):\n        for i in range(\n            len(arr) - 1\n        ):  # since at last iteration last element will be at its correct place\n            did_swap = False\n            for j in range(0, len(arr) - i - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                    did_swap = True\n\n            if not did_swap:  # if array is sorted no swaps will take place\n                break"
            }
        }
    },
    {
        "id": 3,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Insertion Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/insertion-sort/0 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/3_Insertion_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "question": "The task is to complete the insertsort() function which is used to implement Insertion Sort.  Examples:  Input: arr[] = [4, 1, 3, 9, 7] Output: [1, 3, 4, 7, 9] Explanation: The sorted array will be [1, 3, 4, 7, 9].  Input: arr[] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Explanation: The sorted array will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].  Input: arr[] = [4, 1, 9] Output: [1, 4, 9] Explanation: The sorted array will be [1, 4, 9].  Constraints: 1 <= arr.size() <= 1000 1 <= arr[i] <= 1000",
                "intuition": "This algorithms worst,avg time complexity is O(N^2) and best time complexity\nis O(N) when array is already sorted there will be no swaps.\nThis is a stable sorting algo.\nIn this algorithm in every pass we try to place the\nnumber at its correct position,from the current position\nin which the number is in we try to check with its left\nneighbours whether its lesser than its left neighbour,\nif its lesser than its left neighbour we swap places\nwe keep doing it unitl its placed in its correct place",
                "code": "class Solution:\n    def insertionSort(self, arr: list[int]):\n        # we start from 1 index as 1 does not have any left neighbours\n        for i in range(1, len(arr)):\n            j = i\n            while j > 0 and arr[j] < arr[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                j -= 1\n\n        return arr"
            }
        }
    },
    {
        "id": 4,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Merge Sort",
        "problem_link": "https://leetcode.com/problems/sort-an-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/4_Merge_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(Nlog(N))",
                "sc": "O(N)+O(N)",
                "question": "Given an array of integers nums, sort the array in ascending order and return it.  You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.  Example 1:  Input: nums = [5,2,3,1] Output: [1,2,3,5] Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).  Example 2:  Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Explanation: Note that the values of nums are not necessairly unique.  Constraints:  1 <= nums.length <= 5 * 10^4 -5 * 10^4 <= nums[i] <= 5 * 10^4",
                "intuition": "This algorithms worst,avg,best time complexity is O(Nlog(N)).\nThis also use a recursion stack space of O(N) and O(N) auxiliary space to\nstore array elements.\nThis is a stable sorting algo.\nWe follow a divide and conquer strategy we keep divind the\narray into 2 equal halves until they cannot be divided or we are left with array with one element\nand then we keep on merging the two halves until no subarrays are left.\n\nfrom typing import List",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> None:\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> None:\n        if l >= h:  # array has 1 element\n            return\n\n        mid = (l + h) // 2\n\n        self.mergeSort(l, mid, arr)\n        self.mergeSort(mid + 1, h, arr)\n        self.merge(l, mid, h, arr)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(0, len(nums) - 1, nums)\n        return nums"
            }
        }
    },
    {
        "id": 5,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Quick Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/quick-sort/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/5_Quick_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "question": "Implement Quick Sort, a Divide and Conquer algorithm, to sort an array, arr[] in ascending order. Given an array, arr[], with starting index low and ending index high, complete the functions partition() and quickSort(). Use the last element as the pivot so that all elements less than or equal to the pivot come before it, and elements greater than the pivot follow it.  Note: The low and high are inclusive.  Examples:  Input: arr[] = [4, 1, 3, 9, 7] Output: [1, 3, 4, 7, 9] Explanation: After sorting, all elements are arranged in ascending order.  Input: arr[] = [2, 1, 6, 10, 4, 1, 3, 9, 7] Output: [1, 1, 2, 3, 4, 6, 7, 9, 10] Explanation: Duplicate elements (1) are retained in sorted order.  Input: arr[] = [5, 5, 5, 5] Output: [5, 5, 5, 5] Explanation: All elements are identical, so the array remains unchanged.  Constraints: 1 <= arr.size() <= 10^5 1 <= arr[i] <= 10^5",
                "intuition": "This algorithms avg,best time complexity is O(Nlog(N)) and worst case\ntime complexity is O(N^2).\nThis is a unstable sorting algo.\nWe pick a pivot,pivot can be first,last element.we try to place all\nthe elements smaller to pivot to its left and bigger to right,\nnow this two partions (left and right) created are sorted recursively with the same logic.\ntake 2 pointers i and j i points to start and j points to end given in the function call.\nfor finding pivot find the first smallest from right anf first biggest from left.\nkeep doing this till i<j and swap after every finding of these two position.\natlast place pivot at its correct place swap pivot with j and return j.",
                "code": "class Solution:\n    # Function to sort a list using quick sort algorithm.\n    def quickSort(self, arr: list[int], low: int, high: int):\n        if low >= high:  # return if has only one element\n            return\n\n        pivot = self.partitionv2(arr, low, high)\n        self.quickSort(arr, low, pivot - 1)\n        self.quickSort(arr, pivot + 1, high)\n\n    def partitionv2(self, arr: list[int], low: int, high: int) -> int:  # algorithmic\n        i, j = low, high\n        pivot = arr[low]\n\n        while i < j:\n            # bigger from left\n            while i < high and arr[i] <= pivot:\n                i += 1\n\n            # smaller from right\n            while j > low and arr[j] > pivot:\n                j -= 1\n\n            # swap only of i<j\n            if i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n\n        # place the pivot in its correct place\n        arr[low], arr[j] = arr[j], arr[low]\n\n        return j\n\n    # Naive way of partitioning [last as pivot]\n    def partitionv1_0(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[high]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low, high):  # ignore the last element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)\n\n    # Naive way of partitioning [first as pivot]\n    def partitionv1_1(self, arr: list[int], low: int, high: int) -> int:\n        piv = arr[low]\n        left_arr = []\n        right_arr = []\n\n        for i in range(low + 1, high + 1):  # ignore the first element\n            if arr[i] <= piv:\n                left_arr.append(arr[i])\n            else:\n                right_arr.append(arr[i])\n\n        tmp_arr = [*left_arr, piv, *right_arr]\n\n        idx = 0\n        for i in range(low, high + 1):\n            arr[i] = tmp_arr[idx]\n            idx += 1\n\n        return low + len(left_arr)"
            }
        }
    },
    {
        "id": 6,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Count Sort",
        "problem_link": "https://www.geeksforgeeks.org/problems/counting-sort/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/6_Count_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N+26)",
                "sc": "O(26)+O(N)",
                "question": "Given a string arr consisting of lowercase english letters, arrange all its letters in lexicographical order using Counting Sort.  Example 1:  Input: N = 5 S = \"edsab\" Output: abdes Explanation: In lexicographical order, string will be abdes. Example 2:  Input: N = 13 S = \"geeksforgeeks\" Output: eeeefggkkorss Explanation: In lexicographical order, string will be eeeefggkkorss. Your Task: This is a function problem. You only need to complete the function countSort() that takes string arr as a parameter and returns the sorted string. The printing is done by the driver code.  Expected Time Complexity: O(N). Expected Auxiliary Space: O(N).  Constraints: 1 \u2264 N \u2264 10^5",
                "intuition": "This is a non comparison basesd algo\nThis algo work best when all input elements are within a given range k.\nThis algorithms avg,best,worst time complexity is O(Nlog(N)) and worst case\nThis is a unstable sorting algo.\ncreate a count array of size either max element+1 or given k+1\nstore the frequence of each element in the count array\nthen replace everything in the count array with prefix sum\nsuch that count[i]=count[i]+count[i-1]\nloop from back of the input array suppose we enconter number 2\nin our input array then we go to the index 2 in the count array\nthe value at that index 2 will gives us where to place 2 in the final output array\ndecrement count of 2 in the count array\nplace the 2 in that index postion got from count array",
                "code": "class Solution:\n    def countSort(self, arr: list[str]):\n        count_arr = [0] * 27\n\n        # calculate frequency\n        for char in arr:\n            count_arr[ord(char) - 97] += 1\n\n        # calculate prefix sum\n        for i in range(1, len(count_arr)):\n            count_arr[i] = count_arr[i] + count_arr[i - 1]\n\n        # build output array\n        out = [\"\"] * len(arr)\n        for i in range(len(arr) - 1, -1, -1):\n            num = ord(arr[i]) - 97\n            count_arr[num] -= 1\n            out[count_arr[num]] = arr[i]\n\n        return \"\".join(out)"
            }
        }
    },
    {
        "id": 7,
        "topic": "Sorting",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Cyclic Sort",
        "problem_link": "NA ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/1_Sorting/7_Cyclic_Sort.py",
        "approaches": {
            "Optimal": {
                "tc": "1+n) ~ O(N)",
                "sc": "O(1)",
                "question": "You are given an integer array nums containing n + 1 integers where each integer is in the range [1, n]. There is only one duplicate number in the array, but it could be repeated more than once. You must solve the problem without modifying the input array and using O(1) extra space.   Input: nums = [3, 1, 4, 2] Output: [1, 2, 3, 4]  Input: nums = [1, 3, 4, 2] Output: [1, 2, 3, 4]  Input: nums = [2, 1, 3] Output: [1, 2, 3]",
                "intuition": "Check whether current number is at its correct index\nThis algorithm works for small ranged numbers\nmust be in range of 1 to N or 0 to N\nFor one based indexing , correct index of number is val-1\nFor one based indexing , element at index i should be at i+1\nFor zero based indexing , correct index of number is val\nFor zero based indexing , element at index i should be at i\nAlways remember -> ignore numbers greater than size of array for zero based indexing\nAlways remember -> cyclic sort will make the duplicate numbers go at wrong place\nAlways remember -> duplicate numbers will not be at its correct place say i , then nums[i] is the duplicate and i+1 is missing\n\nfrom typing import List",
                "code": "def cyclic_sort(nums: List[int]) -> None:\n    i = 0\n    while i < len(nums):\n        actualPos = nums[i] - 1\n        if nums[actualPos] != nums[i]:\n            nums[i], nums[actualPos] = nums[actualPos], nums[i]\n        else:\n            i += 1\n\n\nif __name__ == \"__main__\":\n    # Test cases\n    nums1 = [3, 1, 4, 2]\n    cyclic_sort(nums1)\n    assert nums1 == [1, 2, 3, 4], f\"Test case 1 failed: expected [1, 2, 3], got {nums1}\"\n\n    nums2 = [1, 3, 4, 2]\n    cyclic_sort(nums2)\n    assert nums2 == [1, 2, 3, 4], f\"Test case 2 failed: expected [1, 2, 3], got {nums2}\"\n\n    nums3 = [2, 1, 3]\n    cyclic_sort(nums3)\n    assert nums3 == [1, 2, 3], f\"Test case 3 failed: expected [1, 2, 3], got {nums3}\"\n\n    nums4 = [4, 3, 2, 1]\n    cyclic_sort(nums4)\n    assert nums4 == [\n        1,\n        2,\n        3,\n        4,\n    ], f\"Test case 4 failed: expected [1, 2, 3, 4], got {nums4}\"\n\n    nums5 = [5, 4, 3, 2, 1]\n    cyclic_sort(nums5)\n    assert nums5 == [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ], f\"Test case 5 failed: expected [1, 2, 3, 4, 5], got {nums5}\"\n\n    print(\"All test cases passed!\")"
            }
        }
    },
    {
        "id": 1,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Largest element in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/largest-element-in-array4009/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/1_Largest_element_in_Array.py",
        "approaches": {
            "Brute": {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "Sort the array in descending order to get largest element at index 0",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        return sorted(arr, reverse=True)[0]"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array arr[]. The task is to find the largest element and return it.  Examples:  Input: arr[] = [1, 8, 7, 56, 90] Output: 90 Explanation: The largest element of the given array is 90.  Input: arr[] = [5, 5, 5, 5] Output: 5 Explanation: The largest element of the given array is 5.  Input: arr[] = [10] Output: 10 Explanation: There is only one element which is the largest.  Constraints: 1 <= arr.size()<= 10^6 0 <= arr[i] <= 10^6",
                "intuition": "traverse the entire array to find the max element",
                "code": "class Solution:\n    def largest(self, arr: list[int]) -> int:\n        max_element = arr[0]\n\n        for i in range(1, len(arr)):\n            if arr[i] > max_element:\n                max_element = arr[i]\n\n        return max_element"
            }
        }
    },
    {
        "id": 2,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Second Largest in Array",
        "problem_link": "https://practice.geeksforgeeks.org/problems/second-largest3735/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/2_Second_Largest_in_Array.py",
        "approaches": {
            "Better": {
                "tc": "O(N)+O(N) ~ O(N)",
                "sc": "O(1)",
                "intuition": "first find the largest then again find the largest excluding already found largest value",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > largest:\n                largest = arr[i]\n\n        sec_largest = -1\n        for j in range(len(arr)):\n            if arr[j] != largest and arr[j] > sec_largest:\n                sec_largest = arr[j]\n\n        return sec_largest"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array of positive integers arr[], return the second largest element from the array. If the second largest element doesn't exist then return -1.  Note: The second largest element should not be equal to the largest element.  Examples:  Input: arr[] = [12, 35, 1, 10, 34, 1] Output: 34 Explanation: The largest element of the array is 35 and the second largest element is 34.  Input: arr[] = [10, 5, 10] Output: 5 Explanation: The largest element of the array is 10 and the second largest element is 5.  Input: arr[] = [10, 10, 10] Output: -1 Explanation: The largest element of the array is 10 and the second largest element does not exist.  Constraints: 2 \u2264 arr.size() \u2264 10^5 1 \u2264 arr[i] \u2264 10^5",
                "intuition": "in one pass we try to find max and sec_largest\nby utilizing 2 condition\n+ if current element is greater than sec_largest,but smaller than largest\n+ if current element is greater than largest",
                "code": "class Solution:\n    def getSecondLargest(self, arr: list[int]) -> int:\n        largest = arr[0]\n        sec_largest = -1\n\n        for i in range(1, len(arr)):\n            if arr[i] < largest and arr[i] > sec_largest:\n                sec_largest = arr[i]\n\n            if arr[i] > largest:\n                sec_largest = largest\n                largest = arr[i]\n\n        return sec_largest"
            }
        }
    },
    {
        "id": 3,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Max Ascending Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-ascending-subarray-sum ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/3_Max_Ascending_Subarray_Sum.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums.  A subarray is defined as a contiguous sequence of numbers in an array.   Example 1:  Input: nums = [10,20,30,5,10,50] Output: 65 Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. Example 2:  Input: nums = [10,20,30,40,50] Output: 150 Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150. Example 3:  Input: nums = [12,17,15,13,10,11,12] Output: 33 Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.   Constraints:  1 <= nums.length <= 100 1 <= nums[i] <= 100",
                "intuition": "Keep track of curr_sum and max_sum\nwhenever a peak drop comes update max_sum\nkeep adding to curr_sum\n\n\nfrom typing import List\nimport sys",
                "code": "class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = -sys.maxsize\n        curr_sum = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i - 1]:\n                max_sum = max(curr_sum, max_sum)\n                curr_sum = nums[i]\n            else:\n                curr_sum += nums[i]\n\n        max_sum = max(curr_sum, max_sum)\n\n        return max_sum"
            }
        }
    },
    {
        "id": 4,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Check Array Sorted",
        "problem_link": "https://practice.geeksforgeeks.org/problems/check-if-an-array-is-sorted0701/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/4_Check_Array_Sorted.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array arr[], check whether it is sorted in non-decreasing order. Return true if it is sorted otherwise false.  Examples:  Input: arr[] = [10, 20, 30, 40, 50] Output: true Explanation: The given array is sorted.  Input: arr[] = [90, 80, 100, 70, 40, 30] Output: false Explanation: The given array is not sorted.  Constraints: 1 \u2264 arr.size \u2264 10^6 - 10^9 \u2264 arr[i] \u2264 10^9",
                "intuition": "Keep checking that current element must be greater than equal to previous element\nif current element lesser than previous element return false",
                "code": "class Solution:\n    def arraySortedOrNot(self, arr) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True"
            }
        }
    },
    {
        "id": 5,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Check Array is Sorted and Rotated",
        "problem_link": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/5_Check_Array_is_Sorted_and_Rotated.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "keep rotating the array by one n times then check if the current rotated array is sorted or not if in at any pass we see that the array becomes equal to its sorted state we return true otherwise we return false  from typing import List",
                "code": "class Solution:\n    def rotateByOne(self, nums: list[int]):\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def check_array_sorted(self, nums: list[int]) -> bool:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                return False\n        return True\n\n    def check(self, nums: List[int]) -> bool:\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            if self.check_array_sorted(nums):\n                return True\n        return False"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.  There may be duplicates in the original array.  Note: An array A rotated by x positions results in an array B of the same length such that B[i] == A[(i+x) % A.length] for every valid index i.   Example 1:  Input: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the element of value 3: [3,4,5,1,2]. Example 2:  Input: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums. Example 3:  Input: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.  Constraints:  1 <= nums.length <= 100 1 <= nums[i] <= 100",
                "intuition": "Suppose ->  [3 4 5 1 2]\nNumber of dips should be 0 or 1\nif more than 1 return False\nThink for [1,3,2] also for return case\n\nfrom typing import List",
                "code": "class Solution:\n    def check(self, nums: List[int]) -> bool:\n        dips = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                dips += 1\n\n            if dips > 1:\n                return False\n\n        if dips == 0:\n            return True\n\n        return nums[-1] <= nums[0] and dips == 1"
            }
        }
    },
    {
        "id": 6,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Remove Duplicates Sorted Array",
        "problem_link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/6_Remove_Duplicates_Sorted_Array.py",
        "approaches": {
            "Brute": {
                "tc": "O(N)+O(Klog(K))+O(K)",
                "sc": "O(K)",
                "intuition": "store the unique nums to a set datastructure fill the first k position of the array with elements in the datastructure   from typing_extensions import List",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        visited_nums = set()\n        for i in range(len(nums)):\n            visited_nums.add(nums[i])\n\n        for idx, val in enumerate(\n            sorted(visited_nums)\n        ):  # since sets do not maintain order we need to sort again\n            nums[idx] = val\n\n        return len(visited_nums)"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.  Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:  Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:  The judge will test your solution with the following code:  int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length  int k = removeDuplicates(nums); // Calls your implementation  assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.   Example 1:  Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:  Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).   Constraints:  1 <= nums.length <= 3 * 10^4 -100 <= nums[i] <= 100 nums is sorted in non-decreasing order.",
                "intuition": "keep track of k which is the last element inserted position\nwe also declare a last num which keeps track of the last number visited\nif we visit a new number we update last visited num and insert the number\nat k position and atlast return k\n\nfrom typing_extensions import List",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 1\n        last_visted_num = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != last_visted_num:\n                last_visted_num = nums[i]\n                nums[k] = nums[i]\n                k += 1\n            else:\n                last_visted_num = nums[i]\n        return k"
            }
        }
    },
    {
        "id": 7,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Left Rotate Right Rotate Array By One",
        "problem_link": "NA ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/7_Left_Rotate_Right_Rotate_Array_By_One.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "You are given an integer array arr of size n. You need to implement two functions to perform rotations on this array:  Left Rotate: Implement a function left_rotate(arr: List[int]) -> List[int] that rotates the array to the left by one position. The first element of the array should move to the end.  Right Rotate: Implement a function right_rotate(arr: List[int]) -> List[int] that rotates the array to the right by one position. The last element of the array should move to the front.  Left Rotate Test Cases:  Example 1:  Input: arr = [1, 2, 3, 4, 5]  Output: [2, 3, 4, 5, 1]  Example 2:  Input: arr = [10, 20, 30, 40, 50]  Output: [20, 30, 40, 50, 10]  --------------------------------  Right Rotate Test Cases:  Example 1:  Input: arr = [1, 2, 3, 4, 5]  Output: [5, 1, 2, 3, 4]  Example 2:  Input: arr = [10, 20, 30, 40, 50]  Output: [50, 10, 20, 30, 40]  Constraints:  The input array will contain at least one integer. The array can contain both positive and negative integers.   Intuition",
                "intuition": "For left rotation move the first element to the last index by continous swapping\nFor right rotation move the last element to the first index by continous swapping\n\nfrom typing import List",
                "code": "def left_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1):\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n    return arr\n\n\ndef right_rotate(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[i - 1] = arr[i - 1], arr[i]\n    return arr\n\n\n# Example usage with assertions\nif __name__ == \"__main__\":\n    # Test left rotation\n    assert left_rotate([1, 2, 3, 4, 5]) == [2, 3, 4, 5, 1], \"Test Case 1 Failed\"\n    assert left_rotate([10, 20, 30, 40, 50]) == [\n        20,\n        30,\n        40,\n        50,\n        10,\n    ], \"Test Case 2 Failed\"\n    assert left_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    # Test right rotation\n    assert right_rotate([1, 2, 3, 4, 5]) == [5, 1, 2, 3, 4], \"Test Case 1 Failed\"\n    assert right_rotate([10, 20, 30, 40, 50]) == [\n        50,\n        10,\n        20,\n        30,\n        40,\n    ], \"Test Case 2 Failed\"\n    assert right_rotate([]) == [], \"Test Case 3 Failed\"  # Edge case: empty array\n\n    print(\"All test cases passed!\")"
            }
        }
    },
    {
        "id": 8,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Rotate Left K Places",
        "problem_link": "https://practice.geeksforgeeks.org/problems/reversal-algorithm5340/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/8_Rotate_Left_K_Places.py",
        "approaches": {
            "Brute": {
                "tc": "O(d*N)",
                "sc": "O(1)",
                "intuition": "keep left rotating by one place for d times",
                "code": "class Solution:\n    def rotate(self, arr: list[int]):\n        for i in range(len(arr) - 1):\n            arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    def leftRotate(self, arr: list[int], d: int) -> None:\n        while d:\n            self.rotate(arr)\n            d -= 1"
            },
            "Optimal": {
                "tc": "k)+O(N)",
                "sc": "O(1)",
                "question": "Given an array arr[]. The task is to rotate the array by d elements where d \u2264 arr.size.  Examples:  Input: arr[] = [-1, -2, -3, 4, 5, 6, 7], d = 2 Output: [-3, 4, 5, 6, 7, -1, -2] Explanation: Rotate by 1: [-2, -3, 4, 5, 6, 7, -1] Rotate by 2: [-3, 4, 5, 6, 7, -1, -2]  Input: arr[] = [1, 3, 4, 2], d = 3 Output: [2, 1, 3, 4] Explanation: After rotating the array three times, the first three elements shift one by one to the right.  Expected Time Complexity: O(n) Expected Auxiliary Space: O(1)  Constraints: 1 \u2264 arr.size \u2264 10^6 -10^9 \u2264 arr[i] \u2264 10^9 0 \u2264 d \u2264 arr.size",
                "intuition": "reverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nreverse the whole array",
                "code": "class Solution:\n    def leftRotate(self, arr: list[int], d: int) -> None:\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(arr, 0, d - 1)\n        rev_array(arr, d, len(arr) - 1)\n        rev_array(arr, 0, len(arr) - 1)"
            }
        }
    },
    {
        "id": 9,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Rotate Right K Places",
        "problem_link": "https://leetcode.com/problems/rotate-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/9_Rotate_Right_K_Places.py",
        "approaches": {
            "Brute": {
                "tc": "O(N*k)",
                "sc": "O(1)",
                "intuition": "keep right rotating by one place for d times   from typing import List",
                "code": "class Solution:\n    def right_rotate(self, arr: List[int]):\n        for i in range(len(arr) - 1, 0, -1):\n            arr[i], arr[i - 1] = arr[i - 1], arr[i]\n\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        while k:\n            self.right_rotate(nums)\n            k -= 1"
            },
            "Optimal": {
                "tc": "k)+O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.   Example 1:  Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:  Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]   Constraints:  1 <= nums.length <= 10^5 -2^31 <= nums[i] <= 2^31 - 1 0 <= k <= 10^5",
                "intuition": "reverse the whole array\nreverse the array from 0 to k-1\nreverse the array from k to len(arr)-1\nperform k normalization\n\nfrom typing import List",
                "code": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        k = k % len(nums)\n\n        def rev_array(arr: list[int], i: int, j: int) -> None:\n\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n\n        rev_array(nums, 0, len(nums) - 1)\n        rev_array(nums, 0, k - 1)\n        rev_array(nums, k, len(nums) - 1)"
            }
        }
    },
    {
        "id": 10,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Move Zeroes at the End",
        "problem_link": "https://leetcode.com/problems/move-zeroes ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/10_Move_Zeroes_at_the_End.py",
        "approaches": {
            "Brute": {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "make a copy of the array and push non negative values at first   from typing_extensions import List",
                "code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        cp_nums = [0] * len(nums)\n\n        idx = 0\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                cp_nums[idx] = nums[i]\n                idx += 1\n\n        nums[:] = cp_nums[:]"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.  Note that you must do this in-place without making a copy of the array.   Example 1:  Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2:  Input: nums = [0] Output: [0]   Constraints:  1 <= nums.length <= 10^4 -^231 <= nums[i] <= 2^31 - 1",
                "intuition": "maintain a idx variable which will tell us the postion to insert the\nnon zero values,if we encounter a non zero value we swap it with the value\nat that index and we increment one to the index\n\nfrom typing_extensions import List",
                "code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        idx = 0\n\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[idx], nums[i] = nums[i], nums[idx]\n                idx += 1"
            }
        }
    },
    {
        "id": 11,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Linear Search",
        "problem_link": "https://practice.geeksforgeeks.org/problems/who-will-win-1587115621/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/11_Linear_Search.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array, arr[] sorted in ascending order and an integer k. Return true if k is present in the array, otherwise, false.  Examples:  Input: arr[] = [1, 2, 3, 4, 6], k = 6 Output: true Explanation: Since, 6 is present in the array at index 4 (0-based indexing), output is true.  Input: arr[] = [1, 2, 4, 5, 6], k = 3 Output: false Explanation: Since, 3 is not present in the array, output is false.  Input: arr[] = [2, 3, 5, 6], k = 1 Output: false Constraints: 1 <= arr.size() <= 10^6 1 <= k <= 10^6 1 <= arr[i] <= 10^6",
                "intuition": "Traverse the array until you encounter the element you are searching",
                "code": "class Solution:\n    def searchInSorted(self, arr: list[int], k: int):\n        for i in range(len(arr)):\n            if arr[i] == k:\n                return True\n        return False"
            }
        }
    },
    {
        "id": 12,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Union of two sorted arrays with duplicates",
        "problem_link": "https://www.geeksforgeeks.org/problems/union-of-two-sorted-arrays-1587115621/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/12_Union_of_two_sorted_arrays_with_duplicates.py",
        "approaches": {
            "Brute": {
                "tc": "O(m+n)+O((m+n)log(m+n))+O(m+n)+O(k) ~ O((m+n)log(m+n))",
                "sc": "O(m+n)+O(m+n)",
                "intuition": "merge two arrays into a list in sorted form convert the merged list to set convert the set to list and return a ssorted list",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        return sorted(list(set(sorted([*a, *b]))))"
            },
            "Optimal": {
                "tc": "O(m+n)",
                "sc": "O(1)",
                "question": "Given two sorted arrays a[] and b[], where each array may contain duplicate elements , the task is to return the elements in the union of the two arrays in sorted order.  Union of two arrays can be defined as the set containing distinct common elements that are present in either of the arrays. Examples:  Input: a[] = [1, 2, 3, 4, 5], b[] = [1, 2, 3, 6, 7] Output: 1 2 3 4 5 6 7 Explanation: Distinct elements including both the arrays are: 1 2 3 4 5 6 7.  Input: a[] = [2, 2, 3, 4, 5], b[] = [1, 1, 2, 3, 4] Output: 1 2 3 4 5 Explanation: Distinct elements including both the arrays are: 1 2 3 4 5.  Input: a[] = [1, 1, 1, 1, 1], b[] = [2, 2, 2, 2, 2] Output: 1 2 Explanation: Distinct elements including both the arrays are: 1 2.  Constraints: 1  <=  a.size(), b.size()  <=  10^5 -10^9  <=  a[i] , b[i]  <=  10^9",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nand follow the merge sort algorithm",
                "code": "class Solution:\n\n    def findUnion(self, a: list[int], b: list[int]) -> list[int]:\n        union: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(a) and j < len(b):\n            if a[i] <= b[j]:\n                if last_inserted != a[i]:\n                    union.append(a[i])\n                    last_inserted = a[i]\n                i += 1\n            else:\n                if last_inserted != b[j]:\n                    union.append(b[j])\n                    last_inserted = b[j]\n                j += 1\n\n        while i < len(a):\n            if last_inserted != a[i]:\n                union.append(a[i])\n                last_inserted = a[i]\n            i += 1\n\n        while j < len(b):\n            if last_inserted != b[j]:\n                union.append(b[j])\n                last_inserted = b[j]\n            j += 1\n\n        return union"
            }
        }
    },
    {
        "id": 13,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Intersection of two sorted arrays",
        "problem_link": "https://www.geeksforgeeks.org/problems/intersection-of-two-sorted-array-1587115620/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/13_Intersection_of_two_sorted_arrays.py",
        "approaches": {
            "Brute": {
                "tc": "O(m)+O(n)+O((m+n)log(m+n))+O(m+n) ~ O((m+n)log(m+n))",
                "sc": "O(m+n)",
                "intuition": "convert the two arrays into set find the intersection between them return the intersection converted into list in a sorted manner",
                "code": "class Solution:\n    # Function to return a list containing the intersection of two arrays.\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        st1 = set(arr1)\n        st2 = set(arr2)\n\n        return sorted(list(st1.intersection(st2)))"
            },
            "Optimal": {
                "tc": "O(m+n)",
                "sc": "O(1)",
                "question": "Given two sorted arrays arr1[] and arr2[]. Your task is to return the intersection of both arrays.  Intersection of two arrays is said to be elements that are common in both arrays. The intersection should not count duplicate elements.  Note: If there is no intersection then return an empty array.  Examples:  Input: arr1[] = [1, 2, 3, 4], arr2[] = [2, 4, 6, 7, 8] Output: [2, 4] Explanation: 2 and 4 are only common elements in both the arrays.  Input: arr1[] = [1, 2, 2, 3, 4], arr2[] = [2, 2, 4, 6, 7, 8] Output: [2, 4] Explanation: 2 and 4 are the only common elements.  Input: arr1[] = [1, 2], arr2[] = [3, 4] Output: [] Explanation: No common elements.  Expected Time Complexity: O(n + m) Expected Auxiliary Space: O(min(n,m))  Constraints: 1 <= arr1.size(),arr2.size() <= 10^5 1 <= arr1[i], arr2[i] <= 10^6",
                "intuition": "just keep track of what you inserted last time\ndont insert if its the same element you inserted last time\nJust follow merge sort algorithm and when equal elements\nare encounter insert only based on the above condition",
                "code": "class Solution:\n\n    def intersection(self, arr1: list[int], arr2: list[int]):\n        intersection: list[int] = []\n\n        i, j = 0, 0\n        last_inserted = (10**9) + 1\n\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                i += 1\n            elif arr1[i] > arr2[j]:\n                if last_inserted != arr2[j]:\n                    last_inserted = arr2[j]\n                j += 1\n            else:\n                if last_inserted != arr1[i]:\n                    last_inserted = arr1[i]\n                    intersection.append(arr1[i])\n                i += 1\n                j += 1\n\n        return intersection"
            }
        }
    },
    {
        "id": 14,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "2 Sum I",
        "problem_link": "https://leetcode.com/problems/two-sum ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/14_2_Sum_I.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all the pairs and check whether pair exists or not  from typing import List",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.  You may assume that each input would have exactly one solution, and you may not use the same element twice.  You can return the answer in any order.   Example 1:  Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:  Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3:  Input: nums = [3,3], target = 6 Output: [0,1]   Constraints:  2 <= nums.length <= 10^4 -10^9 <= nums[i] <= 10^9 -10^9 <= target <= 10^9 Only one valid answer exists.",
                "intuition": "keep marking the element as you visit them\njust check target-current_element present in seen_map or not\nX+Y=target, if target-Y is present then we can definitely say\nwe have a pair\n\nfrom typing import List",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen_map = {}\n\n        for idx, num in enumerate(nums):\n            diff = target - num\n            if diff in seen_map:\n                return [seen_map[diff], idx]\n            seen_map[num] = idx"
            }
        }
    },
    {
        "id": 15,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "2 Sum II",
        "problem_link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/15_2_Sum_II.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all pairs and see whethet target sum exists  from typing import List",
                "code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.  Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.  The tests are generated such that there is exactly one solution. You may not use the same element twice.  Your solution must use only constant extra space.   Example 1:  Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2:  Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3:  Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].   Constraints:  2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order. -1000 <= target <= 1000 The tests are generated such that there is exactly one solution.",
                "intuition": "Use two pointers i and j\ni is at 0th and j is at last index\nif the sum becomes greater decrease range\nif the sum is lesser increase range\n\n\nfrom typing import List",
                "code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        i, j = 0, len(numbers) - 1\n\n        while i < j:\n            if numbers[i] + numbers[j] > target:\n                j -= 1\n            elif numbers[i] + numbers[j] < target:\n                i += 1\n            else:\n                return [i + 1, j + 1]"
            }
        }
    },
    {
        "id": 16,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "3 Sum",
        "problem_link": "https://leetcode.com/problems/3sum ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/16_3_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^3)+O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "Sort the array to generate distinct pairs generate all possible triplet combination and see whether they add to 0   from typing import List",
                "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ans = set()\n        nums.sort()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] == 0:\n                        ans.add((nums[i], nums[j], nums[k]))\n\n        return list(ans)"
            },
            "Better": {
                "tc": "O(N^2)+O(Nlog(N))",
                "sc": "O(N)",
                "intuition": "Fix one element at index i and perform 2 sum hashmap technique  from typing import List",
                "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            h = {}\n            for j in range(i + 1, len(nums)):\n                diff = 0 - nums[i] - nums[j]\n                if diff in h:\n                    ans.add((nums[i], nums[j], nums[h[diff]]))\n                h[nums[j]] = j\n\n        return list(ans)"
            },
            "Optimal": {
                "tc": "O(N^2)+O(Nlog(N))",
                "sc": "O(1)",
                "question": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.  Notice that the solution set must not contain duplicate triplets.   Example 1:  Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2:  Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:  Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0.   Constraints:  3 <= nums.length <= 3000 -10^5 <= nums[i] <= 10^5",
                "intuition": "Fix one element at index i and perform 2 sum sorted array technique\n\nfrom typing import List",
                "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            j, k = i + 1, len(nums) - 1\n\n            if (\n                i != 0 and nums[i] == nums[i - 1]\n            ):  # we dont want to generate same triplets\n                continue\n\n            while j < k:\n                if nums[i] + nums[j] + nums[k] > 0:\n                    k -= 1\n                elif nums[i] + nums[j] + nums[k] < 0:\n                    j += 1\n                elif nums[i] + nums[j] + nums[k] == 0:\n                    ans.add((nums[i], nums[j], nums[k]))\n                    j += 1\n                    k -= 1\n\n                    # we dont want to generate same triplets\n                    while nums[j] == nums[j - 1] and j < k:\n                        j += 1\n                    while nums[k] == nums[k + 1] and j < k:\n                        k -= 1\n\n        return list(ans)"
            }
        }
    },
    {
        "id": 17,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "4 Sum",
        "problem_link": "https://leetcode.com/problems/4sum ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/17_4_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^4)",
                "sc": "O(1)",
                "intuition": "Generate all possible pairs and check if target sum exists   from contextlib import contextmanager from typing import List",
                "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    for l in range(k + 1, len(nums)):\n                        sm = nums[i] + nums[j] + nums[k] + nums[l]\n\n                        if sm == target:\n                            ans.add((nums[i], nums[j], nums[k], nums[l]))\n\n        return list(ans)"
            },
            "Better": {
                "tc": "O(N^3)",
                "sc": "O(N)",
                "intuition": "Fix one element at index i and other at j and perform 2 sum hashmap technique   from typing import List",
                "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                h = {}\n                for k in range(j + 1, len(nums)):\n                    diff = target - nums[i] - nums[j] - nums[k]\n                    if diff in h:\n                        ans.add((nums[i], nums[j], nums[k], nums[h[diff]]))\n                    h[nums[k]] = k\n\n        return list(ans)"
            },
            "Optimal": {
                "tc": "O(N^3)",
                "sc": "O(1)",
                "question": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:  0 <= a, b, c, d < n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order.   Example 1:  Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:  Input: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]]   Constraints:  1 <= nums.length <= 200 -10^9 <= nums[i] <= 10^9 -10^9 <= target <= 10^9",
                "intuition": "Fix one element at index i and other at j and perform 2 sum sorted array technique\n\n\nfrom typing import List",
                "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n\n        for i in range(len(nums)):\n            if i != 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums)):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n\n                k, l = j + 1, len(nums) - 1\n                while k < l:\n                    sm = nums[i] + nums[j] + nums[k] + nums[l]\n                    if sm > target:\n                        l -= 1\n                    elif sm < target:\n                        k += 1\n                    elif sm == target:\n                        ans.add((nums[i], nums[j], nums[k], nums[l]))\n                        k += 1\n                        l -= 1\n\n                        while nums[k] == nums[k - 1] and k < l:\n                            k += 1\n\n                        while nums[l] == nums[l + 1] and k < l:\n                            l -= 1\n\n        return list(ans)"
            }
        }
    },
    {
        "id": 18,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Missing Number",
        "problem_link": "https://leetcode.com/problems/missing-number ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/18_Missing_Number.py",
        "approaches": {
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.  Example 1:  Input: nums = [3,0,1]  Output: 2  Explanation:  n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.  Example 2:  Input: nums = [0,1]  Output: 2  Explanation:  n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.  Example 3:  Input: nums = [9,6,4,2,3,5,7,0,1]  Output: 8  Explanation:  n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.   Constraints:  n == nums.length 1 <= n <= 10^4 0 <= nums[i] <= n All the numbers of nums are unique.",
                "intuition": "use cyclic sort\n\n\nfrom typing import List",
                "code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        i = 0\n\n        while i < len(nums):\n            actualPos = nums[i]\n            if nums[i] < len(nums) and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n\n        return len(nums)"
            }
        }
    },
    {
        "id": 19,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Find All Numbers Disappeared in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/19_Find_All_Numbers_Disappeared_in_an_Array.py",
        "approaches": {
            "Brute": {
                "tc": "O(3N) ~ O(N)",
                "sc": "O(2N)",
                "intuition": "create a map containing items that should be present create a map containing current items in array iterate through the should_contain_map and check which elements are not in curr_contain_map   from typing import List",
                "code": "class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n        curr_contain_map = {i: True for i in nums}\n\n        ans = []\n        for k, v in should_contain_map.items():\n            if k not in curr_contain_map:\n                ans.append(k)\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.   Example 1:  Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Example 2:  Input: nums = [1,1] Output: [2]   Constraints:  n == nums.length 1 <= n <= 10^5 1 <= nums[i] <= n   Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
                "intuition": "Do cyclic sort\nafter cyclic sort does the element expected for that index match\n\nfrom typing import List",
                "code": "class Solution:\n    def cyclic_sort(self, arr: List[int]) -> None:\n        idx = 0\n\n        while idx < len(arr):\n            actualPos = arr[idx] - 1\n\n            if arr[actualPos] != arr[idx]:\n                arr[actualPos], arr[idx] = arr[idx], arr[actualPos]\n            else:\n                idx += 1\n\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        ans = []\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(i + 1)\n\n        return ans"
            }
        }
    },
    {
        "id": 20,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Find the Duplicate Number",
        "problem_link": "https://leetcode.com/problems/find-the-duplicate-number ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/20_Find_the_Duplicate_Number.py",
        "approaches": {
            "Brute": {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "Use a hasmap to keep track of seen elements if we see a elements more than twice return that element   from typing import List",
                "code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        seen = {}\n\n        for i in nums:\n            if i in seen:\n                return i\n            seen[i] = True\n\n        return -1"
            },
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.  There is only one repeated number in nums, return this repeated number.  You must solve the problem without modifying the array nums and using only constant extra space.   Example 1:  Input: nums = [1,3,4,2,2] Output: 2 Example 2:  Input: nums = [3,1,3,4,2] Output: 3 Example 3:  Input: nums = [3,3,3,3,3] Output: 3   Constraints:  1 <= n <= 10^5 nums.length == n + 1 1 <= nums[i] <= n All the integers in nums appear only once except for precisely one integer which appears two or more times.   Follow up:  How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity?",
                "intuition": "Use the cylic sort algoritm\nsort the array using cyclic sort\nthe first number not at its correct place is the duplicate\n\n\nfrom typing import List",
                "code": "class Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicate(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return nums[i]\n\n        return -1"
            }
        }
    },
    {
        "id": 21,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Find All Duplicates in an Array",
        "problem_link": "https://leetcode.com/problems/find-all-duplicates-in-an-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/21_Find_All_Duplicates_in_an_Array.py",
        "approaches": {
            "Brute": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(N)",
                "intuition": "use map to keep track of frequency number occuring more than 2 are duplicates   from typing import List",
                "code": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        freq_mp = {}\n\n        for num in nums:\n            freq_mp[num] = 1 + freq_mp.get(num, 0)\n\n        ans = []\n        for num in freq_mp:\n            if freq_mp[num] >= 2:\n                ans.append(num)\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that appears twice.  You must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output   Example 1:  Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Example 2:  Input: nums = [1,1,2] Output: [1] Example 3:  Input: nums = [1] Output: []   Constraints:  n == nums.length 1 <= n <= 10^5 1 <= nums[i] <= n Each element in nums appears once or twice.",
                "intuition": "do cyclic sort\nnumbers not at its correct place are the duplicates\n\n\nfrom typing import List",
                "code": "class Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n        ans = []\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                ans.append(nums[i])\n\n        return ans"
            }
        }
    },
    {
        "id": 22,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Set Mismatch",
        "problem_link": "https://leetcode.com/problems/set-mismatch ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/22_Set_Mismatch.py",
        "approaches": {
            "Brute": {
                "tc": "O(4N) ~ O(N)",
                "sc": "O(1)",
                "intuition": "For missing number keep track of what should be present and compare it with current present map For duplicate find the number with frequency more than 2",
                "code": "class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        ans = []\n\n        should_contain_map = {i: True for i in range(1, len(nums) + 1)}\n\n        current_contain_map = {}\n        for num in nums:\n            current_contain_map[num] = 1 + current_contain_map.get(num, 0)\n\n        for num in current_contain_map:\n            if current_contain_map[num] > 1:\n                ans.append(num)\n\n        for num in should_contain_map:\n            if num not in current_contain_map:\n                ans.append(num)\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.  You are given an integer array nums representing the data status of this set after the error.  Find the number that occurs twice and the number that is missing and return them in the form of an array.   Example 1:  Input: nums = [1,2,2,4] Output: [2,3] Example 2:  Input: nums = [1,1] Output: [1,2]   Constraints:  2 <= nums.length <= 10^4 1 <= nums[i] <= 10^4",
                "intuition": "do cyclic sort\nnumbers not at correct place is the duplicate and index is the missing\n\nfrom typing import List",
                "code": "class Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return [nums[i], i + 1]\n\n        return []"
            }
        }
    },
    {
        "id": 23,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Hard",
        "problem_name": "First Missing Positive",
        "problem_link": "https://leetcode.com/problems/first-missing-positive ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/23_First_Missing_Positive.py",
        "approaches": {
            "Brute": {
                "tc": "O(max*N)",
                "sc": "O(1)",
                "intuition": "we know that all the positive numbers will lie from 1 to max_number+2 max_number is taken because suppose we have [1,2] then the first missing positive will be 3 just check sequentially from starting whether any number in this is range is absent then that will be our missing first positive termination condition is 1 becuase what if we have ony negatives [-1,-2]  from typing import List",
                "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        for i in range(1, max(nums) + 2):\n            found = False\n            for j in range(len(nums)):\n                if nums[j] <= 0:\n                    continue\n                if i == nums[j]:\n                    found = True\n                    break\n            if not found:\n                return i\n\n        return 1"
            },
            "Better": {
                "tc": "O(max_number)",
                "sc": "O(max_number)",
                "intuition": "Keep track of what element should be present increment the number in the map wrt to elements present in original map see which numbers count is still zero   from typing import List",
                "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        should_contain_map = {}\n        for i in range(1, max(nums) + 2):\n            should_contain_map[i] = 0\n\n        for num in nums:\n            if num in should_contain_map:\n                should_contain_map[num] += 1\n\n        for num in should_contain_map:\n            if should_contain_map[num] == 0:\n                return num\n\n        return 1"
            },
            "Optimal": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(1)",
                "question": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.  You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.   Example 1:  Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2:  Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing. Example 3:  Input: nums = [7,8,9,11,12] Output: 1 Explanation: The smallest positive integer 1 is missing.   Constraints:  1 <= nums.length <= 10^5 -2^31 <= nums[i] <= 2^31 - 1",
                "intuition": "Do cyclic cyclic_sort\nignore number greater than size of array and negative numbers since zero based indexing\nthe first number at wro\n\n\nfrom typing import List",
                "code": "class Solution:\n    def cyclic_sort(self, nums: List[int]) -> None:\n        i = 0\n        while i < len(nums):\n            actualPos = nums[i] - 1\n            if nums[i] < len(nums) and nums[i] > 0 and nums[actualPos] != nums[i]:\n                nums[i], nums[actualPos] = nums[actualPos], nums[i]\n            else:\n                i += 1\n\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        self.cyclic_sort(nums)\n\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return -1"
            }
        }
    },
    {
        "id": 24,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Find Element Appeating more than once",
        "problem_link": "https://leetcode.com/problems/single-element-in-a-sorted-array ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/24_Find_Element_Appeating_more_than_once.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "just check one by one the count of each element in the array if count is equal to return nums   from typing import List",
                "code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            cnt = 0\n            for j in range(len(nums)):\n                if nums[i] == nums[j]:\n                    cnt += 1\n                if cnt >= 2:\n                    break\n            if cnt == 1:\n                return nums[i]\n        return -1"
            },
            "Better": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(N)",
                "intuition": "maintain a frequency map return element with frequency 1   from typing import List",
                "code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        freq_map = {}\n\n        for num in nums:\n            freq_map[num] = 1 + freq_map.get(num, 0)\n\n        for num in freq_map:\n            if freq_map[num] == 1:\n                return num\n\n        return -1"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.  Return the single element that appears only once.  Your solution must run in O(log n) time and O(1) space.   Example 1:  Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Example 2:  Input: nums = [3,3,7,7,10,11,11] Output: 10   Constraints:  1 <= nums.length <= 10^5 0 <= nums[i] <= 10^5",
                "intuition": "we know xor of any 2 same number is 0\nand xor of 0 with any number (x) is x\nso same number get cancelled out leaving\nthe element appeating once\n\nfrom typing import List",
                "code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        xor = 0\n\n        for num in nums:\n            xor ^= num\n\n        return xor"
            }
        }
    },
    {
        "id": 25,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Max Consecutive Ones",
        "problem_link": "https://leetcode.com/problems/max-consecutive-ones ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/25_Max_Consecutive_Ones.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given a binary array nums, return the maximum number of consecutive 1's in the array.   Example 1:  Input: nums = [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Example 2:  Input: nums = [1,0,1,1,0,1] Output: 2   Constraints:  1 <= nums.length <= 10^5 nums[i] is either 0 or 1.",
                "intuition": "Keep track of number of 1s encountered till now\nif current num is 1 increment 1s encountered\nat every step you encounter 1 find max of count and max_ones\nif current num is 0 reset counter",
                "code": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        max_ones = 0\n        c = 0\n\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                c += 1\n                max_ones = max(max_ones, c)\n            else:\n                c = 0\n\n        return max_ones"
            }
        }
    },
    {
        "id": 26,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Sort an array of 0's 1's & 2's",
        "problem_link": "https://leetcode.com/problems/sort-colors ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/26_Sort_an_array_of_0's_1's_&_2's.py",
        "approaches": {
            "Brute": {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "intuition": "sort using inbilt function   from typing import List",
                "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()"
            },
            "Better": {
                "tc": "O(N)+O(3*N) ~ O(N)",
                "sc": "O(3)",
                "intuition": "Count occurences of 0s,1s,2s and store them in a map Then fill the array with the number of times each element occurs   from typing import List",
                "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        count_map = {0: 0, 1: 0, 2: 0}\n\n        for num in nums:\n            count_map[num] += 1\n\n        idx = 0\n        for num, count in count_map.items():\n            for i in range(count):\n                nums[idx] = num\n                idx += 1"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.  We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.  You must solve this problem without using the library's sort function.   Example 1:  Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2:  Input: nums = [2,0,1] Output: [0,1,2]   Constraints:  n == nums.length 1 <= n <= 300 nums[i] is either 0, 1, or 2.",
                "intuition": "Use dutch national flag algorithm\ngoal of this algo is to push all the low values to left\nand high values to right\nat first our entire array is unsorted\nso we can put the mid at 0 and high at len(array)-1\nand start in the 0 th postiion\n\n00000000000000     111111111111     ?????????         2222222222\n^            ^     ^          ^     ^       ^         ^        ^\n0         low-1   low     mid-1    mid      high     high+1   n-1\n\n? is ith unsorted portion\n\n\nfrom typing import List",
                "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low, mid = 0, 0\n        high = len(nums) - 1\n\n        for _ in range(len(nums)):\n            # if unsorted portion has zero\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n\n            # if unsorted portion has one\n            elif nums[mid] == 1:\n                mid += 1\n\n            # if unsorted portion has two\n            elif nums[mid] == 2:\n                nums[high], nums[mid] = nums[mid], nums[high]\n                high -= 1"
            }
        }
    },
    {
        "id": 27,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Rearrange Array Elements by Sign",
        "problem_link": "https://leetcode.com/problems/rearrange-array-elements-by-sign ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/27_Rearrange_Array_Elements_by_Sign.py",
        "approaches": {
            "Brute": {
                "tc": "O(N)+O(N) ~ O(N)",
                "sc": "O(N/2)+O(N/2)+O(N) ~ O(2N)",
                "intuition": "Store all the positive,negative numbers in 2 seperate list since array consists of equal number of positive and negative integers so we are sure that at even index we will have positive number and at odd index we will have negative numbers   from typing import List",
                "code": "class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        pos, neg = [], []\n\n        for num in nums:\n            if num < 0:\n                neg.append(num)\n            if num >= 0:\n                pos.append(num)\n\n        ans = []\n        posIdx, negIdx = 0, 0\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                ans.append(pos[posIdx])\n                posIdx += 1\n            else:\n                ans.append(neg[negIdx])\n                negIdx += 1\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.  You should return the array of nums such that the the array follows the given conditions:  Every consecutive pair of integers have opposite signs. For all integers with the same sign, the order in which they were present in nums is preserved. The rearranged array begins with a positive integer. Return the modified array after rearranging the elements to satisfy the aforementioned conditions.   Example 1:  Input: nums = [3,1,-2,-5,2,-4] Output: [3,-2,1,-5,2,-4] Explanation: The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4]. The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4]. Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions. Example 2:  Input: nums = [-1,1] Output: [1,-1] Explanation: 1 is the only positive integer and -1 the only negative integer in nums. So nums is rearranged to [1,-1].   Constraints:  2 <= nums.length <= 2 * 10^5 nums.length is even 1 <= |nums[i]| <= 10^5 nums consists of equal number of positive and negative integers.",
                "intuition": "since array consists of equal number of positive and negative integers\nso we are sure that at even index we will have positive number and\nat odd index we will have negative numbers\nkeep track of next positive index and next negative index\n\nfrom typing import List",
                "code": "class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        ans = [0 for _ in range(len(nums))]\n\n        posIdx = 0\n        negIdx = 1\n\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                ans[posIdx] = nums[i]\n                posIdx += 2\n            else:\n                ans[negIdx] = nums[i]\n                negIdx += 2\n\n        return ans"
            }
        }
    },
    {
        "id": 28,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Alternate Positive Negative",
        "problem_link": "https://www.geeksforgeeks.org/problems/array-of-alternate-ve-and-ve-nos1401/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/28_Alternate_Positive_Negative.py",
        "approaches": {
            "Brute": {
                "tc": "O(N)+O(N) ~ O(N)",
                "sc": "O(N)+O(N/2)+O(N/2)",
                "intuition": "Separate Positive and Negative numbers Merge the Two Vectors Alternately After append the remaining elements to the ans",
                "code": "class Solution:\n    def rearrange(self, arr: list[int]):\n        ans: list[int] = [0 for _ in range(len(arr))]\n\n        pos, neg = [], []\n\n        for num in arr:\n            if num >= 0:\n                pos.append(num)\n            else:\n                neg.append(num)\n\n        idx = 0\n        if len(pos) <= len(neg):\n            for i in range(len(pos)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(pos), len(neg)):\n                ans[idx] = neg[j]\n                idx += 1\n        else:\n            for i in range(len(neg)):\n                ans[idx] = pos[i]\n                ans[idx + 1] = neg[i]\n                idx += 2\n            for j in range(len(neg), len(pos)):\n                ans[idx] = pos[j]\n                idx += 1\n\n        arr[::] = ans[::]"
            },
            "Optimal": {
                "tc": "",
                "sc": "",
                "question": "Given an unsorted array arr containing both positive and negative numbers. Your task is to rearrange the array and convert it into an array of alternate positive and negative numbers without changing the relative order.  Note: - Resulting array should start with a positive integer (0 will also be considered as a positive integer). - If any of the positive or negative integers are exhausted, then add the remaining integers in the answer as it is by maintaining the relative order. - The array may or may not have the equal number of positive and negative integers.  Examples:  Input: arr[] = [9, 4, -2, -1, 5, 0, -5, -3, 2] Output: [9, -2, 4, -1, 5, -5, 0, -3, 2] Explanation: The positive numbers are [9, 4, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 4 and then -1 and so on.  Input: arr[] = [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8] Output: [5, -5, 2, -2, 4, -8, 7, 1, 8, 0] Explanation : The positive numbers are [5, 2, 4, 7, 1, 8, 0] and the negative integers are [-5,-2,-8]. According to the given conditions we will start from the positive integer 5 and then -5 and so on. After reaching -8 there are no negative elements left, so according to the given rule, we will add the remaining elements (in this case positive elements are remaining) as it in by maintaining the relative order.  Input: arr[] = [9, 5, -2, -1, 5, 0, -5, -3, 2] Output: [9, -2, 5, -1, 5, -5, 0, -3, 2] Explanation: The positive numbers are [9, 5, 5, 0, 2] and the negative integers are [-2, -1, -5, -3]. Since, we need to start with the positive integer first and then negative integer and so on (by maintaining the relative order as well), hence we will take 9 from the positive set of elements and then -2 after that 5 and then -1 and so on.  Constraints: 1 \u2264 arr.size() \u2264 106 -106 \u2264 arr[i] \u2264 106",
                "intuition": "",
                "code": ""
            }
        }
    },
    {
        "id": 29,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Best Time to Buy and Sell Stock",
        "problem_link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/29_Best_Time_to_Buy_and_Sell_Stock.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "You are given an array prices where prices[i] is the price of a given stock on the ith day.  You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.  Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.   Example 1:  Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:  Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0.   Constraints:  1 <= prices.length <= 10^5 0 <= prices[i] <= 10^4",
                "intuition": "Suppose you are at index i just ask yourself\ncan i sell this stock on this day if i have\nthe minimum stock cost from left side of the index\nbuy in less price and sell in high price\n\n\nfrom typing import List\nimport sys",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_cp_till_now = prices[0]\n        max_profit = -sys.maxsize\n\n        for i in range(len(prices)):\n            max_profit = max(max_profit, prices[i] - min_cp_till_now)\n            min_cp_till_now = min(min_cp_till_now, prices[i])\n\n        return max_profit"
            }
        }
    },
    {
        "id": 30,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Leaders in an array",
        "problem_link": "https://www.geeksforgeeks.org/problems/leaders-in-an-array-1587115620/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/30_Leaders_in_an_array.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "You are given an array arr of positive integers. Your task is to find all the leaders in the array. An element is considered a leader if it is greater than or equal to all elements to its right. The rightmost element is always a leader.  Examples:  Input: arr = [16, 17, 4, 3, 5, 2] Output: [17, 5, 2] Explanation: Note that there is nothing greater on the right side of 17, 5 and, 2.  Input: arr = [10, 4, 2, 4, 1] Output: [10, 4, 4, 1] Explanation: Note that both of the 4s are in output, as to be a leader an equal element is also allowed on the right. side  Input: arr = [5, 10, 20, 40] Output: [40] Explanation: When an array is sorted in increasing order, only the rightmost element is leader.  Input: arr = [30, 10, 10, 5] Output: [30, 10, 10, 5] Explanation: When an array is sorted in non-increasing order, all elements are leaders.  Constraints: 1 <= arr.size() <= 106 0 <= arr[i] <= 106",
                "intuition": "traverse the array from right\nkeep track of the maximum height from the right till now\ncompare the value at current index with the max_from_right so far\nif it is greater then we can say its a leader",
                "code": "class Solution:\n    def leaders(self, arr: list[int]) -> list[int]:\n        max_from_right = arr[-1]\n\n        n = len(arr)\n        ans = [arr[-1]]\n\n        for i in range(n - 2, -1, -1):\n            if arr[i] >= max_from_right:\n                ans.append(arr[i])\n                max_from_right = arr[i]\n\n        return ans[::-1]"
            }
        }
    },
    {
        "id": 31,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Rotate Image",
        "problem_link": "https://leetcode.com/problems/rotate-image ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/31_Rotate Image.py",
        "approaches": {
            "Optimal": {
                "tc": "O(2*N*M) ~ O(N*M)",
                "sc": "O(1)",
                "question": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).  You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.   Example 1:  Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:   Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "intuition": "Do transpose of a matrix\nReverse every row\n\n\nfrom typing import List",
                "code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # Transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(\n                i + 1, len(matrix[0])\n            ):  # swap values above diagonal to avoid overwriting\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # Reverse each row\n        for i in range(len(matrix)):\n            j = 0\n            while j < len(matrix[0]) // 2:\n                n = len(matrix[0])\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\n                j += 1"
            }
        }
    },
    {
        "id": 32,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Spiral Matrix",
        "problem_link": "https://leetcode.com/problems/spiral-matrix ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/32_Spiral_Matrix.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N*M)",
                "sc": "O(N*M)",
                "question": "Given an m x n matrix, return all elements of the matrix in spiral order.  Example 1:   Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2:  Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7]",
                "intuition": "keep 4 pointes top,left,right,bottom\njust do what they have said till left<=right and top<=bottom\n\n\nfrom typing import List",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        top = 0\n        left = 0\n        right = len(matrix[0]) - 1\n        bottom = len(matrix) - 1\n\n        ans = []\n\n        while left <= right and top <= bottom:\n            # Left to Right\n            for i in range(left, right + 1):\n                ans.append(matrix[top][i])\n            top += 1\n\n            # Top to Bottom\n            for i in range(top, bottom + 1):\n                ans.append(matrix[i][right])\n            right -= 1\n\n            # Right to Left\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    ans.append(matrix[bottom][i])\n                bottom -= 1\n\n            # Bottom to Top\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    ans.append(matrix[i][left])\n                left += 1\n\n        return ans"
            }
        }
    },
    {
        "id": 33,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Majority Element I",
        "problem_link": "https://leetcode.com/problems/majority-element ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/34_Majority_Element_I.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep track of the element appearing more than n//2 times using 2 loops   from typing import List",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        majority_element = -1\n        appear_count = len(nums) // 2\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_element = nums[i]\n\n        return majority_element"
            },
            "Better": {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//2 times  from typing import List",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        appear_count = len(nums) // 2\n        freq_mp = {}\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                return num\n\n        return -1"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an array nums of size n, return the majority element.  The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.   Example 1:  Input: nums = [3,2,3] Output: 3 Example 2:  Input: nums = [2,2,1,1,1,2,2] Output: 2   Constraints:  n == nums.length 1 <= n <= 5 * 10^4 -10^9 <= nums[i] <= 10^9",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times\n+ assume first element as majority element\n+ if you see majority element again increment count\n+ if you see new element decrement count\n+ if count is zero new majority element has come",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        maj = nums[0]\n        c = 1\n\n        for i in range(1, len(nums)):\n            # increment count if its the same majority element\n            if nums[i] == maj:\n                c += 1\n\n            elif c == 0:  # reset majority element\n                c = 1\n                maj = nums[i]\n\n            # decrement count if its not the current majority element\n            elif nums[i] != maj:\n                c -= 1\n\n        return maj"
            }
        }
    },
    {
        "id": 34,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Majority Element II",
        "problem_link": "https://leetcode.com/problems/majority-element-ii ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/35_Majority_Element_II.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep track of the element appearing more than n//3 times using 2 loops   from typing import List",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        majority_elements: set[int] = set()\n\n        for i in range(len(nums)):\n            c = 1\n            for j in range(len(nums)):\n                if j == i:\n                    continue\n\n                if nums[i] == nums[j]:\n                    c += 1\n\n            if c > appear_count:\n                majority_elements.add(nums[i])\n\n        return list(majority_elements)"
            },
            "Better": {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "store the frequency of each element and just keep checking if some element occur more than n//3 times  from typing import List",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        freq_mp = {}\n        majority_elements: set[int] = set()\n\n        for num in nums:\n            if num not in freq_mp:\n                freq_mp[num] = 1\n            else:\n                freq_mp[num] += 1\n\n            if freq_mp[num] > appear_count:\n                majority_elements.add(num)\n\n        return list(majority_elements)"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times.   Example 1:  Input: nums = [3,2,3] Output: [3] Example 2:  Input: nums = [1] Output: [1] Example 3:  Input: nums = [1,2] Output: [1,2]   Constraints:  1 <= nums.length <= 5 * 10^4 -10^9 <= nums[i] <= 10^9",
                "intuition": "Observation - we can have atmost k-1 majority elements for n//k\nFor example:\nfor n=4 if n//2 given we can have only 1 majority element\nthan can occur 3 times and 1 element can occur 1 time\n[1,1,1,2] for n//2\nfor n=10 if n//3 given we can have only 2 majority elements\nthan can occur 4 times each and 2 element can occur 1 time\n[1,1,1,1,2,2,2,2,3,3] for n//3\n2 pass algo one to find and one to verify\nbasically this algos main Intuition is element occuring more than n//2\ntimes will cancel out the elements occuring less number of times\n\n\nfrom typing import List",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        appear_count = len(nums) // 3\n        maj1 = nums[0]\n        c1 = 0\n\n        maj2 = nums[0]\n        c2 = 0\n\n        for i in range(len(nums)):\n            # increment count1 if its the same majority element1\n            if nums[i] == maj1:\n                c1 += 1\n\n            # increment count2 if its the same majority element2\n            elif nums[i] == maj2:\n                c2 += 1\n\n            elif c1 == 0:  # reset majority element1\n                c1 = 1\n                maj1 = nums[i]\n\n            elif c2 == 0:  # reset majority element2\n                c2 = 1\n                maj2 = nums[i]\n\n            else:\n                c1 -= 1\n                c2 -= 1\n\n        c1 = 0\n        c2 = 0\n        for i in range(len(nums)):\n            if nums[i] == maj1:\n                c1 += 1\n            elif nums[i] == maj2:\n                c2 += 1\n\n        ans = []\n\n        if c1 > appear_count:\n            ans.append(maj1)\n\n        if c2 > appear_count:\n            ans.append(maj2)\n\n        return ans"
            }
        }
    },
    {
        "id": 35,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Pascals's Triangle",
        "problem_link": "https://leetcode.com/problems/pascals-triangle ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/36_Pascals's_Triangle.py",
        "approaches": {
            "Brute": {
                "tc": "O(numRows*last_row)",
                "sc": "O(N)",
                "intuition": "when starting pad your last seen row with single 0 For example if a last row is [0,1,2,1,0] The next row will be the summation of pairs i,i+1 [(0+1),(1+2),(2+1),(1+0)] = [1,3,3,1]   from typing import List",
                "code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = [[1]]\n        last_row = [0, 1, 0]\n\n        for i in range(numRows - 1):\n            tmp = []\n            for j in range(len(last_row) - 1):\n                tmp.append(last_row[j] + last_row[j + 1])\n            ans.append(tmp)\n            last_row = [0, *tmp, 0]\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "question": "Given an integer numRows, return the first numRows of Pascal's triangle.  In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:   Example 1:  Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2:  Input: numRows = 1 Output: [[1]]   Constraints:  1 <= numRows <= 30",
                "intuition": "Must Know (1) : Given row and col , find element at row and col , You can find with\nthis formula -> row-1 C col-1\n\nObservation suppose i have 7C2 ->  (7*6)*(5*4*3*2*1)\n-----------------\n(2*1)*(5*4*3*2*1)\nyou will see only first 2 in the numerator and denominator is left others get cancel\ntry it for others you will see only the \"col\"(r) part remains\n------------------------------------------------------------------------------------\n\nMust Know (2) : Given n print the nth pascals-triangle row, you can use the above\nformula and try to find it in O(N*r) complexity ,but we can improve it a further\nIn pascals-triangle the nth row will have n elements\nGiven 6th row of pascals-triangle\n\nCol Idx           0   1        2            3               4                   5\n\nObservation :     1   5       10           10               5                   1\n\nMultiplication:   1   5/1    (5*4)/(1*2)  (5*4*3)/(1*2*3) (5*4*3*4)/(1*2*3*4)  (5*4*3*4*5)/(1*2*3*4*5)\n\n\nFormula for finding the ith element in a row  is : (row-col)/col , you just have to maintain previouse cols value\n------------------------------------------------------------------------------------------------------------------\n\nfrom typing import List",
                "code": "class Solution:\n    def getNRow(self, n: int) -> list[int]:\n        ans = 1\n        tmp = [1]\n        for i in range(1, n):\n            ans *= n - i\n            ans //= i\n            tmp.append(ans)\n        return tmp\n\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = []\n        for i in range(1, numRows + 1):\n            ans.append(self.getNRow(i))\n\n        return ans"
            }
        }
    },
    {
        "id": 36,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Longest Subarray 0 Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/largest-subarray-with-0-sum/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/38_Longest_Subarray_0_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays find the longest subarray with 0 sum from them",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array arr containing both positive and negative integers, the task is to compute the length of the largest subarray that has a sum of 0.  Examples:  Input: arr[] = [15, -2, 2, -8, 1, 7, 10, 23] Output: 5 Explanation: The largest subarray with a sum of 0 is [-2, 2, -8, 1, 7].  Input: arr[] = [2, 10, 4] Output: 0 Explanation: There is no subarray with a sum of 0.  Input: arr[] = [1, 0, -4, 3, 1, 0] Output: 5 Explanation: The subarray is [0, -4, 3, 1, 0].  Constraints: 1 \u2264 arr.size() \u2264 10^6 \u221210^3 \u2264 arr[i] \u2264 10^3, for each valid i",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def maxLen(self, arr: list[int]) -> int:\n        sm = 0\n        k = 0\n\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len"
            }
        }
    },
    {
        "id": 37,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Longest Subarray K Sum",
        "problem_link": "https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/39_Longest_Subarray_K_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays find the longest subarray with k sum from them",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        # code here\n        mx_len = 0\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm == k:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array arr[] containing integers and an integer k, your task is to find the length of the longest subarray where the sum of its elements is equal to the given value k. If there is no subarray with sum equal to k, return 0.  Examples:  Input: arr[] = [10, 5, 2, 7, 1, -10], k = 15 Output: 6 Explanation: Subarrays with sum = 15 are [5, 2, 7, 1], [10, 5] and [10, 5, 2, 7, 1, -10]. The length of the longest subarray with a sum of 15 is 6.  Input: arr[] = [-5, 8, -14, 2, 4, 12], k = -5 Output: 5 Explanation: Only subarray with sum = -5 is [-5, 8, -14, 2, 4] of length 5.  Input: arr[] = [10, -10, 20, 30], k = 5 Output: 0 Explanation: No subarray with sum = 5 is present in arr[].  Constraints: 1 \u2264 arr.size() \u2264 10^5 -10^4 \u2264 arr[i] \u2264 10^4 -10^9 \u2264 k \u2264 10^9",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the prefix sum till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum , current_i-mp[s-k]\nwill give the current length\nUse the concept of prefix sum",
                "code": "class Solution:\n    def longestSubarray(self, arr: list[int], k: int) -> int:\n        sm = 0\n        pref_sum_map = {0: -1}  # at first the size is -1\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            diff = sm - k\n\n            if diff in pref_sum_map:\n                mx_len = max(mx_len, i - pref_sum_map[diff])\n\n            if (\n                sm not in pref_sum_map\n            ):  # store the index as left as possible as newer index will decrease our size\n                pref_sum_map[sm] = i\n\n        return mx_len"
            }
        }
    },
    {
        "id": 38,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Longest Subarray Sum Divisible by K",
        "problem_link": "<Question Link> ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/40_Longest_Subarray_Sum_Divisible_by_K.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all subarrays among them find the longest subarray divisible by k",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n\n        for i in range(len(arr)):\n            sm = 0\n            for j in range(i, len(arr)):\n                sm += arr[j]\n                if sm % k == 0:\n                    mx_len = max(mx_len, j - i + 1)\n\n        return mx_len"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array arr[] and a positive integer k, find the length of the longest subarray with the sum of the elements divisible by k. Note: If there is no subarray with sum divisible by k, then return 0.  Examples :  Input: arr[] = [2, 7, 6, 1, 4, 5], k = 3 Output: 4 Explanation: The subarray [7, 6, 1, 4] has sum = 18, which is divisible by 3.  Input: arr[] = [-2, 2, -5, 12, -11, -1, 7], k = 3 Output: 5 Explanation: The subarray [2, -5, 12, -11, -1] has sum = -3, which is divisible by 3.  Input: arr[] = [1, 2, -2], k = 2 Output: 2 Explanation: The subarray is [2, -2] has sum = 0, which is divisible by 2.  Constraints: 1 <= arr.size() <= 10^6 1 <= k <= 10^6 -10^6 <= arr[i] <= 10^6",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before",
                "code": "class Solution:\n    def longestSubarrayDivK(self, arr: list[int], k: int) -> int:\n        mx_len = 0\n        sm = 0\n        remainder_map = {0: -1}\n\n        for i in range(len(arr)):\n            sm += arr[i]\n\n            rem = sm % k\n\n            if rem < 0:  # dont store negative remainder\n                rem += k\n\n            if rem in remainder_map:\n                mx_len = max(mx_len, i - remainder_map[rem])\n\n            if rem not in remainder_map:\n                remainder_map[rem] = i\n\n        return mx_len"
            }
        }
    },
    {
        "id": 39,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Count Subarray K Sum",
        "problem_link": "https://leetcode.com/problems/subarray-sum-equals-k ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/41_Count_Subarray_K_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays and count subarrays with sum k   from typing import List",
                "code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n\n                if sm == k:\n                    c += 1\n\n        return c"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.  A subarray is a contiguous non-empty sequence of elements within an array.   Example 1:  Input: nums = [1,1,1], k = 2 Output: 2 Example 2:  Input: nums = [1,2,3], k = 3 Output: 2   Constraints:  1 <= nums.length <= 2 * 10^4 -1000 <= nums[i] <= 1000 -10^7 <= k <= 10^7",
                "intuition": "Suppose i have an array below :\nx    k\n--- -----\na b c d e f g h\n---------\ns\n\ns is the sum till now\nwe are looking for subarray with k sum ,\nif k sum is already present then k+x will\ngive us \"s\" , so in every pass we are going\nto take a map and store the count till\nthat ith index if we are able to find a sum\ns-k that we have seen earlier we can say that\nwe have got a subarray with k sum\nUse the concept of prefix sum\nhow many s-k we have to remove inorder from curr sum to get k\nno of s-k will be equivalent to no of k\n\nNow, there may exist multiple subarrays with the prefix sum x-k. So, the number of subarrays\nwith sum k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix sum x-k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        sm = 0\n        k_sum_count_map = {0: 1}\n        count = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n\n            diff = sm - k\n\n            if diff in k_sum_count_map:\n                count += k_sum_count_map[diff]\n\n            if sm not in k_sum_count_map:\n                k_sum_count_map[sm] = 1\n            else:\n                k_sum_count_map[sm] += 1\n\n        return count"
            }
        }
    },
    {
        "id": 40,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Count Subarray Sum Divisible by K",
        "problem_link": "https://leetcode.com/problems/subarray-sums-divisible-by-k ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/42_Count_Subarray_Sum_Divisible_by_K.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays from those subarrays count subarray sum divisible by k  from typing import List",
                "code": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                if sm % k == 0:\n                    count += 1\n\n        return count"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.  A subarray is a contiguous part of an array.   Example 1:  Input: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Example 2:  Input: nums = [5], k = 9 Output: 0   Constraints:  1 <= nums.length <= 3 * 10^4 -10^4 <= nums[i] <= 10^4 2 <= k <= 10^4",
                "intuition": "suppose i have a below array:\n------- S1(x)      sum1 with x remainder\na b c d e f g h i j k l\n------------------- S2(x)  sum2 with x remainder\n\nit can be mathematically proven s2-s1 is divisible by k\ns1= kn1+x\ns2= kn2+x\ns1-s2=k(n1-n2) # divisible\nkeep storing remainder for correspdoing prefix sum\ncheck if we have seen this remainder before\n\n\nfrom typing import List",
                "code": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n        rem_count_mp = {0: 1}\n        sm = 0\n\n        for i in range(len(nums)):\n            sm += nums[i]\n            rem = sm % k\n\n            if rem < 0:\n                rem += k\n\n            if rem in rem_count_mp:\n                count += rem_count_mp[rem]\n\n            if rem not in rem_count_mp:\n                rem_count_mp[rem] = 1\n            else:\n                rem_count_mp[rem] += 1\n\n        return count"
            }
        }
    },
    {
        "id": 41,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Count Subarray K XOR",
        "problem_link": "https://www.geeksforgeeks.org/problems/count-subarray-with-given-xor/0 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/43_Count_Subarray_K_XOR.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(N)",
                "intuition": "Generate all subarrays count subarrays with k xor from them",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        c = 0\n\n        for i in range(len(arr)):\n            xor = 0\n            for j in range(i, len(arr)):\n                xor ^= arr[j]\n\n                if xor == k:\n                    c += 1\n\n        return c"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an array of integers arr[] and a number k, count the number of subarrays having XOR of their elements as k.  Examples:  Input: arr[] = [4, 2, 2, 6, 4], k = 6 Output: 4 Explanation: The subarrays having XOR of their elements as 6 are [4, 2], [4, 2, 2, 6, 4], [2, 2, 6], and [6]. Hence, the answer is 4.  Input: arr[] = [5, 6, 7, 8, 9], k = 5 Output: 2 Explanation: The subarrays having XOR of their elements as 5 are [5] and [5, 6, 7, 8, 9]. Hence, the answer is 2.  Input: arr[] = [1, 1, 1, 1], k = 0 Output: 4 Explanation: The subarrays are [1, 1], [1, 1], [1, 1] and [1, 1, 1, 1].  Constraints:  1 \u2264 arr.size() \u2264 10^5 0 \u2264 arr[i] \u226410^5 0 \u2264 k \u2264 10^5",
                "intuition": "Now, there may exist multiple subarrays with the prefix xor pref^k. So, the number of subarrays\nwith xor k that we can generate from the entire subarray ending at index i, is exactly equal\nto the number of subarrays with the prefix xor pref^k, that we can remove from the entire subarray.",
                "code": "class Solution:\n    def subarrayXor(self, arr: list[int], k: int) -> int:\n        pref_xor = 0\n        count = 0\n        xor_mp = {0: 1}\n\n        for i in range(len(arr)):\n            pref_xor ^= arr[i]\n\n            diff_xor = pref_xor ^ k\n\n            if diff_xor in xor_mp:\n                count += xor_mp[diff_xor]\n\n            if pref_xor in xor_mp:\n                xor_mp[pref_xor] += 1\n            else:\n                xor_mp[pref_xor] = 1\n\n        return count"
            }
        }
    },
    {
        "id": 42,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Longest Consecutive Sequence",
        "problem_link": "https://leetcode.com/problems/longest-consecutive-sequence ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/44_Longest_Consecutive_Sequence.py",
        "approaches": {
            "Brute": {
                "tc": "O(Nlog(N)) + O(N)",
                "sc": "O(1)",
                "intuition": "sort the array and find the longest consecutive sequence ignore equal length number   from typing import List",
                "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        nums.sort()\n\n        mx_len = 1\n        curr_len = 1\n\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] == 1:\n                curr_len += 1\n                mx_len = max(mx_len, curr_len)\n            elif nums[i] - nums[i - 1] == 0:\n                mx_len = max(mx_len, curr_len)\n                continue\n            else:\n                curr_len = 1\n\n        return mx_len"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(N)",
                "question": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.  You must write an algorithm that runs in O(n) time.   Example 1:  Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2:  Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 Example 3:  Input: nums = [1,0,1,2] Output: 3   Constraints:  0 <= nums.length <= 10^5 -10^9 <= nums[i] <= 10^9",
                "intuition": "The answer lies in visualization\nconsider the below array\n100 4 200 1 3 2\n\n1 2 3 4     100        200\n---------------------------\n\nconvert the given array to set\nstarting values of the sequence does not have left neightbour\nso whenever we find an element which does not have left neightbour\nwe will start a while loop incrementing it by 1 and check if that\nnumber exists and keep on building the sequence and atlast we can\ncheck if its the max length till now or not\n\n\nfrom typing import List",
                "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for num in numSet:\n            if (num - 1) not in numSet:\n                length = 1\n                while (num + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest"
            }
        }
    },
    {
        "id": 43,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Maximum Sum Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-subarray ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/45_Maximum_Sum_Subarray.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays, and find the subarray with max sum   from typing import List import sys",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n        for i in range(len(nums)):\n            sm = 0\n            for j in range(i, len(nums)):\n                sm += nums[j]\n                mx_sum = max(mx_sum, sm)\n\n        return mx_sum"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums, find the subarray with the largest sum, and return its sum.   Example 1:  Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2:  Input: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3:  Input: nums = [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.   Constraints:  1 <= nums.length <= 10^5 -10^4 <= nums[i] <= 10^4   Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
                "intuition": "print the sequence\nwhen the sum is zero we can say right its a start of the sequnce\ntake 2 pointers ansStart and ansEnd and another variable to track\ncurrent start\n\n\nfrom typing import List\nimport sys",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]):\n        curr_sum = 0\n        global_sum = -sys.maxsize\n        resStart, resEnd = 0, 0\n        currStart = 0\n\n        for i in range(len(nums)):\n            if curr_sum == 0:\n                currStart = i\n\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n                resStart = currStart\n                resEnd = i\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        print(\"Maximum subarray sequence:\", nums[resStart : resEnd + 1])\n        print(\"Maximum subarray sum:\", global_sum)\n\n\nobj = Solution()\nls = [1, -2, -1, 0, 3, 4]\nls = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nobj.maxSubArray(ls)"
            }
        }
    },
    {
        "id": 44,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Maximum Circular Subarray Sum",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/46_Maximum_Circular_Subarray_Sum.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "rotate the array by one find max sum subarray keep track of global sum subarray  import sys from typing import List",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        curr_sum = 0\n        global_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n\n            if curr_sum > global_sum:\n                global_sum = curr_sum\n\n            if curr_sum < 0:\n                curr_sum = 0\n\n        return global_sum\n\n    def rotateByOne(self, nums: list[int]) -> None:\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        mx_sum = -sys.maxsize\n\n        for _ in range(len(nums)):\n            self.rotateByOne(nums)\n            mx_sum = max(mx_sum, self.maxSubArray(nums))\n\n        return mx_sum"
            },
            "Optimal": {
                "tc": "",
                "sc": "O(1)",
                "question": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.  A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].  A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.  Example 1:  Input: nums = [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3. Example 2:  Input: nums = [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10. Example 3:  Input: nums = [-3,-2,-3] Output: -2 Explanation: Subarray [-2] has maximum sum -2.   Constraints:  n == nums.length 1 <= n <= 3 * 10^4 -3 * 10^4 <= nums[i] <= 3 * 10^4",
                "intuition": "Suppose consider the below array\na b c d e f g h i j k l m\n------- --------- -------\nmax-sum min-sum(b) max-sum(a)\n-------------------------- total-sum(s)\nproof -> We know that a+b = S\nwe are claiming that b is the min sum\nbut suppose we say that in order to make b\nthe min sum, we need to reduce the value of b\nif we are reducing the value of b then we have\nto increase the value of a to inorder to balance\nout the sum , but wait a is already max sum we cannot\nincrease its value , so by contradiction its proven right\nthat b is the min sum\nbut whenever my total sum and min-sum is the same, then return\nthe normal sum , Egde case [-1,-2,-3] here the circular sum\nbecomes 0\n\nimport sys\nfrom typing import List",
                "code": "class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        total_sum = 0\n\n        curr_min_sum = 0\n        min_sum = sys.maxsize\n\n        curr_max_sum = 0\n        max_sum = -sys.maxsize\n\n        for i in range(len(nums)):\n            total_sum += nums[i]\n\n            curr_min_sum = min(nums[i], curr_min_sum + nums[i])\n            min_sum = min(min_sum, curr_min_sum)\n\n            curr_max_sum = max(nums[i], curr_max_sum + nums[i])\n            max_sum = max(max_sum, curr_max_sum)\n\n        circular_sum = total_sum - min_sum\n\n        if total_sum == min_sum:\n            return max_sum\n\n        return max(circular_sum, max_sum)"
            }
        }
    },
    {
        "id": 45,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Maximum Product Subarray",
        "problem_link": "https://leetcode.com/problems/maximum-sum-circular-subarray ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/47_Maximum_Product_Subarray.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all sub arrays and find the max product from it   import sys from typing import List",
                "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        mx_prod = -sys.maxsize\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod *= nums[j]\n                mx_prod = max(mx_prod, prod)\n        return mx_prod"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums, find a subarray that has the largest product, and return the product.  The test cases are generated so that the answer will fit in a 32-bit integer.   Example 1:  Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2:  Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.   Constraints:  1 <= nums.length <= 2 * 10^4 -10 <= nums[i] <= 10 The product of any subarray of nums is guaranteed to fit in a 32-bit integer.",
                "intuition": "Observation 1 : if array has all postive then just return the prod of entire array\nObservation 2: if array has even nos of negative just return the prod of entire array\nObservation 3: if array has odd no of negatives just remove one negative (leaving us with even negative) and the answer will lie in either suffix or prefix\nObservation 4: if we have zero then we will not carry it over as it will reduce our maximum product , we will suffix,prefix to 1,1\nTo find the answer, we will check all possible prefix subarrays (starting from index 0) and all possible suffix subarrays (starting from index n-1)\nThe maximum product obtained from these prefix and suffix subarrays will be our final answer.\n\nimport sys\nfrom typing import List",
                "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        pref = 1\n        suff = 1\n        n = len(nums)\n        mx_prod = -sys.maxsize\n\n        for i in range(len(nums)):\n            if pref == 0:\n                pref = 1\n            if suff == 0:\n                suff = 1\n\n            pref *= nums[i]\n            suff *= nums[n - i - 1]\n\n            mx_prod = max(mx_prod, pref, suff)\n\n        return mx_prod"
            }
        }
    },
    {
        "id": 46,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Product of array except itself",
        "problem_link": "https://leetcode.com/problems/product-of-array-except-self ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/48_Product_of_array_except_itself.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Find the product of each number except itself using 2 loops  from typing import List",
                "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = []\n\n        for i in range(n):\n            p = 1\n            for j in range(n):\n                if i == j:\n                    continue\n                p *= nums[j]\n            ans.append(p)\n\n        return ans"
            },
            "Better": {
                "tc": "O(N)+O(N)+O(N)",
                "sc": "O(N)+O(N)",
                "intuition": "Product of array except itself for an ith number is nothing but product of prefix sum till i-1 and suffix sum i+1 Example : [1 2 3 4 5 6] Prod of 3 excpe itself is => 1*2 * 4*5*6 --   ----- pref  suff  from typing import List",
                "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        pref = [1] * n\n        for i in range(1, n):\n            pref[i] = pref[i - 1] * nums[i - 1]\n\n        suff = [1] * n\n        for i in range(n - 2, -1, -1):\n            suff[i] = suff[i + 1] * nums[i + 1]\n\n        ans = [1] * n\n        for i in range(n):\n            ans[i] = pref[i] * suff[i]\n\n        return ans"
            },
            "Optimal": {
                "tc": "O(N)+O(N)",
                "sc": "O(1)",
                "question": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].  The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.  You must write an algorithm that runs in O(n) time and without using the division operation.   Example 1:  Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2:  Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]   Constraints:  2 <= nums.length <= 10^5 -30 <= nums[i] <= 30 The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.   Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
                "intuition": "Fill the result array on the fly\nfirst put the prefix part in the result\nthen put suffix part in the result\n\nfrom typing import List",
                "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [1] * n\n\n        pref = 1\n        for i in range(n):\n            ans[i] = pref\n            pref *= nums[i]\n\n        suff = 1\n        for j in range(n - 1, -1, -1):\n            ans[j] *= suff\n            suff *= nums[j]\n\n        return ans"
            }
        }
    },
    {
        "id": 47,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Merge Sorted Array Without Extra Space",
        "problem_link": "https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/49_Merge_Sorted_Array_Without_Extra_Space.py",
        "approaches": {
            "Optimal": {
                "tc": "O((M+N) + M*log(M) + N*log(N))",
                "sc": "O(1)",
                "question": "Given two sorted arrays a[] and b[] of size n and m respectively, the task is to merge them in sorted order without using any extra space. Modify a[] so that it contains the first n elements and modify b[] so that it contains the last m elements.  Examples:  Input: a[] = [2, 4, 7, 10], b[] = [2, 3] Output: 2 2 3 4 7 10 Explanation: After merging the two non-decreasing arrays, we get, 2 2 3 4 7 10  Input: a[] = [1, 5, 9, 10, 15, 20], b[] = [2, 3, 8, 13] Output: 1 2 3 5 8 9 10 13 15 20 Explanation: After merging two sorted arrays we get 1 2 3 5 8 9 10 13 15 20.  Input: a[] = [0, 1], b[] = [2, 3] Output: 0 1 2 3 Explanation: After merging two sorted arrays we get 0 1 2 3.  Constraints: 1 <= a.size(), b.size() <= 10^5 0 <= a[i], b[i] <= 10^7",
                "intuition": "use 2 pointers\nfix one pointer to the last index of 1st array\nfix another pointer to the first index if 2nd array\nkeep comparing if the j is smaller than i swap\notherwise break",
                "code": "class Solution:\n    def mergeArrays(self, a: list[int], b: list[int]) -> None:\n        i = len(a) - 1\n        j = 0\n\n        while i >= 0 and j < len(b) and b[j] < a[i]:\n            b[j], a[i] = a[i], b[j]\n            j += 1\n            i -= 1\n\n        a.sort()\n        b.sort()"
            }
        }
    },
    {
        "id": 48,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Count Inversions",
        "problem_link": "https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/50_Count_Inversions.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Generate all subarrays and find the subarray with the matching condition",
                "code": "class Solution:\n    def inversionCount(self, arr):\n        c = 0\n        for i in range(len(arr)):\n            for j in range(len(arr)):\n                if i < j and arr[i] > arr[j]:\n                    c += 1\n        return c"
            },
            "Optimal": {
                "tc": "O(Nlog(N))",
                "sc": "O(1)",
                "question": "Given an array of integers arr[]. Find the Inversion Count in the array. Two elements arr[i] and arr[j] form an inversion if arr[i] > arr[j] and i < j.  Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If the array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum.  Examples:  Input: arr[] = [2, 4, 1, 3, 5] Output: 3 Explanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).  Input: arr[] = [2, 3, 4, 5, 6] Output: 0 Explanation: As the sequence is already sorted so there is no inversion count.  Input: arr[] = [10, 10, 10] Output: 0 Explanation: As all the elements of array are same, so there is no inversion count.  Constraints: 1 \u2264 arr.size() \u2264 10^5 1 \u2264 arr[i] \u2264 10^4",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,2)(5,3),(5,4)\nwill form pair right as i<j and arr[i]>arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        i, j = l, mid + 1\n        tmp = []\n\n        c = 0\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                c += mid - i + 1  # include all the farther ahead elements too\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def inversionCount(self, arr: list[int]) -> int:\n        return self.mergeSort(0, len(arr) - 1, arr)"
            }
        }
    },
    {
        "id": 49,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Hard",
        "problem_name": "Reverse Pairs",
        "problem_link": "https://leetcode.com/problems/reverse-pairs ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/51_Reverse_Pairs.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "generate all pairs and check which pairs follow the condition   from typing import List",
                "code": "class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        c = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j] * 2:\n                    c += 1\n        return c"
            },
            "Optimal": {
                "tc": "O(NlogN)",
                "sc": "O(N)",
                "question": "Given an integer array nums, return the number of reverse pairs in the array.  A reverse pair is a pair (i, j) where:  0 <= i < j < nums.length and nums[i] > 2 * nums[j].   Example 1:  Input: nums = [1,3,2,3,1] Output: 2 Explanation: The reverse pairs are: (1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1 (3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1 Example 2:  Input: nums = [2,4,3,5,1] Output: 3 Explanation: The reverse pairs are: (1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1 (2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1 (3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1   Constraints:  1 <= nums.length <= 5 * 10^4 -2^31 <= nums[i] <= 2^31 - 1",
                "intuition": "use merge sort to solve this\nSuppose we have 2 sorted array as below\n[5,6,7,8] [1,2,3,4]\none thing for sure is (5,1)(5,2)\nwill form pair right as i<j and arr[i]>2*arr[j]\nbut in merge sort after we have proceessed a smaller\nnumber we move one position ahead but this may lead\nto missing of many pair, so since 2 arrays are sorted\nwe can for sure say if 5 forms pair then all the further\nelements will form pair too and add those pair to counter",
                "code": "class Solution:\n    def merge(self, l: int, mid: int, h: int, arr: list[int]) -> int:\n        c = 0\n        i, j = l, mid + 1\n        while i <= mid and j <= h:  #  check the condition before performing merge sort\n            if arr[i] > 2 * arr[j]:\n                c += (mid - i) + 1\n                j += 1\n            else:\n                i += 1\n\n        i, j = l, mid + 1\n        tmp = []\n\n        while i <= mid and j <= h:\n            if arr[i] <= arr[j]:\n                tmp.append(arr[i])\n                i += 1\n            else:\n                tmp.append(arr[j])\n                j += 1\n\n        while i <= mid:\n            tmp.append(arr[i])\n            i += 1\n        while j <= h:\n            tmp.append(arr[j])\n            j += 1\n\n        k = 0\n        for i in range(l, h + 1):\n            arr[i] = tmp[k]\n            k += 1\n\n        return c\n\n    def mergeSort(self, l: int, h: int, arr: list[int]) -> int:\n        c = 0\n\n        if l >= h:  # array has 1 element\n            return 0\n\n        mid = (l + h) // 2\n\n        c += self.mergeSort(l, mid, arr)\n        c += self.mergeSort(mid + 1, h, arr)\n        c += self.merge(l, mid, h, arr)\n\n        return c\n\n    def reversePairs(self, nums: List[int]) -> int:\n        return self.mergeSort(0, len(nums) - 1, nums)"
            }
        }
    },
    {
        "id": 50,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Game of Life",
        "problem_link": "https://leetcode.com/problems/game-of-life ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/52_Game_of_Life.py",
        "approaches": {
            "Brute": {
                "tc": "O(M*N*8)",
                "sc": "O(M*N)",
                "intuition": "Live cell with less than 2 live neighbors die Live cell with more than 2 or 3 live neighbors live Live cell with more than 3 live die Dead cell ressurects with exactly 3 live neighbors   from typing import List",
                "code": "class Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] == 1:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        ans = [[0 for _ in range(len(board[0]))] for _ in range(len(board))]\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        ans[i][j] = 0\n                    else:\n                        ans[i][j] = 1\n                else:\n                    if live_neighbor_count == 3:\n                        ans[i][j] = 1\n\n        board[::] = ans"
            },
            "Optimal": {
                "tc": "O(M*N*8)+O(M*N) ~ O(M*N)",
                "sc": "O(1)",
                "question": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"  The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.  Given the current state of the board, update the board to reflect its next state.  Note that you do not need to return anything.  Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Example 2:   Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]]   Constraints:  m == board.length n == board[i].length 1 <= m, n <= 25 board[i][j] is 0 or 1.",
                "intuition": "we try to preserve the original values of each state\nmark the cell that was alive but will die as -2\nmark the cell that was dead but ressurects with 2\n\nfrom typing import List",
                "code": "class Solution:\n    def get_live_neighbour_count(self, x: int, y: int, board: List[List[int]]):\n        dirs = [(1, 0), (0, 1), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, -1), (-1, 0)]\n\n        live_neighbor_count = 0\n        for dx, dy in dirs:\n            if 0 <= x + dx < len(board) and 0 <= y + dy < len(board[0]):\n                if board[x + dx][y + dy] in [1, -2]:\n                    live_neighbor_count += 1\n\n        return live_neighbor_count\n\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbor_count = self.get_live_neighbour_count(i, j, board)\n                if board[i][j] == 1:\n                    if live_neighbor_count > 3 or live_neighbor_count < 2:\n                        board[i][j] = -2\n                else:\n                    if live_neighbor_count == 3:\n                        board[i][j] = 2\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == -2:\n                    board[i][j] = 0\n                elif board[i][j] == 2:\n                    board[i][j] = 1"
            }
        }
    },
    {
        "id": 51,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "H Index",
        "problem_link": "https://leetcode.com/problems/h-index ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/53_H_Index.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Do i have h papers that has been cited h times start with 0 and keep increasing the index by 1 and check if there can be h-index of i sice we have an array of size n, the max h-index can be n   from typing import List",
                "code": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        h_index = 0\n\n        for i in range(1, len(citations) + 1):\n            c = 0\n            for j in range(len(citations)):\n                if citations[j] >= i:\n                    c += 1\n                if c == i:\n                    h_index = i\n                    break\n\n        return h_index"
            },
            "Optimal": {
                "tc": "O(N)+O(N) ~ O(N)",
                "sc": "O(N)",
                "question": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.  According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.   Example 1:  Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2:  Input: citations = [1,3,1] Output: 1   Constraints:  n == citations.length 1 <= n <= 5000 0 <= citations[i] <= 1000",
                "intuition": "we use a counting sort techique to solve this problem\nfirst we create an array of size n+1\neach index in the array represents the count of paper having i citaions\nsince we can have citations more than size of the array for those cases\nwe are going to use the last index of the array to store count\nwe start iterating from back of the array and check whether we have\npapers more than i value or not if we have then we just return i\n\n\nfrom typing import List",
                "code": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        count_arr = [0] * (len(citations) + 1)\n\n        for i in range(len(citations)):\n            if citations[i] >= len(citations):\n                count_arr[len(citations)] += 1\n            else:\n                count_arr[citations[i]] += 1\n\n        paper_count = 0\n        for i in range(len(count_arr) - 1, -1, -1):\n            paper_count += count_arr[i]\n            if paper_count >= i:\n                return i\n\n        return 0"
            }
        }
    },
    {
        "id": 52,
        "topic": "Arrays",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Insert Delete GetRandom O(1)",
        "problem_link": "https://leetcode.com/problems/insert-delete-getrandom-o1 ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/2_Arrays_and_Hashing/54_Insert_Delete_GetRandom_O(1).py",
        "approaches": {
            "Optimal": {
                "tc": "O(1)",
                "sc": "O(N)+O(N)",
                "question": "Implement the RandomizedSet class:  RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity.   Example 1:  Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2]  Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.   Constraints:  -2^31 <= val <= 2^31 - 1 At most 2 * 10^5 calls will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called.",
                "intuition": "import random",
                "code": "class RandomizedSet:\n\n    def __init__(self):\n        self.indices: dict[int, int] = {}\n        self.vals: list[int] = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.indices:\n            return False\n\n        self.indices[val] = len(self.vals)\n        self.vals.append(val)\n\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.indices:\n            return False\n\n        # Swap the last element with this val\n        delete_element_idx = self.indices[val]\n        last_element_idx = len(self.vals) - 1\n\n        self.vals[delete_element_idx], self.vals[last_element_idx] = (\n            self.vals[last_element_idx],\n            self.vals[delete_element_idx],\n        )\n\n        # Update the index of the last element\n        self.indices[self.vals[delete_element_idx]] = delete_element_idx\n\n        self.vals.pop(-1)\n        del self.indices[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.vals)"
            }
        }
    },
    {
        "id": 1,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Remove Outermost Parentheses",
        "problem_link": "https://leetcode.com/problems/remove-outermost-parentheses ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/1_Remove_Outermost_Parentheses.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.  Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.  Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.   Example 1:  Input: s = \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2:  Input: s = \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3:  Input: s = \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\".   Constraints:  1 <= s.length <= 10^5 s[i] is either '(' or ')'. s is a valid parentheses string.",
                "intuition": "Suppose we have an input case : s = \"(()())(())(()(()))\"\n\n(()()) Part1\n121210\n\n(()) Part2\n1210\n\n(()(())) Part3\n12123210\n\nThere is a pattern,\n+ if depth count is 1 and if its opening brace then it is the outermost opening brace\n+ if depth count is 0 and its closing brace, it is the outermost closing brace",
                "code": "class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        depthCount: int = 0\n        res: str = \"\"\n\n        for char in s:\n\n            if char == \"(\":\n                depthCount += 1\n\n            elif char == \")\":\n                depthCount -= 1\n\n            if depthCount == 1 and char == \"(\":\n                continue\n\n            if depthCount == 0 and char == \")\":\n                continue\n\n            res += char\n\n        return res"
            }
        }
    },
    {
        "id": 2,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Maximum Nesting Depth of the Parentheses",
        "problem_link": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/2_Maximum_Nesting_Depth_of_the_Parentheses.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.   Example 1:  Input: s = \"(1+(2*3)+((8)/4))+1\"  Output: 3  Explanation:  Digit 8 is inside of 3 nested parentheses in the string.  Example 2:  Input: s = \"(1)+((2))+(((3)))\"  Output: 3  Explanation:  Digit 3 is inside of 3 nested parentheses in the string.  Example 3:  Input: s = \"()(())((()()))\"  Output: 3   Constraints:  1 <= s.length <= 100 s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'. It is guaranteed that parentheses expression s is a VPS.",
                "intuition": "maintain a depth count\nif its an open parentheses add one\nif its a closed parentheses decrement one\nthe max count throught the process will be the max depth",
                "code": "class Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n\n        for char in s:\n            if char == \"(\":\n                depth += 1\n            elif char == \")\":\n                depth -= 1\n            max_depth = max(max_depth, depth)\n\n        return max_depth"
            }
        }
    },
    {
        "id": 3,
        "topic": "String",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Reverse words in a given string",
        "problem_link": "https://leetcode.com/problems/reverse-words-in-a-string ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/3_Reverse_words_in_a_given_string.py",
        "approaches": {
            "Brute": {
                "tc": "O(2N) ~ O(N)",
                "sc": "O(N)",
                "intuition": "extract only words from string and put them into the list reverse the list return the list by using join keyword",
                "code": "class Solution:\n    def split_string_to_words(self, s: str) -> list[str]:\n        words: list[str] = []\n        tmp: str = \"\"\n\n        for i in range(len(s)):\n            if s[i] == \" \":\n                if tmp:\n                    words.append(tmp)\n                    tmp = \"\"\n            else:\n                tmp += s[i]\n\n        if tmp:\n            words.append(tmp)\n\n        return words\n\n    def reverse_list(self, words: list[str]):\n        i, j = 0, len(words) - 1\n\n        while i < j:\n            words[i], words[j] = words[j], words[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        words = self.split_string_to_words(s)\n        self.reverse_list(words)\n        return \" \".join(words)"
            },
            "Better": {
                "tc": "O(N)",
                "sc": "O(N)",
                "intuition": "use pythons builtin split to split into words then reverse the list return the reversed list using join keyword",
                "code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(s.split()[::-1])"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given an input string s, reverse the order of the words.  A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.  Return a string of the words in reverse order concatenated by a single space.  Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.   Example 1:  Input: s = \"the sky is blue\" Output: \"blue is sky the\" Example 2:  Input: s = \"  hello world  \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:  Input: s = \"a good   example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.   Constraints:  1 <= s.length <= 10^4 s contains English letters (upper-case and lower-case), digits, and spaces ' '. There is at least one word in s.   Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
                "intuition": "reverse whole string first\nTake 2 pointers l and r it will be used to reverse words between them\nkeep moving i until you reach non space character , then assign the character at ith index with the character at r index\nwhen we encounter space , reverse words between l and r index\nmove r to one place after space and assign l to r, repeat the above process until i exhauts the string",
                "code": "class Solution:\n    def rev(self, i: int, j: int, s: list[str]):\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n\n    def reverseWords(self, s: str) -> str:\n        mutable_str = list(s)\n\n        self.rev(0, len(mutable_str) - 1, mutable_str)\n\n        l, r = 0, 0  # will be used for reversing string\n        i = 0  # will be used to traverse string\n        # r will be used for writing\n\n        while i < len(mutable_str):\n            while i < len(mutable_str) and mutable_str[i] != \" \":\n                mutable_str[r] = mutable_str[i]\n                i += 1\n                r += 1\n\n            if l < r:\n                self.rev(l, r - 1, mutable_str)\n                mutable_str[r] = \" \"\n                r += 1\n                l = r\n\n            i += 1\n\n        return \"\".join(mutable_str[: r - 1])"
            }
        }
    },
    {
        "id": 4,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Largest Odd Number in string",
        "problem_link": "https://leetcode.com/problems/largest-odd-number-in-string ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/4_Largest_Odd_Number_in_string.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists. A substring is a contiguous sequence of characters within a string.  Example 1:  Input: num = \"52\" Output: \"5\" Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number. Example 2:  Input: num = \"4206\" Output: \"\" Explanation: There are no odd numbers in \"4206\". Example 3:  Input: num = \"35427\" Output: \"35427\" Explanation: \"35427\" is already an odd number.   Constraints:  1 <= num.length <= 10^5 num only consists of digits and does not contain any leading zeros.",
                "intuition": "An odd number ends with either 1,3,5,7,9\nwe want the largest-valued odd number in\nthe string, so if we traverse from back of the string\nand find the first number that is not divisible by\n2 that will give us the larges possible odd number\nsubstring from the given input string",
                "code": "class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        for i in range(len(num) - 1, -1, -1):\n            if int(num[i]) % 2 != 0:\n                return num[: i + 1]\n        return \"\""
            }
        }
    },
    {
        "id": 5,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Longest Common Prefix",
        "problem_link": "https://leetcode.com/problems/longest-common-prefix ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/5_Longest_Common_Prefix.py",
        "approaches": {
            "Optimal": {
                "tc": "O(S)",
                "sc": "O(1)",
                "question": "Write a function to find the longest common prefix string amongst an array of strings.  If there is no common prefix, return an empty string \"\".   Example 1:  Input: strs = [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2:  Input: strs = [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings.   Constraints:  1 <= strs.length <= 200 0 <= strs[i].length <= 200 strs[i] consists of only lowercase English letters if it is non-empty.",
                "intuition": "Take a comparison string suppose the first word in strs\nKeep checking each character of the comparison_str , whether its\npresent in all words in the strs or not, if any time the char is\nnot common or the character index is greater than length of the\nword we return as from that moment onwards we dont have longest\nprefix substring\n\n\nfrom typing import List",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if len(strs) == 1:\n            return strs[0]\n\n        comparison_str = strs[0]\n        lcp = \"\"\n\n        for i, char in enumerate(comparison_str):\n            is_char_common = True\n            for st in strs:\n                if i + 1 > len(st) or st[i] != char:\n                    is_char_common = False\n                    return lcp\n            if is_char_common:\n                lcp += char\n\n        return lcp"
            }
        }
    },
    {
        "id": 6,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Isomorphic Strings",
        "problem_link": "https://leetcode.com/problems/isomorphic-strings ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/6_Isomorphic_Strings.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(2N)",
                "question": "Given two strings s and t, determine if they are isomorphic.  Two strings s and t are isomorphic if the characters in s can be replaced to get t.  All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.   Example 1:  Input: s = \"egg\", t = \"add\"  Output: true  Explanation:  The strings s and t can be made identical by:  Mapping 'e' to 'a'. Mapping 'g' to 'd'. Example 2:  Input: s = \"foo\", t = \"bar\"  Output: false  Explanation:  The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.  Example 3:  Input: s = \"paper\", t = \"title\"  Output: true   Constraints:  1 <= s.length <= 5 * 10^4 t.length == s.length s and t consist of any valid ascii character.",
                "intuition": "Just keep 2 hashmaps and assign a char of s to t and vice versa\nif a already assigned char from c does not matches with\nt and vice versa, return False otherwise at the end return True",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        cmap1, cmap2 = {}, {}\n\n        for i in range(len(s)):\n            c1 = s[i]\n            c2 = t[i]\n\n            if (c1 in cmap1 and cmap1[c1] != c2) or (c2 in cmap2 and cmap2[c2] != c1):\n                return False\n\n            cmap1[c1] = c2\n            cmap2[c2] = c1\n\n        return True"
            }
        }
    },
    {
        "id": 7,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Valid Anagram",
        "problem_link": "https://leetcode.com/problems/valid-anagram ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/7_Valid_Anagram.py",
        "approaches": {
            "Optimal": {
                "tc": "O(S)",
                "sc": "O(S)+O(T)",
                "question": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.   Example 1:  Input: s = \"anagram\", t = \"nagaram\"  Output: true  Example 2:  Input: s = \"rat\", t = \"car\"  Output: false   Constraints:  1 <= s.length, t.length <= 5 * 104 s and t consist of lowercase English letters.   Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
                "intuition": "Just compare the frequency map of\nthe 2 strings",
                "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        freq_map_s = {}\n        freq_map_t = {}\n\n        for i in range(len(s)):\n            freq_map_s[s[i]] = 1 + freq_map_s.get(s[i], 0)\n            freq_map_t[t[i]] = 1 + freq_map_t.get(t[i], 0)\n\n        return freq_map_s == freq_map_t"
            }
        }
    },
    {
        "id": 8,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Rotate String",
        "problem_link": "https://leetcode.com/problems/rotate-string ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/8_Rotate_String.py",
        "approaches": {
            "Brute": {
                "tc": "O(N^2)",
                "sc": "O(1)",
                "intuition": "Keep rotating the string by 1 if at any point we reach the goal string return True",
                "code": "class Solution:\n    def rotate_by_one(self, s: list[str]) -> str:\n        for i in range(len(s) - 1):\n            s[i], s[i + 1] = s[i + 1], s[i]\n        return \"\".join(s)\n\n    def rotateString(self, s: str, goal: str) -> bool:\n        for _ in range(len(s)):\n            s = self.rotate_by_one(list(s))\n            if s == goal:\n                return True\n\n        return False"
            },
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(1)",
                "question": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.  A shift on s consists of moving the leftmost character of s to the rightmost position.  For example, if s = \"abcde\", then it will be \"bcdea\" after one shift.   Example 1:  Input: s = \"abcde\", goal = \"cdeab\" Output: true Example 2:  Input: s = \"abcde\", goal = \"abced\" Output: false   Constraints:  1 <= s.length, goal.length <= 100 s and goal consist of lowercase English letters.",
                "intuition": "double concatentate the input string\nand check whether the goal exits in the\nconcatentated string",
                "code": "class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        if len(s) != len(goal):\n            return False\n\n        concatenated = s + s\n\n        return concatenated.find(goal) != -1"
            }
        }
    },
    {
        "id": 9,
        "topic": "String",
        "language": "python",
        "difficulty": "Easy",
        "problem_name": "Roman to Integer",
        "problem_link": "https://leetcode.com/problems/roman-to-integer ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/9_Roman_to_Integer.py",
        "approaches": {
            "Optimal": {
                "tc": "O(N)",
                "sc": "O(7)",
                "question": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.  Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.  Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.   Example 1:  Input: s = \"III\" Output: 3 Explanation: III = 3. Example 2:  Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3:  Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.   Constraints:  1 <= s.length <= 15 s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M'). It is guaranteed that s is a valid roman numeral in the range [1, 3999].",
                "intuition": "Keep iterating and Keep track of the final val\nsince roman nums are written from largest to smallest keep addding the\ncurrrent characters val if curr_char is lesser than prev_char , but\nif curr_char is greater then prev_char take out the prev_char from\nfinal val and add (curr_char-prev_char) to the final val",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_num_map = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000,\n        }\n\n        val: int = 0\n        val += roman_num_map[s[0]]\n\n        for i in range(1, len(s)):\n            curr_char: str = s[i]\n            prev_char: str = s[i - 1]\n\n            if roman_num_map[curr_char] > roman_num_map[prev_char]:\n                val -= roman_num_map[prev_char]\n                val += roman_num_map[curr_char] - roman_num_map[prev_char]\n            else:\n                val += roman_num_map[curr_char]\n\n        return val"
            }
        }
    },
    {
        "id": 10,
        "topic": "String",
        "language": "python",
        "difficulty": "Medium",
        "problem_name": "Integer to Roman",
        "problem_link": "https://leetcode.com/problems/integer-to-roman ",
        "solution_link": "https://raw.githubusercontent.com/glowfi/DS/main/Programs/python/3_String/10_Integer_to_Roman.py",
        "approaches": {
            "Brute": {
                "tc": "",
                "sc": "",
                "intuition": "",
                "code": ""
            },
            "Better": {
                "tc": "",
                "sc": "",
                "intuition": "",
                "code": ""
            },
            "Optimal": {
                "tc": "",
                "sc": "",
                "question": "Seven different symbols represent Roman numerals with the following values:  Symbol\tValue I\t1 V\t5 X\t10 L\t50 C\t100 D\t500 M\t1000 Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:  If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral. If the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM). Only powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form. Given an integer, convert it to a Roman numeral.   Example 1:  Input: num = 3749  Output: \"MMMDCCXLIX\"  Explanation:  3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M) 700 = DCC as 500 (D) + 100 (C) + 100 (C) 40 = XL as 10 (X) less of 50 (L) 9 = IX as 1 (I) less of 10 (X) Note: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places Example 2:  Input: num = 58  Output: \"LVIII\"  Explanation:  50 = L 8 = VIII Example 3:  Input: num = 1994  Output: \"MCMXCIV\"  Explanation:  1000 = M 900 = CM 90 = XC 4 = IV   Constraints:  1 <= num <= 3999",
                "intuition": "",
                "code": ""
            }
        }
    }
]